{"total":37,"pageSize":12,"pageCount":4,"data":[{"title":"Java内存泄露排查与Docker","uid":"b8168afdffad5b347df67f8a5b2d9b7b","slug":"Java内存泄露排查与Docker","date":"2023-10-05T07:34:50.000Z","updated":"2023-10-05T07:42:43.634Z","comments":true,"path":"api/articles/Java内存泄露排查与Docker.json","cover":null,"text":" 此处是说明如何在Docker环境下进行Java内存泄露排查工作。 前言之所以要进行Java内存排查，这是因为线上部署和运行后，服务器的内存总会不断增加，我认为...","permalink":"/post/Java内存泄露排查与Docker","photos":[],"count_time":{"symbolsCount":653,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"二分查找进阶-最小化最大值问题","uid":"ad7ad0115c35840e2a0cacdefdb15ded","slug":"二分查找进阶-最小化最大值问题","date":"2023-09-20T15:10:01.000Z","updated":"2023-09-26T01:02:26.116Z","comments":true,"path":"api/articles/二分查找进阶-最小化最大值问题.json","cover":null,"text":"最小化最大值介绍参考：二分法（二）：采用二分法解决“最小化最大值问题” - aTeacher - 博客园 (cnblogs.com) 二分法除了可以进行有序查找...","permalink":"/post/二分查找进阶-最小化最大值问题","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"二分查找","slug":"二分查找","count":1,"path":"api/tags/二分查找.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"数据结构-排序算法-基数排序","uid":"0d2dedcfb9b849bfcbbcb965f4e9512e","slug":"数据结构-排序算法-基数排序","date":"2023-09-17T04:25:43.000Z","updated":"2023-09-25T04:30:27.005Z","comments":true,"path":"api/articles/数据结构-排序算法-基数排序.json","cover":null,"text":"基数排序适合针对位数比较大的数值的排序，比如手机号等，其思路是构建多个桶，然后每个桶按照其个位数放，然后取出来，接着按照十位数放，再取出来，这样循环处理，就可以...","permalink":"/post/数据结构-排序算法-基数排序","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"数据结构-排序算法-桶排序","uid":"b4c95d269fe095846c4f40b3ac9ac15f","slug":"数据结构-排序算法-桶排序","date":"2023-09-17T03:39:29.000Z","updated":"2023-09-25T03:50:24.997Z","comments":true,"path":"api/articles/数据结构-排序算法-桶排序.json","cover":null,"text":"桶排序是在计数排序的基础上改进的，差不多对于有 n 个元素的计数排序上，就有 n 个桶，每个桶放一个元素，但是对于元素很大的数组时，这个情况存在数据超出容量的问...","permalink":"/post/数据结构-排序算法-桶排序","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"数据结构-排序算法-计数排序","uid":"48cb407f9899e0708dd5fe7c64470ce9","slug":"数据结构-排序算法-计数排序","date":"2023-09-17T03:00:56.000Z","updated":"2023-09-25T03:03:11.626Z","comments":true,"path":"api/articles/数据结构-排序算法-计数排序.json","cover":null,"text":"计数排序不需要元素交换要点： 找到最大值，创建一个大小为最大值+1的count数组 count 数组的索引对应原始数组的元素，用来统计该元素的出现次数 遍历co...","permalink":"/post/数据结构-排序算法-计数排序","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"数据结构-排序算法-希尔排序","uid":"6c54dccc3f8eb40068e225a095cab8fd","slug":"数据结构-排序算法-希尔排序","date":"2023-09-16T03:17:21.000Z","updated":"2023-09-24T03:20:46.909Z","comments":true,"path":"api/articles/数据结构-排序算法-希尔排序.json","cover":null,"text":"对插入排序的优化要点： 实现分组插入，每组元素之间的间隙为 gap 每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序。 对插入排序优化，让元素更快速...","permalink":"/post/数据结构-排序算法-希尔排序","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"数据结构-排序算法-插入排序","uid":"0871db5f0d6e98bd0968a11fb172bff1","slug":"数据结构-排序算法-插入排序","date":"2023-09-16T02:50:12.000Z","updated":"2023-09-24T02:54:16.497Z","comments":true,"path":"api/articles/数据结构-排序算法-插入排序.json","cover":null,"text":"注意要和选择排序区分插入排序的要点：【插入】 将数组分为两部分[0…low-1][low…a.length -1]左边是已排序的部分右边是未排序的部分 每次从未...","permalink":"/post/数据结构-排序算法-插入排序","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"数据结构-排序算法-堆排序","uid":"e918f5badebbffe3f81803dc092ebefe","slug":"数据结构-排序算法-堆排序","date":"2023-09-16T01:29:56.000Z","updated":"2023-09-24T02:54:48.187Z","comments":true,"path":"api/articles/数据结构-排序算法-堆排序.json","cover":null,"text":"在掌握堆排序前需要先理解堆的数据结构： 堆是一个完全二叉树。 在构建堆时，需要重点掌握下潜算法、上浮算法和建堆。 以大顶堆为例，下潜算法指的是如果所在的节点的数...","permalink":"/post/数据结构-排序算法-堆排序","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"排序算法","slug":"排序算法","count":6,"path":"api/tags/排序算法.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"二分查找的记录","uid":"9d323d77d023dce580918223b263aee7","slug":"二分查找的记录","date":"2023-09-14T12:30:33.000Z","updated":"2023-09-25T14:46:51.483Z","comments":true,"path":"api/articles/二分查找的记录.json","cover":null,"text":"二分查找程序在二分查找上，根据区间的确定，主要有二种不同的写法：左闭右闭，左闭右开。 在左闭右闭上，需要在 while 循环内满足 $left \\leq rig...","permalink":"/post/二分查找的记录","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"二分","slug":"二分","count":1,"path":"api/tags/二分.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"LRU与LFU的实现","uid":"9f1275f199e127f24dd271fc7f7f6a6f","slug":"LRU与LFU的实现","date":"2023-09-14T01:29:24.000Z","updated":"2023-09-26T02:07:58.847Z","comments":true,"path":"api/articles/LRU与LFU的实现.json","cover":null,"text":"参考资料：Redis 常见面试题 | 小林coding (xiaolincoding.com) LRULRU 与 LFU 都是缓存机制，也是 Redis 缓存淘...","permalink":"/post/LRU与LFU的实现","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"LRU","slug":"LRU","count":1,"path":"api/tags/LRU.json"},{"name":"LFU","slug":"LFU","count":1,"path":"api/tags/LFU.json"},{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"（Java复习总结）JVM简要总结","uid":"7668b55f818985386793a5565052eec1","slug":"（Java复习总结）JVM简要总结","date":"2023-09-02T06:01:29.000Z","updated":"2023-09-07T06:11:11.598Z","comments":true,"path":"api/articles/（Java复习总结）JVM简要总结.json","cover":[],"text":"复习资料：二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn) 字节码字节码 Java分为编译时与运行时，而字节码与编译...","permalink":"/post/（Java复习总结）JVM简要总结","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"（秋招笔试-美团）平均数为k的最长连续子数组","uid":"68722260f230b1d25b1de336fbf09213","slug":"（秋招笔试-美团）平均数为k的最长连续子数组","date":"2023-09-01T04:17:24.000Z","updated":"2023-09-07T01:02:12.885Z","comments":true,"path":"api/articles/（秋招笔试-美团）平均数为k的最长连续子数组.json","cover":null,"text":"题的来源： 平均数为k的最长连续子数组__牛客网 (nowcoder.com) 【重要的参考资料：560. 和为 K 的子数组 - 力扣（LeetCode）】 ...","permalink":"/post/（秋招笔试-美团）平均数为k的最长连续子数组","photos":[],"count_time":{"symbolsCount":956,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"刷题：前缀和","slug":"刷题：前缀和","count":1,"path":"api/tags/刷题：前缀和.json"},{"name":"刷题：哈希表","slug":"刷题：哈希表","count":1,"path":"api/tags/刷题：哈希表.json"},{"name":"秋招","slug":"秋招","count":1,"path":"api/tags/秋招.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}