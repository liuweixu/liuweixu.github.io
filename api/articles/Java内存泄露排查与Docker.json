{"title":"Java内存泄露排查与Docker","uid":"b8168afdffad5b347df67f8a5b2d9b7b","slug":"Java内存泄露排查与Docker","date":"2023-10-05T07:34:50.000Z","updated":"2023-10-05T07:42:43.634Z","comments":true,"path":"api/articles/Java内存泄露排查与Docker.json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>此处是说明如何在Docker环境下进行Java内存泄露排查工作。</p></blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之所以要进行Java内存排查，这是因为线上部署和运行后，服务器的内存总会不断增加，我认为这个与Java的内存泄露存在可能的联系，因而有必要进行线上的Java内存泄露排查工作。</p>\n<h2 id=\"使用的命令\"><a href=\"#使用的命令\" class=\"headerlink\" title=\"使用的命令\"></a>使用的命令</h2><p>因为Java的内存泄露主要与堆内存泄露有关，所以进行Java排查时，一般会使用Java的自带命令：jmap，这个可以生成堆内存快照文件，然后下载到本地，使用JRE自带的VisualVM进行分析就行。</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>因为之前的部署上，是一次性把所有环境都部署在Docker上，所以要先进入Docker的Java容器，然后才能用 jmap 命令，即：</p>\n<ol>\n<li><p>先使用Docker命令查看相应的容器的ID</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">docker ps</span></span></code></pre></div></li>\n<li><p>进入容器</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">docker</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">exec</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">-it</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">容器ID</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">bash</span></span></code></pre></div></li>\n<li><p>进入容器后，使用 jmap 命令，并且要用 top 命令查看 java 进程ID</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">jmap</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">-dump:format=b,file=/tmp/heapdump.hprof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #BABED8\">  </span><span style=\"color: #C3E88D\">//1是进程的ID</span></span></code></pre></div></li>\n<li><p>从Docker导出快照文件到服务器</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">docker</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">cp</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">容器ID:/tmp/heapdump.hprof</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">文件位置</span></span></code></pre></div></li>\n<li><p>直接下载到本地（可以使用Xftp等，工具不限）</p>\n</li>\n</ol>\n<h2 id=\"VisualVM\"><a href=\"#VisualVM\" class=\"headerlink\" title=\"VisualVM\"></a>VisualVM</h2><p>最后直接进入 JRE 文件夹里的 bin 下，找到 VM 的 exe 文件，直接打开就行，然后导入下载的快照文件，就可以分析内存是否泄露。</p>\n","feature":true,"text":" 此处是说明如何在Docker环境下进行Java内存泄露排查工作。 前言之所以要进行Java内存排查，这是因为线上部署和运行后，服务器的内存总会不断增加，我认为...","permalink":"/post/Java内存泄露排查与Docker","photos":[],"count_time":{"symbolsCount":653,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">使用的命令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker\"><span class=\"toc-text\">Docker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#VisualVM\"><span class=\"toc-text\">VisualVM</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"二分查找进阶-最小化最大值问题","uid":"ad7ad0115c35840e2a0cacdefdb15ded","slug":"二分查找进阶-最小化最大值问题","date":"2023-09-20T15:10:01.000Z","updated":"2023-09-26T01:02:26.116Z","comments":true,"path":"api/articles/二分查找进阶-最小化最大值问题.json","keywords":null,"cover":null,"text":"最小化最大值介绍参考：二分法（二）：采用二分法解决“最小化最大值问题” - aTeacher - 博客园 (cnblogs.com) 二分法除了可以进行有序查找...","permalink":"/post/二分查找进阶-最小化最大值问题","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"刷题","slug":"刷题","count":9,"path":"api/tags/刷题.json"},{"name":"二分查找","slug":"二分查找","count":1,"path":"api/tags/二分查找.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}