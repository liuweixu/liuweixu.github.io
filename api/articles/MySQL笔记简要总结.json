{"title":"MySQL笔记简要复习总结","uid":"cc0c0ae272578c20aede8e365a202e3c","slug":"MySQL笔记简要总结","date":"2023-01-11T11:38:03.000Z","updated":"2023-09-07T01:43:35.452Z","comments":true,"path":"api/articles/MySQL笔记简要总结.json","keywords":null,"cover":null,"content":"<p>阅读来源：<a href=\"https://javaguide.cn/database/sql/sql-syntax-summary.html\">SQL语法基础知识总结 | JavaGuide(Java面试 + 学习指南)</a></p>\n<h2 id=\"select聚类\"><a href=\"#select聚类\" class=\"headerlink\" title=\"select聚类\"></a>select聚类</h2><p>    select 语句中，如果没有 <code>GROUP BY</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity * item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity * item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p></blockquote>\n<h2 id=\"排序检索数据\"><a href=\"#排序检索数据\" class=\"headerlink\" title=\"排序检索数据\"></a>排序检索数据</h2><p><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</p>\n<p>知识点：</p>\n<ul>\n<li>逗号作用是用来隔开列与列之间的。</li>\n<li>ORDER BY 是有 BY 的，需要撰写完整，且位置正确</li>\n<li>知识点：<code>DISTINCT</code> 用于返回列中的唯一不同值、</li>\n<li>注意limit的使用，这个作用筛选某些值，比如筛选前面的几个值</li>\n</ul>\n<h2 id=\"过滤数据\"><a href=\"#过滤数据\" class=\"headerlink\" title=\"过滤数据\"></a>过滤数据</h2><p><code>WHERE</code> 可以过滤返回的数据。</p>\n<p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于。 <strong>注释：</strong> 在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;&#x3D;</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;&#x3D;</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n<tr>\n<td>IN</td>\n<td>指定针对某个列的多个可能值</td>\n</tr>\n</tbody></table>\n<h2 id=\"用通配符进行过滤\"><a href=\"#用通配符进行过滤\" class=\"headerlink\" title=\"用通配符进行过滤\"></a>用通配符进行过滤</h2><p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p>\n<p>在 SQL 中，可使用以下通配符：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>%</code></td>\n<td>代表零个或多个字符</td>\n</tr>\n<tr>\n<td><code>_</code></td>\n<td>仅替代一个字符</td>\n</tr>\n<tr>\n<td><code>[charlist]</code></td>\n<td>字符列中的任何单一字符</td>\n</tr>\n<tr>\n<td><code>[^charlist]</code> 或者 <code>[!charlist]</code></td>\n<td>不在字符列中的任何单一字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"使用函数处理数据\"><a href=\"#使用函数处理数据\" class=\"headerlink\" title=\"使用函数处理数据\"></a>使用函数处理数据</h2><p>知识点：</p>\n<ul>\n<li><p>截取函数<code>SUBSTRING()</code>：截取字符串，<code>substring(str ,n ,m)</code>（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；</p>\n</li>\n<li><p>拼接函数<code>CONCAT()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。</p>\n</li>\n<li><p>大写函数 <code>UPPER()</code>：将指定字符串转换为大写。</p>\n</li>\n</ul>\n<p>知识点：</p>\n<ul>\n<li>日期格式：<code>YYYY-MM-DD</code></li>\n<li>时间格式：<code>HH:MM:SS</code></li>\n</ul>\n<p>日期和时间处理相关的常用函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ADDDATE()</code></td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td><code>ADDTIME()</code></td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td><code>CURDATE()</code></td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td><code>CURTIME()</code></td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td><code>DATE()</code></td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td><code>DATEDIFF</code></td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td><code>DATE_FORMAT()</code></td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td><code>DAY()</code></td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td><code>DAYOFWEEK()</code></td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td><code>HOUR()</code></td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td><code>MINUTE()</code></td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td><code>MONTH()</code></td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td><code>NOW()</code></td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td><code>SECOND()</code></td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td><code>TIME()</code></td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td><code>YEAR()</code></td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n<h2 id=\"汇总数据\"><a href=\"#汇总数据\" class=\"headerlink\" title=\"汇总数据\"></a>汇总数据</h2><p>汇总数据相关的函数：</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AVG()</code></td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td><code>COUNT()</code></td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td><code>MAX()</code></td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td><code>MIN()</code></td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td><code>SUM()</code></td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n<h2 id=\"分组数据\"><a href=\"#分组数据\" class=\"headerlink\" title=\"分组数据\"></a>分组数据</h2><p><code>GROUP BY</code>：</p>\n<ul>\n<li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li>\n<li><code>GROUP BY</code> 为每个组返回一个记录。</li>\n<li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li>\n<li><code>GROUP BY</code> 可以按一列或多列进行分组。</li>\n<li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li>\n</ul>\n<p><code>HAVING</code>：</p>\n<ul>\n<li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li>\n<li><code>HAVING</code> 必须要与 <code>GROUP BY</code> 连用。</li>\n<li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li>\n</ul>\n<p><code>HAVING</code> vs <code>WHERE</code>：</p>\n<ul>\n<li><code>WHERE</code>：过滤指定的行，后面不能加聚合函数（分组函数）。</li>\n<li><code>HAVING</code>：过滤分组，必须要与 <code>GROUP BY</code> 连用，不能单独使用。</li>\n</ul>\n<h2 id=\"使用子查询\"><a href=\"#使用子查询\" class=\"headerlink\" title=\"使用子查询\"></a>使用子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p>\n<p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p>\n<p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p>\n<ul>\n<li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li>\n<li><strong>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</strong></li>\n<li>from</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote>\n<p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">SELECT column_name [, column_name ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM table1 [, table2 ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">WHERE column_name operator</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">(SELECT column_name [, column_name ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM table1 [, table2 ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">[WHERE])</span></span></code></pre></div><ul>\n<li>子查询需要放在括号<code>( )</code>内。</li>\n<li><code>operator</code> 表示用于 <code>WHERE</code> 子句的运算符，可以是比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code> 等）或逻辑运算符（如 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code>, <code>NOT EXISTS</code> 等），具体根据需求来确定。</li>\n</ul>\n<p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">SELECT column_name [, column_name ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM (SELECT column_name [, column_name ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">      FROM table1 [, table2 ]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">      [WHERE]) AS temp_table_name [, ...]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">[JOIN type JOIN table_name ON condition]</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">WHERE condition;</span></span></code></pre></div><ul>\n<li>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</li>\n<li>子查询需要放在括号 <code>( )</code> 内。</li>\n<li>可以指定多个临时表名，并使用 <code>JOIN</code> 语句连接这些表</li>\n</ul>\n<h2 id=\"连接表\"><a href=\"#连接表\" class=\"headerlink\" title=\"连接表\"></a>连接表</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p>\n<p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p>\n<p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">SELECT table1.column1, table2.column2...</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM table1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">JOIN table2</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">ON table1.common_column1 = table2.common_column2;</span></span></code></pre></div><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p>\n<p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p>\n<p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\"># join....on</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">SELECT c.cust_name, o.order_num</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM Customers c</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">INNER JOIN Orders o</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">ON c.cust_id = o.cust_id</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">ORDER BY c.cust_name</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\"># 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....USING()</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">SELECT c.cust_name, o.order_num</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">FROM Customers c</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">INNER JOIN Orders o</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">USING(cust_id)</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">ORDER BY c.cust_name</span></span></code></pre></div><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p>\n<ul>\n<li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li>\n<li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li>\n</ul>\n<p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p>\n<p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>连接类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>INNER JOIN 内连接</td>\n<td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td>\n</tr>\n<tr>\n<td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td>\n<td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td>\n<td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td>\n</tr>\n<tr>\n<td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td>\n<td>只要其中有一个表存在满足条件的记录，就返回行。</td>\n</tr>\n<tr>\n<td>SELF JOIN</td>\n<td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td>\n</tr>\n<tr>\n<td>CROSS JOIN</td>\n<td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td>\n</tr>\n</tbody></table>\n<p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p>\n<h2 id=\"组合查询\"><a href=\"#组合查询\" class=\"headerlink\" title=\"组合查询\"></a>组合查询</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p>\n<p><code>UNION</code> 基本规则：</p>\n<ul>\n<li>所有查询的列数和列顺序必须相同。</li>\n<li>每个查询中涉及表的列的数据类型必须相同或兼容。</li>\n<li>通常返回的列名取自第一个查询。</li>\n</ul>\n<p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">SELECT column_name(s) FROM table1</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">UNION ALL</span></span>\n<span class=\"line\"><span style=\"color: #babed8\">SELECT column_name(s) FROM table2;</span></span></code></pre></div><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p>\n<p><code>JOIN</code> vs <code>UNION</code>：</p>\n<ul>\n<li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li>\n<li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li>\n</ul>\n<p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后 或者直接使用or做</p>\n<p>在组合查询上，union的作用和or类似</p>\n<h2 id=\"删除记录\"><a href=\"#删除记录\" class=\"headerlink\" title=\"删除记录\"></a>删除记录</h2><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p>\n<table>\n<thead>\n<tr>\n<th>Filed</th>\n<th>Type</th>\n<th>Null</th>\n<th>Key</th>\n<th>Extra</th>\n<th>Default</th>\n<th>Comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td>PRI</td>\n<td>auto_increment</td>\n<td>(NULL)</td>\n<td>自增 ID</td>\n</tr>\n<tr>\n<td>uid</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>用户 ID</td>\n</tr>\n<tr>\n<td>exam_id</td>\n<td>int(11)</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>试卷 ID</td>\n</tr>\n<tr>\n<td>start_time</td>\n<td>datetime</td>\n<td>NO</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>开始时间</td>\n</tr>\n<tr>\n<td>submit_time</td>\n<td>datetime</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>提交时间</td>\n</tr>\n<tr>\n<td>score</td>\n<td>tinyint(4)</td>\n<td>YES</td>\n<td></td>\n<td></td>\n<td>(NULL)</td>\n<td>分数</td>\n</tr>\n</tbody></table>\n<p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;</p>\n<p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p>\n<ul>\n<li><code>DROP</code>: 清空表，删除表结构，不可逆</li>\n<li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li>\n<li><code>DELETE</code>：删除数据，可逆</li>\n</ul>\n<p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p>\n<p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p>\n<p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>\n","text":"阅读来源：SQL语法基础知识总结 | JavaGuide(Java面试 + 学习指南) select聚类 select 语句中，如果没有 GROUP BY 语句...","permalink":"/post/MySQL笔记简要总结","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#select%E8%81%9A%E7%B1%BB\"><span class=\"toc-text\">select聚类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">排序检索数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">过滤数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4\"><span class=\"toc-text\">用通配符进行过滤</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">使用函数处理数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">汇总数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">分组数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">使用子查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E8%A1%A8\"><span class=\"toc-text\">连接表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">组合查询</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">删除记录</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"（开发笔记）平台数据库开发记录总结","uid":"a2a04591aa24c2e458792273dc89fac0","slug":"（开发笔记）平台数据库开发记录总结","date":"2023-02-21T07:42:36.000Z","updated":"2023-09-07T02:03:38.586Z","comments":true,"path":"api/articles/（开发笔记）平台数据库开发记录总结.json","keywords":null,"cover":null,"text":"添加到数据库时 如果是Mapper，一般是用insert方法或save方法 而用这些方法前，一般会设置dto类，并创建dto方法，然后用BeansUtils将传...","permalink":"/post/（开发笔记）平台数据库开发记录总结","photos":[],"count_time":{"symbolsCount":129,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"（开发笔记）平台开发时所使用的JSON记录总结","uid":"5b339b9c114d051588672244c783d1ca","slug":"（开发笔记）平台开发时所使用的JSON记录总结","date":"2023-01-10T01:05:01.000Z","updated":"2023-09-07T02:12:57.275Z","comments":true,"path":"api/articles/（开发笔记）平台开发时所使用的JSON记录总结.json","keywords":null,"cover":null,"text":"JSONJSON的作用是实现序列化，用于将Java中的对象转化为JSON字符串，方便返回给前端。 平台使用的JSON是fastjson，阿里开源的，但是Java...","permalink":"/post/（开发笔记）平台开发时所使用的JSON记录总结","photos":[],"count_time":{"symbolsCount":296,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}