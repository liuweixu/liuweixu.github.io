{"title":"（开发笔记）平台使用的技术简要总结_杂记（随时间更新）","uid":"535536b539f073c2d793d87577695f87","slug":"（开发笔记）平台使用的技术简要总结-杂记（随时间更新）","date":"2023-04-01T12:50:20.000Z","updated":"2023-09-07T02:30:48.607Z","comments":true,"path":"api/articles/（开发笔记）平台使用的技术简要总结-杂记（随时间更新）.json","keywords":null,"cover":null,"content":"<p>JSON 阿里巴巴的fastjson  </p>\n<p>StringUtils  </p>\n<ul>\n<li><p>不同的包也有不同的方法  </p>\n</li>\n<li><p>isNotBlank 和 isEmpty也是不同的方法</p>\n</li>\n</ul>\n<p>BeansUtils springframework的  </p>\n<p>@RequestBody  </p>\n<p>Arrays类，比如asList  </p>\n<p>IDEA快捷键，比如Ctrl+SHIFT+t 可以构建测试类  </p>\n<p>DFA算法，雪花算法 DFA有点像前缀树  </p>\n<p>spring.factories 作用探讨  </p>\n<p>Tess4j 图片识别 把图片的文字提出来，然后识别文字是否存在问题  </p>\n<p>同步 异步 @Aynsn  </p>\n<p>Freemarker Template Configuration  </p>\n<p>StringWriter  </p>\n<p>apArticleService.update(Wrappers.<ApArticle>lambdaUpdate().eq(ApArticle::getId,apArticle.getId()).set(ApArticle::getStaticUrl,path)); set用法  </p>\n<p>乐观锁 悲观锁  </p>\n<ul>\n<li><p>乐观锁： 每次拿数据的时候都认为别人不会修改，所以不上锁，但是每次更新时会判断之前被人是否改过，用版本号机制等判断  </p>\n<p>用@Version 标明是版本号，用乐观锁  </p>\n<p>MP对乐观锁有支持，只需要加个拦截器配置，分页机制也是  </p>\n</li>\n<li><p>悲观锁：而悲观锁则是每次拿数据时都认为别人会修改，所以每次拿数据都会上锁</p>\n</li>\n</ul>\n<p>StringRedisTemplate StringRedisConnection  </p>\n<ul>\n<li><p>Scan方法  </p>\n</li>\n<li><p>分布式锁 Setnx</p>\n</li>\n</ul>\n<p>Calendar Date 日期类  </p>\n<p>getTime()  </p>\n<p>测试类  </p>\n<ul>\n<li>@SpringBootTest(classes &#x3D; ScheduleApplication.class)<br>@RunWith(SpringRunner.class)</li>\n</ul>\n<p>@Schedule  </p>\n<p>@PostConstruct 有初始化的方法  </p>\n<p>@PathVariable 占位符  </p>\n<p>Feign（重点！！！！！）  </p>\n<p>枚举类的撰写  </p>\n<p>Protostuff序列化  </p>\n<p>@Scheduled @EnableScheduling  </p>\n<p>MP如何更新数据  </p>\n<p>DigestUtils  </p>\n<p>定时任务框架-xxljob</p>\n","text":"JSON 阿里巴巴的fastjson StringUtils 不同的包也有不同的方法 isNotBlank 和 isEmpty也是不同的方法 BeansUtil...","permalink":"/post/（开发笔记）平台使用的技术简要总结-杂记（随时间更新）","photos":[],"count_time":{"symbolsCount":987,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"toc":"","author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"（开发笔记）平台开发的注意事项简要记录","uid":"5da0e7c1ff981f5dde4015103b247300","slug":"（开发笔记）平台开发的注意事项简要记录","date":"2023-04-23T03:30:58.000Z","updated":"2023-09-07T03:35:45.270Z","comments":true,"path":"api/articles/（开发笔记）平台开发的注意事项简要记录.json","keywords":null,"cover":null,"text":"nacos配置问题每次正确添加nacos配置后，如果碰上某个微服务的错误，此时要考虑是不是不小心加上了无关的依赖库，尤其是okhttp 。 延迟队列问题延迟队列...","permalink":"/post/（开发笔记）平台开发的注意事项简要记录","photos":[],"count_time":{"symbolsCount":334,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"（开发笔记）注解总结之@RequestBody","uid":"4a84d38afea4c32655f17f427273c865","slug":"（开发笔记）注解总结之-RequestBody","date":"2023-03-10T03:28:20.000Z","updated":"2023-09-07T03:30:04.344Z","comments":true,"path":"api/articles/（开发笔记）注解总结之-RequestBody.json","keywords":null,"cover":null,"text":"@RequestBody 是一个Spring框架中的注解，用于将HTTP请求的内容（例如JSON、XML等）绑定到方法的参数上。它通常与Spring MVC或S...","permalink":"/post/（开发笔记）注解总结之-RequestBody","photos":[],"count_time":{"symbolsCount":893,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"开发","slug":"开发","count":7,"path":"api/tags/开发.json"},{"name":"注解与反射","slug":"注解与反射","count":1,"path":"api/tags/注解与反射.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}