[{"id":"b8168afdffad5b347df67f8a5b2d9b7b","title":"Java内存泄露排查与Docker","content":"\n\n\n\n\n\n\n\n\n此处是说明如何在Docker环境下进行Java内存泄露排查工作。\n前言之所以要进行Java内存排查，这是因为线上部署和运行后，服务器的内存总会不断增加，我认为这个与Java的内存泄露存在可能的联系，因而有必要进行线上的Java内存泄露排查工作。\n使用的命令因为Java的内存泄露主要与堆内存泄露有关，所以进行Java排查时，一般会使用Java的自带命令：jmap，这个可以生成堆内存快照文件，然后下载到本地，使用JRE自带的VisualVM进行分析就行。\nDocker因为之前的部署上，是一次性把所有环境都部署在Docker上，所以要先进入Docker的Java容器，然后才能用 jmap 命令，即：\n\n先使用Docker命令查看相应的容器的ID\ntxtdocker ps\n进入容器\nshelldocker exec -it 容器ID bash\n进入容器后，使用 jmap 命令，并且要用 top 命令查看 java 进程ID\nshelljmap -dump:format=b,file=/tmp/heapdump.hprof 1  //1是进程的ID\n从Docker导出快照文件到服务器\nshelldocker cp 容器ID:/tmp/heapdump.hprof 文件位置\n直接下载到本地（可以使用Xftp等，工具不限）\n\n\nVisualVM最后直接进入 JRE 文件夹里的 bin 下，找到 VM 的 exe 文件，直接打开就行，然后导入下载的快照文件，就可以分析内存是否泄露。\n","slug":"Java内存泄露排查与Docker","date":"2023-10-05T07:34:50.000Z","categories_index":"","tags_index":"Java,开发","author_index":"Aurora"},{"id":"ad7ad0115c35840e2a0cacdefdb15ded","title":"二分查找进阶-最小化最大值问题","content":"最小化最大值介绍参考：二分法（二）：采用二分法解决“最小化最大值问题” - aTeacher - 博客园 (cnblogs.com) \n二分法除了可以进行有序查找、解方程等外，还可以用来解决一些实际问题。这些问题中，非常典型的应用就是“最小化最大值问题”和“最大化最小值问题”\n   “最小化最大值问题”和“最大化最小值问题”在优化问题中比较常见，简单来说，“最小化最大值”是为了压制优化目标中表现最突出的成分，“最大化最小值”为了提升优化目标中表现最差的成分。\n   （1）“最小化最大值问题”\n   一般来说，优化时考虑的是目标函数的最大化或最小化的问题。但是在某些情况下，则要求最大值的最小化才有意义。例如，在城市规划中需要确定急救中心、消防中心的位置，可取的目标函数应该是到所有地点最大距离的最小值（即急救中心、消防中心的建设位置应保证它到最远需求点的距离尽可能小），而不是到达所有目的地距离和的最小值。因为城市同时发生事故或同时着火的几率极低，因此更多应该考虑如何降低最恶劣情况的影响，即使是最远的地方出事了，中心到它们的距离也能达到最小。\n   （2）“最大化最小值问题”\n   这个问题在通信链路中应用比较多，如基站同时和多用户通信，每个基站到用户的通信为一个通信链路，且基站的发射功率是固定的。为了保证所有的通信链路都正常工作，应该去优化最差链路的通信情况，降低信道较好链路的基站发射功率，增加信道较差链路的基站发射功率，这是一个最大化最小值问题。\n典型的 leetcode题410. 分割数组的最大值该题是典型的最小化最大值问题，即将各个连续数组的和最大值取得最小值。\n思路：要解决这个最小化最大值的问题，基本思路就是选取任意一个范围（输入数组的最大值到数组所有元素的和），然后在这个范围内进行二分法，每次把范围的中间值 mid 当作最小值，然后判断在 mid 值下数组是否能够被分为 m 个部分。如果判断出值为 mid 时可以将数组分成 m 个部分，就先让mid变大再试试，即增大下界（left&#x3D;mid+1）；如果分不成 m 个部分，说明当前的 mid 太大了，就先让 mid 变小再进行判断，即减小上界（right&#x3D;mid-1）。直到求出一个最大的mid就是最终的答案。\n因为要求各个子数组和的最大值中的最小，所以该值肯定大于等于所有数组的最大值，并且肯定小于等于数组的所有和，并且这个数值是连续递增，于是可以用二分解决。\n最后，针对二分出来的答案是否在数组的元素内？答案是肯定的，假如找到一个合适的 mid ，满足所有要求，但是其值不在元素中，此时该 mid 还可以进一步减去 1，这样一直继续循环下去，可以得到最大的下限。\njavaclass Solution &#123;\n    boolean judge(int[] a, int mid, int m)&#123;\n        int sum = 0, count = 0;\n        for(int i = 0; i &lt; a.length; i++)&#123;\n            sum += a[i];\n            if(sum &gt; mid)&#123;\n                sum = a[i];\n                count++;\n            &#125;\n        &#125;\n        if(count + 1 &lt;= m)&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n    public int splitArray(int[] nums, int k) &#123;\n        int left = -1, right = 0;\n        int mid;\n        for(int i = 0; i &lt; nums.length; i++)&#123;\n            right += nums[i];\n            if(nums[i] &gt; left)&#123;\n                left = nums[i];\n            &#125;\n        &#125;\n        while(left &lt;= right)&#123;\n            mid = (left + right) / 2;\n            if(judge(nums, mid, k))&#123;\n                right = mid - 1;\n            &#125;\n            else&#123;\n                left = mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;2560. 打家劫舍IV2560. 打家劫舍 IV - 力扣（LeetCode）\n该题和之前的三个打家劫舍问题不同的是，其题是最小化最大值问题，所以更适合用二分方法。\n思路：\n从中可知，最大值是小偷窃取过程中能从单间房屋中窃取的最大金额，所以最小值就是该数组的最小值，而最大值则是该数组的最大值，并且可以认为这些数值是递增，所以可以用二分。\n求解时需要得到一个最大的下限，该值可以能够满足至少窃取 $k$ 个房屋后，小偷的最小窃取能力。求解该问题时，可以用贪心思路，即在从左到右遍历数组时，能偷就偷。\njavaclass Solution &#123;\n    public int minCapability(int[] nums, int k) &#123;\n        int left = Arrays.stream(nums).min().getAsInt();\n        int right = Arrays.stream(nums).max().getAsInt();\n        while(left &lt;= right)&#123;\n            int middle = left + (right - left) / 2;\n            int count = 0;\n            for(int i = 0; i &lt; nums.length; i++)&#123;\n                if(nums[i] &lt;= middle)&#123;\n                    count++;\n                    i++; //如果当前偷了，就必须跳过下一个房子\n                &#125;\n            &#125;\n            if(count &gt;= k)&#123;\n                right = middle - 1;\n            &#125;\n            else&#123;\n                left = middle + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;","slug":"二分查找进阶-最小化最大值问题","date":"2023-09-20T15:10:01.000Z","categories_index":"","tags_index":"刷题,二分查找","author_index":"Aurora"},{"id":"0d2dedcfb9b849bfcbbcb965f4e9512e","title":"数据结构-排序算法-基数排序","content":"基数排序适合针对位数比较大的数值的排序，比如手机号等，其思路是构建多个桶，然后每个桶按照其个位数放，然后取出来，接着按照十位数放，再取出来，这样循环处理，就可以对数值进行排序。\n基数排序 vs 计数排序 vs 桶排序\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n\n基数排序：根据键值的每位数字来分配桶\n计数排序：每个桶只存储单一键值\n桶排序：每个桶存储一定范围的数值\n\njavaimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/*\n针对11位的手机号排序\n */\npublic class RadisSort &#123;\n    private static void radisSort(String[] a)&#123;\n        List&lt;String&gt;[] buckets = new ArrayList[10];\n        for(int i = 0; i &lt; 10; i++)&#123;\n            buckets[i] = new ArrayList&lt;&gt;();\n        &#125;\n        /*\n        从低位向高位排序\n         */\n        for(int i = a[0].length() - 1; i &gt;= 0; i--)&#123;\n            for (String s : a) &#123;\n                buckets[s.charAt(i) - &#39;0&#39;].add(s);\n            &#125;\n            int k = 0;\n            for (List&lt;String&gt; bucket : buckets) &#123;\n                for (String s : bucket) &#123;\n                    a[k++] = s;\n                &#125;\n                bucket.clear();\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        String[] a = &#123;&quot;1113123123&quot;, &quot;1133123123&quot;, &quot;1133123087&quot;, &quot;1133123123&quot;, &quot;1233123123&quot;&#125;;\n        System.out.println(Arrays.toString(a));\n        radisSort(a);\n        System.out.println(Arrays.toString(a));\n    &#125;\n&#125;拓展\n如果数值里面有 abc 等字符时，如何排序？\n只需要将桶的个数增加就行，比如增加到 128，刚好存下 ASCII 的字符。\n","slug":"数据结构-排序算法-基数排序","date":"2023-09-17T04:25:43.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"b4c95d269fe095846c4f40b3ac9ac15f","title":"数据结构-排序算法-桶排序","content":"桶排序是在计数排序的基础上改进的，差不多对于有 n 个元素的计数排序上，就有 n 个桶，每个桶放一个元素，但是对于元素很大的数组时，这个情况存在数据超出容量的问题，所以需要设置每个桶放多个元素，并且放完后，需要对桶里面的元素排序。\n然后需要创建动态数组，因为不确定每个桶里面会有多少个元素，所以针对每个桶要分别加个动态数组，此处可以使用 2 个 ArrayList 或 DynamicArray 来创建。\n最后，需要注意的是，针对-9-9这个较为极端的情况下，需要手动设置每个桶放置的元素个数，并且需要借鉴计数排序，求出最大值和最小值，然后计算合适的桶的个数，以及怎么将每个元素放到合适的桶上（关键点是最小值）。\n其平均时间复杂度是 O(n+k)，但是最差的时间复杂度可以有 O(n^2)。\njavaimport java.util.*;\n\npublic class BucketSort &#123;\n    private static void bucketsort(int[] a, int range)&#123;\n        int max = a[0];\n        int min = a[0];\n        for(int i = 0; i &lt; a.length; i++)&#123;\n            max = Math.max(max, a[i]);\n            min = Math.min(min, a[i]);\n        &#125;\n        List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();\n        for(int i = 0; i &lt; (max - min) / range + 1; i++)&#123;\n            buckets.add(new ArrayList&lt;&gt;());\n        &#125;\n        for(int i = 0; i &lt; a.length; i++)&#123;\n            buckets.get((a[i] - min) / range).add(a[i]);\n        &#125;\n        for(int i = 0; i &lt; buckets.size(); i++)&#123;\n            Collections.sort(buckets.get(i));\n        &#125;\n//        for (int i = 0; i &lt; buckets.size(); i++) &#123;\n//            System.out.println(Arrays.toString(buckets.get(i).toArray()));\n//        &#125;\n        int k = 0;\n        for(int i = 0; i &lt; buckets.size(); i++)&#123;\n            while(buckets.get(i).size() &gt; 0)&#123;\n                a[k++] = buckets.get(i).get(0);\n                buckets.get(i).remove(0);\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;2, 1, 3, -1, 6, 9, 10, 12, 17&#125;;\n        System.out.println(Arrays.toString(a));\n        bucketsort(a, 3);\n        System.out.println(Arrays.toString(a));\n    &#125;\n&#125;","slug":"数据结构-排序算法-桶排序","date":"2023-09-17T03:39:29.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"48cb407f9899e0708dd5fe7c64470ce9","title":"数据结构-排序算法-计数排序","content":"计数排序不需要元素交换要点：  \n\n找到最大值，创建一个大小为最大值+1的count数组  \ncount 数组的索引对应原始数组的元素，用来统计该元素的出现次数  \n遍历count数组，根据count数组的索引（即原始数组的元素）以及出现次数，生成排序后的内容count 数组的索引是：已排序好的\n\n上述技术排序的前提：待排序元素 &gt;&#x3D; 0，且不能太大如何改进？（对负数排序）也要找最小值，将最小值映射为索引为0\n时间复杂度大概在 O(N + K)，比较低了，属于以空间换时间的一个典型例子。\njavaimport java.util.Arrays;\n\npublic class CountingSort &#123;\n    private static void countingsort(int[] a)&#123;\n        int max = a[0];\n        int min = a[0];\n        for(int i = 1; i &lt; a.length; i++)&#123;\n            if(a[i] &gt; max)&#123;\n                max = a[i];\n            &#125;\n            if(a[i] &lt; min)&#123;\n                min = a[i];\n            &#125;\n        &#125;\n        int[] count = new int[max - min + 1];\n        for(int i = 0; i &lt; a.length; i++)&#123;\n            count[a[i] - min]++;\n        &#125;\n        int k = 0;\n        for(int i = 0; i &lt; count.length; i++)&#123;\n            while(count[i] &gt; 0)&#123;\n                a[k++] = i + min;\n                count[i]--;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;2, 1, -1, 4, -2, 10&#125;;\n        System.out.println(Arrays.toString(a));\n        countingsort(a);\n        System.out.println(Arrays.toString(a));\n    &#125;\n&#125;","slug":"数据结构-排序算法-计数排序","date":"2023-09-17T03:00:56.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"6c54dccc3f8eb40068e225a095cab8fd","title":"数据结构-排序算法-希尔排序","content":"对插入排序的优化要点：  \n\n实现分组插入，每组元素之间的间隙为 gap  \n每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序。  \n对插入排序优化，让元素更快速交换到最终位置。  \n插入排序可以视为希尔排序上的 gap 为 1 时的特殊情况 ，所以程序上和插入排序类似。\n平均时间复杂度是 **O(nlogn)**，最差时间复杂度是 O(n^2) ，最好的时间复杂度是O(nlogn)\n算法是不稳定的。\n\njavaimport java.util.Arrays;\n\n/*\n对插入排序的优化\n要点：\n- 实现分组插入，每组元素之间的间隙为gap\n- 每轮排序后gap逐渐变小，直至gap为1完成排序。\n- 对插入排序优化，让元素更快速交换到最终位置。\n- 插入排序可以视为希尔排序上的gap为1时的特殊情况\n- 平均时间复杂度是O(nlogn)，最差时间复杂度是O(n^2)，最好的时间复杂度是O(nlogn)\n */\npublic class ShellSort &#123;\n    public static void shellsort(int[] a)&#123;\n        //a.length / 2\n        for (int gap = a.length &gt;&gt; 1; gap &gt;=1  ; gap &gt;&gt;= 1) &#123;\n            for (int low = gap; low &lt; a.length; low++) &#123;\n                int t = a[low];\n                int i = low - gap;\n                //自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置\n                while(i &gt;= 0 &amp;&amp; t &lt; a[i])&#123;\n                    a[i+gap] = a[i];\n                    i--;\n                &#125;\n                if(i != low - gap)&#123;\n                    a[i+gap] = t;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;2, 1, 4, 5, 7, 9, 4, 1, 2, 3&#125;;\n        System.out.println(Arrays.toString(a));\n        shellsort(a);\n        System.out.println(Arrays.toString(a));\n    &#125;\n&#125;","slug":"数据结构-排序算法-希尔排序","date":"2023-09-16T03:17:21.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"0871db5f0d6e98bd0968a11fb172bff1","title":"数据结构-排序算法-插入排序","content":"注意要和选择排序区分插入排序的要点：【插入】  \n\n将数组分为两部分[0…low-1][low…a.length -1]左边是已排序的部分右边是未排序的部分  \n每次从未排序区域取出low位置的元素，插入到已排序的区域。\n有递归版本和非递归版本，下面使用的是非递归版本\n\njavaimport java.util.Arrays;\n\n/*\n注意和选择排序区分\n插入排序的要点：【插入】\n1. 将数组分为两部分[0...low-1][low...a.length -1]\n    左边是已排序的部分\n    右边是未排序的部分\n2. 每次从未排序区域取出low位置的元素，插入到已排序的区域。\n */\npublic class InsertSort &#123;\n    /*\n    非递归版本\n     */\n    private static void insertion(int[] a)&#123;\n        for (int low = 1; low &lt; a.length; low++) &#123;\n            int t = a[low];\n            int i = low - 1;\n            //自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置\n            while(i &gt;= 0 &amp;&amp; t &lt; a[i])&#123;\n                a[i+1] = a[i];\n                i--;\n            &#125;\n            if(i != low - 1)&#123;\n                a[i+1] = t;\n            &#125;\n        &#125;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;9, 3, 7, 2, 5, 8, 1, 4&#125;;\n        System.out.println(Arrays.toString(a));\n        insertion(a);\n        System.out.println(Arrays.toString(a));\n    &#125;\n&#125;","slug":"数据结构-排序算法-插入排序","date":"2023-09-16T02:50:12.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"e918f5badebbffe3f81803dc092ebefe","title":"数据结构-排序算法-堆排序","content":"在掌握堆排序前需要先理解堆的数据结构：\n\n堆是一个完全二叉树。\n\n在构建堆时，需要重点掌握下潜算法、上浮算法和建堆。\n\n以大顶堆为例，下潜算法指的是如果所在的节点的数值比左右子节点要小，就需要交换，此时可以使用递归方法。\n\n还是以大顶堆为例，上浮算法指的是如果所在的节点的值比其父节点的值要大，就要逐步交换，可以使用while函数\n\n如果要从小到大的排序，则需要使用大顶堆\n\n建立大顶堆\n\n每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让其重新符合大顶堆的特性，并逐步缩减，直至堆的元素数量为1为止。\n\n\n\n\njavaimport java.util.Arrays;\n\npublic class Heap&#123;\n    int[] array;\n    int size;\n    public Heap(int capacity)&#123;\n        this.array = new int[capacity];\n    &#125;\n    public Heap(int[] array)&#123;\n        this.array = array;\n        this.size = array.length;\n        heapify();\n    &#125;\n    /*\n    建堆 Floyd建堆方法， 时间复杂度O(n)\n     */\n    public void heapify()&#123;\n        for (int i = size / 2 - 1; i &gt;= 0 ; i--) &#123;\n            down(i);\n        &#125;\n    &#125;\n    /*\n    下潜\n     */\n    private void down(int parent)&#123;\n        int left = parent * 2 + 1;\n        int right = left + 1;\n        int max = parent;\n        if(left &lt; size &amp;&amp; array[max] &lt; array[left])&#123;\n            max = left;\n        &#125;\n        if(right &lt; size &amp;&amp; array[max] &lt; array[right])&#123;\n            max = right;\n        &#125;\n        if(max != parent)&#123;\n            swap(max, parent);\n            down(max);\n        &#125;\n    &#125;\n    private void swap(int i, int j)&#123;\n        int t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    &#125;\n\n    /*\n    获取堆顶函数\n     */\n    public int peek()&#123;\n        if(size == 0)&#123;\n            return Integer.MIN_VALUE;\n        &#125;\n        return array[0];\n    &#125;\n\n    /*\n    删除堆顶元素\n     */\n    public int poll() &#123;\n        if(size == 0)&#123;\n            return Integer.MIN_VALUE;\n        &#125;\n        int top = array[0];\n        swap(0, size - 1);\n        size--;\n        down(0);\n        return top;\n    &#125;\n    /*\n    删除指定索引处的元素\n    */\n    public int poll(int index)&#123;\n        if(size == 0)&#123;\n            return Integer.MIN_VALUE;\n        &#125;\n        int deleted = array[index];\n        swap(index, size - 1);\n        size--;\n        down(index);\n        return deleted;\n    &#125;\n    /*\n    替换堆顶元素\n     */\n    public void replace(int replaced)&#123;\n        if(size == 0)&#123;\n            return;\n        &#125;\n        array[0] = replaced;\n        down(0);\n    &#125;\n    /*\n    堆的尾部添加元素\n     */\n    public boolean offer(int offered)&#123;\n        if(size == array.length)&#123;\n            return false;\n        &#125;\n        up(offered);\n        size++;\n        return true;\n    &#125;\n    /*\n    上浮\n     */\n    private void up(int offered)&#123;\n        int child = size;\n        while(child &gt; 0)&#123;\n            int parent = (child - 1) / 2;\n            if(offered &gt; array[parent])&#123;\n                array[child] = array[parent];\n            &#125;else&#123;\n                break;\n            &#125;\n            child = parent;\n        &#125;\n        array[child] = offered;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        /*\n\n         */\n        int[] array = &#123;2, 3, 1, 7, 6, 4, 5&#125;;\n        Heap heap = new Heap(array);\n        System.out.println(Arrays.toString(heap.array));\n\n        while(heap.size &gt; 1)&#123;\n            heap.swap(0, heap.size - 1);\n            heap.size--;\n            heap.down(0);\n        &#125;\n\n        System.out.println(Arrays.toString(heap.array));\n    &#125;\n&#125;\n//public class Heap &#123;\n//    public static void main(String[] args) &#123;\n//\n//    &#125;\n//&#125;","slug":"数据结构-排序算法-堆排序","date":"2023-09-16T01:29:56.000Z","categories_index":"","tags_index":"刷题,排序算法","author_index":"Aurora"},{"id":"9d323d77d023dce580918223b263aee7","title":"二分查找的记录","content":"二分查找程序在二分查找上，根据区间的确定，主要有二种不同的写法：左闭右闭，左闭右开。\n在左闭右闭上，需要在 while 循环内满足 $left \\leq right$，并且在 right 要为$middle-1$。\n而在左闭右开上，则是需要在 while 循环内满足 $left &lt; right$，并且在 right 要为 $middle$。\n以左闭右闭为例，程序有:\njavapublic class BinarySearch &#123;\n    private static int binarysearch(int[] a, int target)&#123;\n        int left = 0, right = a.length - 1;\n        int candidate = -1;\n        while(left &lt;= right)&#123;\n            int middle = left + (right - left) / 2;\n            if(a[middle] &gt; target)&#123;\n                right = middle - 1;\n            &#125;\n            else if(a[middle] &lt; target)&#123;\n                left = middle + 1;\n            &#125;\n            else&#123;\n                return middle;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;1, 3, 5, 7, 9, 10, 11, 13&#125;;\n        System.out.println(binarysearch(a, 10));\n    &#125;\n&#125;二分查找的最大查找次数在上述程序进行修改，就可以得到计算查找次数的程序，如下：\njavapublic class BinarySearch &#123;\n    private static int binarysearch(int[] a, int target)&#123;\n        int left = 0, right = a.length - 1;\n        int res = 0;\n        int candidate = -1;\n        while(left &lt;= right)&#123;\n            int middle = left + (right - left) / 2;\n            res++;\n            if(a[middle] &gt; target)&#123;\n                right = middle - 1;\n            &#125;\n            else if(a[middle] &lt; target)&#123;\n                left = middle + 1;\n            &#125;\n            else&#123;\n                candidate = middle;\n                break;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n    public static void main(String[] args) &#123;\n        int[] a = &#123;1, 3, 5, 7, 9, 10, 11, 13&#125;;\n        System.out.println(binarysearch(a, 15));\n    &#125;\n&#125;输出的结果是 4 ，也就是说，如果查找不到元素时，最大的查找次数就是 4，而如果数组长度为 7，相应的最大查找次数是 3，这个是有相应的公式：\n$$res &#x3D; \\lfloor log_2(N) \\rfloor +1$$\n 其中$N$为数组的长度。\n二分查找时的最左和最右元素问题：34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）\n需要在一个有序数组上，查找某个元素的第一个和最后一个位置，也可以在上述的程序的基础上，加以修改得到的，关键是如果 $left &#x3D;&#x3D; right$ 时，针对 $middle$ 加一或减一，从而让指针向右移动或向左移动，得到目标元素的最后一个位置或第一个位置。\njavaclass Solution &#123;\n    private static int leftBorder(int[] nums, int target)&#123;\n        int left = 0, right = nums.length - 1;\n        int candidate = -1;\n        while(left &lt;= right)&#123;\n            int middle = left + (right - left) / 2;\n            if(nums[middle] &lt; target)&#123;\n                left = middle + 1;\n            &#125;\n            else if(nums[middle] &gt; target)&#123;\n                right = middle - 1;\n            &#125;\n            else&#123;\n                candidate = middle;\n                right = middle - 1;\n            &#125;\n        &#125;\n        return candidate;\n    &#125;\n    private static int rightBorder(int[] nums, int target)&#123;\n        int left = 0, right = nums.length - 1;\n        int candidate = -1;\n        while(left &lt;= right)&#123;\n            int middle = left + (right - left) / 2;\n            if(nums[middle] &lt; target)&#123;\n                left = middle + 1;\n            &#125;\n            else if(nums[middle] &gt; target)&#123;\n                right = middle - 1;\n            &#125;\n            else&#123;\n                candidate = middle;\n                left = middle + 1;\n            &#125;\n        &#125;\n        return candidate;\n    &#125;\n    public int[] searchRange(int[] nums, int target) &#123;\n        return new int[]&#123;leftBorder(nums, target), rightBorder(nums, target)&#125;;\n    &#125;\n&#125;","slug":"二分查找的记录","date":"2023-09-14T12:30:33.000Z","categories_index":"","tags_index":"数据结构,刷题,二分","author_index":"Aurora"},{"id":"9f1275f199e127f24dd271fc7f7f6a6f","title":"LRU与LFU的实现","content":"参考资料：Redis 常见面试题 | 小林coding (xiaolincoding.com)\nLRULRU 与 LFU 都是缓存机制，也是 Redis 缓存淘汰机制的重要实现，在 Redis 4.0 前使用的缓存机制是 LRU，即最近最少使用，会选择淘汰最近最少使用的数据。\n传统 LRU传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。\nRedis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：\n\n需要用链表管理所有的缓存数据，这会带来额外的空间开销；\n当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。\n\nRedis 的 LRU\n\n\n\n\n\n\n\n\n然后 Redis 如何实现 LRU 算法？\nRedis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。\n当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。\n\n\n\n\n\n\n\n\n\nRedis 实现的 LRU 算法的优点：\n\n不用为所有的数据维护一个大链表，节省了空间占用；\n不用在每次数据访问时都移动链表项，提升了缓存的性能；\n\nLRU 的问题但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。\nLFU为了解决上述的缓存污染问题，Redis 4,0 引入 LFU 算法。\nLFU含义LFU 全称是 Least Frequently Used 翻译为最近最不常用的，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。\n所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。\nLFU的实现LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。\n程序实现LRU题型来源：146. LRU 缓存 - 力扣（LeetCode）\nLRU 的实现主要使用双向链表和哈希表，其中双向链表用于保存缓存数据，而哈希表则是用于快速判断缓存数据是否存在。\n\n\n\n\n\n\n\n\n\n为什么使用双向链表？\n答：之所以要用双向链表，这是因为为了能够让其删除头部和尾部元素时的时间复杂度能够为 $O(1)$。\n在构建双向链表的类时，需要构建三个方法：添加头部元素、删除已知的节点和删除尾部节点。\n然后构建 LRU 类时，需要构建二个方法：get 和 put。\n在 get 方法上，主要有 2 种可能，即使用哈希表查不到元素和查到了元素。如果查不到元素，就直接返回 -1，而如果查到了，需要将这个结点移动到链表的开头（为了让最近最久未使用的节点放在链表的末尾）。\n在 put 方法上，也有 2 种可能，查到元素和查不到元素。 如果查到元素，就把这个结点移动到链表的开头。如果查不到，就在链表的开头加这个元素，如果链表的长度超过容量，还需要删除尾部元素。\n程序实现（Leetcode版本）\njava/*\n * @lc app=leetcode.cn id=146 lang=java\n *\n * [146] LRU 缓存\n */\nimport java.util.*;\n\n// @lc code=start\nclass LRUCache &#123;\n    // 双向链表的节点定义\n    class Node&#123;\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        public Node()&#123;&#125;;\n        public Node(int key, int value)&#123;\n            this.key = key;\n            this.value = value;\n        &#125;\n    &#125;\n\n    class DLinkedList&#123;\n        Node head;\n        Node tail;\n\n        public DLinkedList()&#123;\n            head = tail = new Node();\n            head.next = tail;\n            tail.prev = head;\n        &#125;\n\n        //头部添加 head &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; tail;\n        public void addFisrt(Node newFirst)&#123;\n            Node oldFirst = head.next;\n            newFirst.prev = head;\n            newFirst.next = oldFirst;\n            head.next = newFirst;\n            oldFirst.prev = newFirst;\n        &#125;\n        //已知节点删除\n        public void remove(Node node)&#123;\n            Node prev = node.prev;\n            Node next = node.next;\n            prev.next = next;\n            next.prev = prev;\n        &#125;\n\n        //尾部节点删除\n        public Node removeLast()&#123;\n            Node last = tail.prev;\n            remove(last);\n            return last;\n        &#125;\n    &#125;\n\n    private Map&lt;Integer, Node&gt; hashMap = new HashMap&lt;&gt;();\n    private DLinkedList list = new DLinkedList();\n    private int capacity;\n    private Node head, tail;\n\n    // 初始化\n    public LRUCache(int capacity) &#123;\n        this.capacity = capacity;\n\n        head = new Node(); //创建新的节点\n        tail = new Node(); // 创建新的节点\n        head.next = tail;\n        tail.prev = head;\n    &#125;\n    \n    /*\n     * 2种可能\n     * 返回的是查到的节点的值，如果查到，要将这个结点移动到链表的开头\n     */\n    public int get(int key) &#123;\n        if(!hashMap.containsKey(key))&#123;\n            return -1;\n        &#125;\n        Node node = hashMap.get(key);\n        list.remove(node);\n        list.addFisrt(node);\n        return node.value;\n    &#125;\n    \n    /**\n     * 增加节点 2种可能\n     * 需要考虑容量的问题\n     * @param key\n     * @param value\n     */\n    public void put(int key, int value) &#123;\n        if(hashMap.containsKey(key))&#123;\n            Node node = hashMap.get(key);\n            list.remove(node);\n            node.value = value;\n            list.addFisrt(node);\n        &#125;\n        else&#123;\n            Node node = new Node(key, value);\n            hashMap.put(key, node);\n            list.addFisrt(node);\n            if(hashMap.size() &gt; capacity)&#123;\n                Node last = list.removeLast();\n                hashMap.remove(last.key);\n            &#125;\n        &#125;\n    &#125;\n\n\n&#125;\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n// @lc code=end\nLFU题型来源：460. LFU 缓存 - 力扣（LeetCode）\n和 LRU 的实现相比， LFU 的实现难度其实更大。\nLFU 的实现需要使用一个双向链表和 2 个哈希表，双向链表是用于保存数据的，而哈希表一个（用 kvMap 表示）是用来判断缓存数据是否存在，而另一个哈希表（用 freqMap 表示）上，key 表示缓存的次数，而 value 则是双向链表，这是为了能够在缓存次数一样时，就直接按照 LRU 的方法删除最近最久未使用的元素。\n在构建双向链表的类时，需要构建四个方法：添加头部元素、删除已知的节点、删除尾部节点和判断链表是否为空。\n然后构建 LRU 类时，需要构建二个方法：get 和 put。\n在 get 方法上，主要有 2 种可能，即使用 kvMap 查不到元素和查到了元素。如果查不到元素，就直接返回 -1，而如果查到了，需要在 freqMap 上对相应的查找次数上的链表上，将该元素删除，然后将该元素的查找次数 + 1，接着将该元素移动到新的查找次数下的链表的开头。\n在 put 方法上，也有 2 种可能，KvMap 查到元素和查不到元素。 如果查到元素，操作和 get 方法查到的元素一样。如果查不到，首先子在 kvMap 上添加该元素，然后判断 freqMap 上的 key 为 1 的链表是否存在，如果不存在，就新建一个，然后将该元素添加到这个链表的开头。\njava/*\n * @lc app=leetcode.cn id=460 lang=java\n *\n * [460] LFU 缓存\n */\n\n// @lc code=start\n\nimport java.util.HashMap;\n\nclass LFUCache &#123;\n    class Node&#123;\n        Node prev;\n        Node next;\n        int key;\n        int value;\n        int freq;\n        public Node()&#123;&#125;;\n        public Node(int key, int value)&#123;\n            this.key = key;\n            this.value = value;\n        &#125;\n    &#125;\n\n    class DLinkedList&#123;\n        Node head;\n        Node tail;\n        int size;\n\n        public DLinkedList()&#123;\n            head = tail = new Node();\n            head.next = tail;\n            tail.prev = head;\n            size = 0;\n        &#125;\n\n        //头部添加 head &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; tail;\n        public void addFisrt(Node newFirst)&#123;\n            Node oldFirst = head.next;\n            newFirst.prev = head;\n            newFirst.next = oldFirst;\n            head.next = newFirst;\n            oldFirst.prev = newFirst;\n            size++;\n        &#125;\n        //已知节点删除\n        public void remove(Node node)&#123;\n            Node prev = node.prev;\n            Node next = node.next;\n            prev.next = next;\n            next.prev = prev;\n            size--;\n        &#125;\n\n        //尾部节点删除\n        public Node removeLast()&#123;\n            Node last = tail.prev;\n            remove(last);\n            return last;\n        &#125;\n\n        //判断是否是空\n        public boolean isEmpty()&#123;\n            return size == 0;\n        &#125;\n    &#125;\n\n    private int capacity;\n    private HashMap&lt;Integer, Node&gt; kvMap = new HashMap&lt;&gt;();\n    private HashMap&lt;Integer, DLinkedList&gt; freqMap = new HashMap&lt;&gt;();\n    private int minFreq = 1;\n    private int size;\n    private Node head, tail;\n\n    public LFUCache(int capacity) &#123;\n        this.capacity = capacity;\n\n        head = new Node(); //创建新的节点\n        tail = new Node(); // 创建新的节点\n        head.next = tail;\n        tail.prev = head;\n        size = 0;\n        \n    &#125;\n\n\n    public int get(int key) &#123;\n        if(!kvMap.containsKey(key))&#123;\n            return -1;\n        &#125;\n        Node node = kvMap.get(key);\n        freqMap.get(node.freq).remove(node);\n        if(freqMap.get(node.freq).isEmpty() &amp;&amp; node.freq == minFreq)&#123;\n            minFreq++;\n        &#125;\n        node.freq++;\n        // DLinkedList list = freqMap.get(node.freq);\n        // if(list == null)&#123;\n        //     list = new DLinkedList();\n        //     freqMap.put(node.freq, list);\n        // &#125;\n        // list.addFisrt(node);\n        freqMap.computeIfAbsent(node.freq, k -&gt; new DLinkedList()).addFisrt(node);\n        return node.value;\n    &#125;\n    \n    public void put(int key, int value) &#123;\n        if(kvMap.containsKey(key))&#123;\n            Node node = kvMap.get(key);\n            freqMap.get(node.freq).remove(node);\n            if(freqMap.get(node.freq).isEmpty() &amp;&amp; node.freq == minFreq)&#123;\n                minFreq++;\n            &#125;\n            node.freq++;\n            DLinkedList list = freqMap.get(node.freq);\n            if(list == null)&#123;\n                list = new DLinkedList();\n                freqMap.put(node.freq, list);\n            &#125;\n            list.addFisrt(node);\n            // freqMap.computeIfAbsent(node.freq, k -&gt; new DLinkedList()).addFisrt(node);\n            node.value = value;\n        &#125;\n        else&#123;\n            if(kvMap.size() == capacity)&#123;\n                Node node = freqMap.get(minFreq).removeLast();\n                kvMap.remove(node.key);\n            &#125;\n            Node node = new Node(key, value);\n            kvMap.put(key, node);\n            DLinkedList list = freqMap.get(1);\n            if(list == null)&#123;\n                list = new DLinkedList();\n                freqMap.put(1, list);\n            &#125;\n            list.addFisrt(node);\n            node.freq = 1;\n            // freqMap.computeIfAbsent(1, k-&gt;new DLinkedList()).addFisrt(node);\n            minFreq = 1;\n        &#125;\n    &#125;\n&#125;\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n// @lc code=end\n\n","slug":"LRU与LFU的实现","date":"2023-09-14T01:29:24.000Z","categories_index":"","tags_index":"数据结构,LRU,LFU,刷题","author_index":"Aurora"},{"id":"7668b55f818985386793a5565052eec1","title":"（Java复习总结）JVM简要总结","content":"复习资料：二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)\n字节码字节码\nJava分为编译时与运行时，而字节码与编译时有关。\n\n类加载机制与字节码密切相关。\n\nIDEA 默认会用 Fernflower 反编译工具将字节码文件（后缀为 .class 的文件，也就是 Java 源代码编译后的文件）反编译为我们可以看得懂的 Java 源代码。\n\n在编译阶段，Java会将Java源代码文件编译为字节码文件。在这个阶段，编译器会进行一些检查工作，比如说，某个关键字是不是写错了，语法上是不是符合预期了，不能有很明显的错误，否则带到运行时再检查出来就会比较麻烦了。\n\nJava 字节码是沟通 JVM 与 Java 代码的桥梁，可以用javap查看。\n\nJava虚拟机采用基于栈的架构，其指令由操作码与操作数组成。\n0xb2 getstatic 获取静态字段的值0x12 ldc 常量池中的常量值入栈0xb6 invokevirtual 运行时方法绑定调用方法0xb1 return void 函数返回\n\nJVM会在准备阶段对类变量（静态变量， static修饰）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。\n也就是说，假如有这样一段代码：\njavapublic String chenmo = &quot;沉默&quot;; //会查看常量池是否存在，只创建一个对象\npublic static String wanger = &quot;王二&quot;;\npublic static final String cmower = &quot;沉默王二&quot;;chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 null。\n需要注意的是，static final 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 null。\n\n\nClass文件详解Java的类文件（class文件）结构 | Java程序员进阶之路 (tobebetterjavaer.com)\n\n使用xxd命令后，得到16进制内容，其中如果开头有cafe base这个魔数，说明这个class文件可以被JVM接受。\n\n上面往后抽空看。\nJavap与字节码从javap的角度轻松看懂字节码 | Java程序员进阶之路 (tobebetterjavaer.com)\n上面抽空看\n\nJava 内置了一个反编译命令 javap，可以通过 javap -help 了解 javap 的基本用法\n\n常量池\nConstant pool，也就是字节码文件最重要的常量池部分。可以把常量池理解为字节码文件中的资源仓库，主要存放两大类信息。\n1）字面量（Literal），有点类似 Java 中的常量概念，比如文本字符串，final 常量等。\n2）符号引用（Symbolic References），属于编译原理方面的概念，包括 3 种：\n\n类和接口的全限定名（Fully Qualified Name）\n字段的名称和描述符（Descriptor）\n方法的名称和描述符\n\nJava 虚拟机是在加载字节码文件的时候才进行的动态链接，也就是说，字段和方法的符号引用只有经过运行期转换后才能获得真正的内存地址。当 Java 虚拟机运行时，需要从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。\n\n\nJVM字节码详情虚拟机 字节码HSDBASM史上最通俗易懂的ASM教程 | Java程序员进阶之路 (tobebetterjavaer.com)\n前面有讲基础内容。\n自己编译JDK类加载类加载\n类加载过程\nLoading\nVerification\nPreparation【编译时阶段】\nResolution【运行时阶段】\n\n该阶段将常量池中的符号引用转化为直接引用。\n符号引用以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。（就是不知道内存地址，先暂时用它的名字，也就是符号）\n在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 com.Wanger 类引用了 com.Chenmo 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 com.Chenmo。\n直接引用通过对符号引用进行解析，找到引用的实际内存地址。\n\n\nInitialization\n\n该阶段是类加载过程的最后一步。在准备阶段，类变量已经被赋过默认初始值，而在初始化阶段【运行时阶段】，类变量将被赋值为代码期望赋的值。换句话说，初始化阶段是执行类构造器方法的过程。\n\n\n类加载器\nJava 类加载器可以分为三种。【黑马八股文有讲】\n注意：这个三种是JDK8之前的情况，JDK9有改动。\n1）启动类（或者说引导类）加载器（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar，通常以null表示。\n2）扩展类加载器（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件，它的父类加载器为引导类加载器。\n3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。它的父类加载器为扩展类加载器。\nJDK9的改动：\nJava 9仍然保留了三层类加载器结构，不过为了支持模块系统，对它们做了一些调整。扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。Java 9中的内置类加载器如下所示。\n\n引导类加载器：定义核心Java SE和JDK模块。\n\n平台类加载器：定义部分Java SE和JDK模块。\n\n应用或系统类加载器：定义CLASSPATH上的类和模块路径中的模块。\n\n\n关键程序：\njava```Java\nClassLoader classLoader = ClassLoaderMain.class.getClassLoader();\nwhile (classLoader != null) &#123;\n  System.out.println(classLoader);\n  classLoader = classLoader.getParent();\n&#125;txt\n双亲委派模型\n如果以上三种类加载器不能满足要求的话，程序员还可以自定义类加载器（继承 java.lang.ClassLoader 类），它们之间的层级关系如下图所示。\n【图片见https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/jvm/class-load-02.png】\n自定义类加载器的父类是应用类加载器（JDK8前）\n这种层次关系被称作为双亲委派模型：如果一个类加载器收到了加载类的请求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。\n使用双亲委派模型有一个很明显的好处，那就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。\n上文中曾提到，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等——双亲委派模型能够保证同一个类最终会被特定的类加载器加载。\n\n\n内存与垃圾回收JVM内存结构程序计数器\n程序计数器（Program Counter Register）所占的内存空间不大，很小一块，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个计数器的值来选取下一条需要执行的字节码指令，像分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\n\n在 JVM 中，多线程是通过线程轮流切换来获得 CPU 执行时间的，因此，在任一具体时刻，一个 CPU 的内核只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，并且不能互相干扰，否则就会影响到程序的正常执行次序。\n也就是说，我们要求程序计数器是线程私有的。\n\n《Java 虚拟机规范》中规定，如果线程执行的是非本地（native）方法，则程序计数器中保存的是当前需要执行的指令地址；如果线程执行的是本地方法，则程序计数器中的值是 undefined。\n为什么本地方法在程序计数器中的值是 undefined 的？因为本地方法大多是通过 C&#x2F;C++ 实现的，并未编译成需要执行的字节码指令。\n由于程序计数器中存储的数据所占的空间不会随程序的执行而发生大小上的改变，因此，程序计数器是不会发生内存溢出现象（OutOfMemory）的。\n\n\nJava虚拟机栈Java虚拟机是如何执行字节码指令的？ | Java程序员进阶之路 (tobebetterjavaer.com)\n堆\n所有线程共享的一块内存区域。在 Java 虚拟机启动的时候创建，用来存储对象（数组也是一种对象，new创建）。\n以前，Java 中“几乎”所有的对象都会在堆中分配，但随着 JIT（Just-In-Time）编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么“绝对”了。从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了，意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n堆是 Java 垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度来看，由于垃圾收集器基本都采用了分代垃圾收集的算法，所以堆还可以细分为：新生代和老年代。新生代还可以细分为：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。\n堆这最容易出现的就是 OutOfMemoryError 错误，分为以下几种表现形式：\nOutOfMemoryError: GC Overhead Limit Exceeded：当JVM花费太多时间执行垃圾回收并且只能回收很少的堆空间时，会发生这个错误的，就是堆空间爆满。\njava.lang.OutOfMemoryError: Java heap space：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。和本机的物理内存无关，和我们配置的虚拟机内存大小有关！\n\n\n\n元空间https://tobebetterjavaer.com/jvm/neicun-jiegou.html#_05、元空间\n\nJDK8后，元空间取代方法区（或者说永久代），方法区和堆一样，是线程共享的区域，它用来存储已经被 Java 虚拟机加载的类信息、常量、静态变量，以及编译后的代码等。\n\n在方法区中，还有一块非常重要的部分，也就是运行时常量池【字节码上很重要】。在讲 class 文件的时候，提到了每个 class 文件都会有个常量池，用来存放字符串常量、类和接口的名字、字段名、常量等等。运行时常量池和 class 文件的常量池是一一对应的，它就是通过 class 文件中的常量池来构建的。\nJDK 7 之前，运行时常量池中包含着字符串常量池，都在方法区。\nJDK 7 的时候，字符串常量池从方法区中拿出来放到了堆中，运行时常量池中的其他东西还在方法区中\n\nJDK 8 的时候，HotSpot 移除了永久代，也就是说方法区不存在了，取而代之的是元空间。也就意味着字符串常量池在堆中，运行时常量池跑到了元空间。\n再来说说为什么要将永久代 (PermGen) 或者说方法区替换为元空间 (MetaSpace) 。\n第一，永久代放在 Java 虚拟机中，就会受到 Java 虚拟机内存大小的限制，而元空间使用的是本地内存，也就脱离了 Java 虚拟机内存的限制。\n第二，JDK 8 的时候，在 HotSpot 中融合了 JRockit 虚拟机，而 JRockit 中并没有永久代的概念，因此新的 HotSpot 就没有必要再开辟一块空间来作为永久代了。\n\n\nJava创建对象问题：创建对象的时候，对象是在堆内存中创建的。但堆内存又分为新生代和老年代，新生代又细分为 Eden 空间、From Survivor 空间、To Survivor 空间。那我们创建的对象到底在哪里？\nJava 创建的对象到底放在哪？ | 二哥的Java进阶之路\n\nJava垃圾回收咱们从头到尾说一次Java垃圾回收 | Java程序员进阶之路 (tobebetterjavaer.com)\n图解Java的垃圾回收机制 | Java程序员进阶之路 (tobebetterjavaer.com)\nJava中9种常见的CMS GC问题分析与解决 | Java程序员进阶之路 (tobebetterjavaer.com)\n","slug":"（Java复习总结）JVM简要总结","date":"2023-09-02T06:01:29.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"68722260f230b1d25b1de336fbf09213","title":"（秋招笔试-美团）平均数为k的最长连续子数组","content":"题的来源：\n平均数为k的最长连续子数组__牛客网 (nowcoder.com)\n【重要的参考资料：560. 和为 K 的子数组 - 力扣（LeetCode）】\n题解：\n因为题意中，有：“连续子数组”与“平均数”这两个重要条件，所以可以用上前缀和，这是因为平均数乘以k就是一个子数组的和，另外，这个题与DP无关的。另外，注意结果要用Long。\n又因为数据范围过大，需要使用哈希表，防止超时。\njavaimport java.util.Arrays;\nimport java.util.*;\n\nclass Main&#123;\n    public static void main(String[] args) &#123;\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long k = in.nextLong();\n        Map&lt;Long, Integer&gt; hashMap = new HashMap&lt;&gt;();\n        hashMap.put(0L, 0);\n        long pre = 0L;\n        int ans = -1;\n        for(int i = 1; i &lt;= n; i++)&#123;\n            long cur = pre + in.nextLong() - k;\n            if(hashMap.containsKey(cur))&#123;\n                ans = Math.max(ans, i - hashMap.get(cur));\n            &#125;\n            else&#123;\n                hashMap.put(cur, i);\n            &#125;\n            pre = cur;\n        &#125;\n        System.out.println(ans);\n    &#125;\n&#125;上述没有建立前缀和数组。\n","slug":"（秋招笔试-美团）平均数为k的最长连续子数组","date":"2023-09-01T04:17:24.000Z","categories_index":"","tags_index":"刷题：前缀和,刷题：哈希表,秋招","author_index":"Aurora"},{"id":"c0cf9f2ee6076c351fdadf6a5a89ace4","title":"（Java复习总结）多线程简要总结","content":"复习资料：二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)\nSynchronized\nSyschronized是关键字，可以修饰实例方法、静态方法和代码块。\n\n修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁；\n修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁；\n修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁\n\n可以让实例方法、静态方法等变为一个临界区\nJava的锁都是基于对象的。\n\nsynchronized可以保证原子性、可见性（能够替代volatile）和有序性。\n而volatile只能保证可见性与有序性，不能保证原子性。\n\nsynchronized是悲观锁。\n\n几个锁的等级排序【要回顾】\n无锁&lt;偏向锁&lt;轻量级锁&lt;重量级锁\n\n\nCAS\nsynchronized是悲观锁\n而CAS是乐观锁\n悲观锁：\n悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。\n乐观锁：\n乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。\n由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。\n乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。\n\n\n锁总结[重要，查阅该网址]公司空降一个美团大佬，彻底把Java中的锁”讲清楚了 | 二哥的Java进阶之路 (javabetter.cn)\n\n","slug":"（Java复习总结）多线程简要总结","date":"2023-08-28T03:58:30.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"1230bafa710dd471057d709666f4e18a","title":"（Java复习总结）面对对象","content":"复习资料：二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)\n构造方法\n在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。构造方法有无参构造方法与有参构造方法两种。\n注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。\n必须得要有构造方法，这样才能让类的对象初始化为null或其他值。\n没有返回值，但是返回的是类的对象。\n不仅能做初始化工作，还可以做其他工作，比如启动线程、调用其他方法等。\n\n构造方法必须符合以下规则：\n1）构造方法的名字必须和类名一样；\n2）构造方法没有返回类型，包括 void，否则会当成普通方法来处理。\n3）构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。\n简单解析一下最后一条规则：\n1）由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；\n2）构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；\n3）多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。\n\n方法与构造方法之间的区别：\n\n\n复制对象的方式\n复制一个对象可以通过下面三种方式完成：\n\n通过构造方法\n通过对象的值\n通过 Object 类的 clone() 方法\n\n\n\n权限修饰符\n补充一些关于 Java 包和类文件的知识：\n1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；\n2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。\n另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。\n\n\n","slug":"（Java复习总结）面对对象","date":"2023-08-22T05:55:12.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"39c3baf125857a0ddb46522ae75bacb7","title":"（Java复习总结）数组与字符串","content":"复习资料：掌握Java数组：一个非常特殊的对象 | 二哥的Java进阶之路 (javabetter.cn)\n数组的初始化方式\nint[] anArray &#x3D; new int[10]; new 方式创建数组对象\nint anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};\n\n无效的数组初始化方式以下是一些初始化数组的无效方法。\njava// 无效，因为未提供维度\nint[] a = new int[];\n// 无效，因为未提供最左侧的维度值\nint[][] aa = new int[][5];以下是在java中声明数组的一些其他变体，但强烈建议不要使用它们以避免混淆。\njavaint[] twoArrInt[] = new int[4][5];\nint twoIntArr[][] = new int[5][];String的声明（String不可变）\n“第一，String 类是 final的，意味着它不能被子类继承。”\n“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”\n“第三，String 类实现了 Comparable 接口，意味着最好不要用‘&#x3D;&#x3D;’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”\n\n","slug":"（Java复习总结）数组与字符串","date":"2023-08-21T01:52:34.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"978310dc6cad989500c585bf21064346","title":"（Java复习总结）Java数据类型笔记","content":"二哥的Java\n基本类型\n字符字面量应该用单引号（’’）包围，而不是双引号（””），因为双引号表示字符串字面量\n\nchar 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。\n自动转换：\nbyte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; doublechar -&gt; int -&gt; long -&gt; float -&gt; double\n强制转换：\ndouble -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte\n\nInteger.toBinaryString() 将证书转为二进制数，String类型的\n\n字符常量\n必须使用单引号\n‘\\n’也算是字符常量\n\n\n接口\n接口不能初始化，也就是说不能使用new。\n\n基本数据与引用数据之间的区别基本数据类型：\n\n1、变量名指向具体的数值。\n2、基本数据类型存储在栈上。\n\n引用数据类型：\n\n1、变量名指向的是存储对象的内存地址，在栈上。\n2、内存地址指向的对象存储在堆上。\n\n堆和栈堆：\n\n是程序运行时在内存中申请的空间（可理解为动态的过程），不是在编译时。\n动态申请的数据存储位置，比如数组与创建的对象（new方式）等。\n\n栈：\n\n栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。\n一般放的是编程语句等，对象引用也行，即：Object o这样子，作为对象的引用。\n\n一个例子：【参考】\njavaPhone phone = new Phone;通常会认为 phone 就是 Phone 类的对象。实际上，phone 是创建 Phone 类的对象的引用。\n这个表述实际上执行的操作：\n\nnew Phone() 是在内存中为对象开辟空间。其实也就是 new 关键字表示在内存的 堆（heap） 上为对象开辟空间，该空间保存了对象的属性和方法。\nPhone phone ：phone 指代一个 Phone 对象，被称为 对象引用。实际上，phone 并不是对象本身，而是一个类似执行对象的指针。phone 存在于内存的栈（stack） 中。\n当用等号赋值时，是将右侧 new Phone() 在堆中创建对象的地址赋给对象引用 phone 。\n\n为什么要这样操作？简单来讲，有以下几种优点：\n\n栈的读取速度比堆块，但栈上存储的数据受到有效范围的限制。\n一个对象引用可以赋值给另一个对象引用，此时复制的实际上是对象的地址。因此，一个对象可以由多个对象引用，减少对内存的消耗。\n\n","slug":"（Java复习总结）Java数据类型笔记","date":"2023-08-20T03:46:43.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"378ef04860d0061ea328fa054dbf3d74","title":"（开发笔记）平台开发总结记录（随时间更新）","content":"登录\n查看是否登录时，一般会看看线程是否有这个用户（网关处理时会把数据保存到线程上）\n\nMP\n要掌握如何进行分页  \nMP在处理多个表时，有时用xml更好，尤其是在查询列表时\n\n\n项目审核上  \n一般需要一个公共的方法，外加一个code，表示审核失败和审核成功  \n查询验证信息 就是查询是否对象是否存在\n\n\n进行消息传递时，如果需要传递类，可以用HashMap包装\n\n网关\nMono类  \n拦截器 过滤器  \n要加上@Component  \n获取用户的方法  \n利用网关过滤器，将登录信息包装到thread，然后可以直接读取该thread的信息，得到用户的信息  \n根据传过来的json信息来得到用户的信息\n\n\n\n拦截器\nAppThreadLocalUtil  \n线程读取用户的id  \n重要，需要认真学习\n\n延迟任务 用于处理文章定时审核和上架\n延迟任务的实现  \n用的是Redis的延迟队列，其中有2个队列，当前队列和未来队列  \n需要用上乐观锁  \n也可以用RabbitMQ\n\n\n分布式锁的解决方案（因为@Schedule存在做集群任务的重复执行问题，后续的xxl-job任务可以解决）  \nSETNX 用的是StringRedisTemplate\n\n\n定时刷新  \n未来任务定时刷新到当前任务  \n是在redis上的处理，就是先清楚掉未来任务的数据（zset），然后将这个数据加入到当前队列（list）\n\n\n数据库定时刷新到redis（即数据库定时同步到redis）  \n要先清理缓存中的数据，然后从数据库中查询符合条件的数据，并加入到redis\n\n\n\n\nGetMapping 和 PostMapping的区别是GetMapping上的连接必须有占位符，即{}，并且参数要有@PathVariable。这个与Http的Get请求特点有关的。  \n延迟任务上，使用的序列化方法是Protostuff，特点是比Jdk的序列化方法快  \n延迟任务上，会使用到的@Scheduled注解，里面用上2个参数  \ncron  \nfixedRate  \n然后会用上EnableScheduling注解，用于开启调度任务\n\n\n在文章审核上，需要使用@Asyns实现异步调用，保证文章微服务挂掉时，不影响文章的审核（自媒体的微服务部分）  \n区分延迟任务和定时任务\n\nKafka 用于通知文章上下架\n自媒体文章上下架  \n自媒体微服务如何通知文章微服务？？  \nFeign远程调用 有耦合性  \n消息队列 RabbitMQ Kafka 系统解耦 流量削峰  \nKafkaProducer 创建Kafka对象\n\n\n\n\nKafka入门  \n程序设置  生产者和消费者\n写程序时需要先用Properties创建配置类（也可以写入yml配置文件），里面保存连接信息，key和value的序列化或反序列化，另外消费者还需要添加消费者组，其使用的重要参数有：1. 连接信息。2. key和value的序列化或反序列化。3. ack 消息确认机制 开发中不会专门去设置 默认 ack&#x3D;1。4. retries 尝试重试次数 一般设置10次。5. 消息压缩 snappy\n创建生产者对象或消费者对象 传入配置类\n发送消息或订阅主题并拉取消息\n生产者还需要关闭消息通道\n\n\n消费者组  \n一对一接收 同一个消费者组有多个消费者就行 （Topic中的一个消费者组的消息只能由一个消费者消费，这也保证消息的有序性）  \n而一对多时，只需要将不同的消费者放在不同的消费组就行  \n消费组的设置：ConsumerConfig类\n\n\nKafka的分区设计和高可用设计 这一块需要查阅资料  \nKafka的生产者上，有同步和异步发送消息  \nKafka的参数配置  \nKafka的消息有序性 （按顺序处理Topic的所有消息，就只提供一个分区）  \n偏移量 提交方式： 同步与异步组合方式提交  \nSpringBoot结合Kafka  \n用yml写入kafka的一些配置  \n用KafkaTemplate（发送信息）  \n注解接收信息 @KafkaListener  \n序列化处理，使用JSON方法，发送消息时，将对象转为JSON字符串，然后接收消息时，将JSON字符串转化为对象\n\n\n\n\n\nElasticSearch 搜索总结\nElasticSearch  \n数据库批量导入ES  \nRestHighLevelClient  \n要复习ES  \nSearchRequest  \nQueryBuilders  \nSearchSourceBuilders\n\n\nIndexRequest\n\n\n保存搜索记录  \n用mongodb数据库  \nmongoTemplate  \nsave  \nfindById  \nfind  \nremove\n\n\nQuery(与Criteria搭配使用，用于组合查询或排序)  \nquery\n\n\n更新时间方式  \n用new Date()就行\n\n\nSort\n\n\n联想词查询  \n实际上是模糊查询\n\n\n\n\n\n关注、取消、点赞等CRUD处理\n关注与取消关注  \n添加到Redis，使用zset\n\n\n点赞  \n因为点赞只能点赞一次，所以要判断是否点赞，此时可以用哈希表\n\n\n阅读  \n要更新登录次数  \n用哈希表\n\n\n不喜欢  \n根据交流可知，似乎这个与点赞是区分的，都可以点击，也算是不足之处吧  \n用哈希表\n\n\n收藏  \n要判断是否已经收藏 只能收藏一次\n\n\n每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！\n\n定时任务热点文章计算（问题很大）\n定时任务框架（xxl-job也许主流？？？？ 分布式消息队列？？？？）  \n定时任务框架-xxl-job 分布式任务调度框架  \n可以解决的问题：  \n做集群任务的重复执行问题  \ncron表达式定义在代码中，修改不方便  \n定时任务失败，无法重试也没有统计  \n如果任务量过大，不能有效分片执行\n\n\n\n\n\n实时任务 热点文章计算\nSerDe是Serializer&#x2F;Deserializer的缩写。 Serdes.String().getClass() 实际上是得到一个序列化器  \nTopology类 这个可能要注意  \n重要的对象 KStream 键值类型的  \nDuration.ofSeconds  \nKakfaStream 的flatMapValues方法：在Kafka中，flatMapValues是一个操作符（operator），用于对每个记录的值进行扁平化处理（就是对一个数据流的数据进行分开处理），并生成零个或多个新的记录。flatMapValues操作符的功能类似于flatMap操作符，但它只应用于记录的值部分，而不改变键部分。\n\n\nKafka的流式处理模块是单独的，需要生产者的topic和消费者的topic  \n需要自己添加配置类，因为SpringBoot对kafkaStream的yml集成效果不太好  \n需要学习的注解  \n@ConfigurationProperties  \n@Bean  \n@Value\n\n\n所谓热点文章，就是同时考虑点赞行为和阅读行为，对文章的分值进行计算，要实时的，这个可以用KafkaStream完成的。  \nenum 枚举类或集合方法的撰写 必须要学会  \n常量类上的方法使用 static 和 final  \nString.format()\n\n其他补充\nmongodb处理 \n分页列表并不像MP那样有插件，需要自己实现  \n涉及到MongoDB的数据操作，是没有mapper的，因为mongoTemplate里面有数据操作的方法\n\n\n\n","slug":"（开发笔记）平台开发总结记录（随时间更新）","date":"2023-05-07T02:32:25.000Z","categories_index":"","tags_index":"开发","author_index":"Aurora"},{"id":"5da0e7c1ff981f5dde4015103b247300","title":"（开发笔记）平台开发的注意事项简要记录","content":"nacos配置问题每次正确添加nacos配置后，如果碰上某个微服务的错误，此时要考虑是不是不小心加上了无关的依赖库，尤其是okhttp 。\n延迟队列问题延迟队列  \n\n延迟队列上，判断数据是否到期，就是和当前时间进行比较，用的是System.currentTimeMillis() 。\n\n如何将Redis的未来队列的数据同步到list  \n\n从zset中查出数据，并删除  \n\n把数据存入到list  \n\n用管道方式更快\n\n\n\n\n拦截器问题每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！  \n业务问题部分程序存在 ，存在Claims类（自己编写失误）将未登录的用户的id默认为0的情况，此时需要在此处加个判断，将未登录用户不能直接登录。\n","slug":"（开发笔记）平台开发的注意事项简要记录","date":"2023-04-23T03:30:58.000Z","categories_index":"","tags_index":"开发","author_index":"Aurora"},{"id":"535536b539f073c2d793d87577695f87","title":"（开发笔记）平台使用的技术简要总结_杂记（随时间更新）","content":"JSON 阿里巴巴的fastjson  \nStringUtils  \n\n不同的包也有不同的方法  \n\nisNotBlank 和 isEmpty也是不同的方法\n\n\nBeansUtils springframework的  \n@RequestBody  \nArrays类，比如asList  \nIDEA快捷键，比如Ctrl+SHIFT+t 可以构建测试类  \nDFA算法，雪花算法 DFA有点像前缀树  \nspring.factories 作用探讨  \nTess4j 图片识别 把图片的文字提出来，然后识别文字是否存在问题  \n同步 异步 @Aynsn  \nFreemarker Template Configuration  \nStringWriter  \napArticleService.update(Wrappers.lambdaUpdate().eq(ApArticle::getId,apArticle.getId()).set(ApArticle::getStaticUrl,path)); set用法  \n乐观锁 悲观锁  \n\n乐观锁： 每次拿数据的时候都认为别人不会修改，所以不上锁，但是每次更新时会判断之前被人是否改过，用版本号机制等判断  \n用@Version 标明是版本号，用乐观锁  \nMP对乐观锁有支持，只需要加个拦截器配置，分页机制也是  \n\n悲观锁：而悲观锁则是每次拿数据时都认为别人会修改，所以每次拿数据都会上锁\n\n\nStringRedisTemplate StringRedisConnection  \n\nScan方法  \n\n分布式锁 Setnx\n\n\nCalendar Date 日期类  \ngetTime()  \n测试类  \n\n@SpringBootTest(classes &#x3D; ScheduleApplication.class)@RunWith(SpringRunner.class)\n\n@Schedule  \n@PostConstruct 有初始化的方法  \n@PathVariable 占位符  \nFeign（重点！！！！！）  \n枚举类的撰写  \nProtostuff序列化  \n@Scheduled @EnableScheduling  \nMP如何更新数据  \nDigestUtils  \n定时任务框架-xxljob\n","slug":"（开发笔记）平台使用的技术简要总结-杂记（随时间更新）","date":"2023-04-01T12:50:20.000Z","categories_index":"","tags_index":"开发","author_index":"Aurora"},{"id":"4a84d38afea4c32655f17f427273c865","title":"（开发笔记）注解总结之@RequestBody","content":"@RequestBody 是一个Spring框架中的注解，用于将HTTP请求的内容（例如JSON、XML等）绑定到方法的参数上。它通常与Spring MVC或Spring Boot中的控制器方法一起使用。  \n使用@RequestBody注解时，Spring框架会自动将请求体的内容解析，并尝试将其转换为指定的参数类型。  \n以下是@RequestBody的示例用法：  \njava@RestController  \npublic class UserController &#123;  \n    @PostMapping(&quot;/users&quot;)  \n        public ResponseEntity&lt;?&gt; createUser(@RequestBody User user) &#123;  \n        // 处理请求，使用接收到的User对象  \n        // ...  \n    return ResponseEntity.ok().build();  \n    &#125;  \n&#125;  在上面的示例中，createUser()方法使用@RequestBody注解来接收HTTP POST请求中的请求体，并将其转换为User对象。Spring框架会根据请求的内容类型（例如JSON）以及User类的定义，自动完成请求体到User对象的转换。  \n需要注意的是，在使用@RequestBody时，通常还需要指定请求的Content-Type。例如，如果请求的Content-Type是application&#x2F;json，则Spring会使用相应的JSON转换器将JSON字符串转换为User对象。  \n另外，@RequestBody注解还支持其他参数类型，如Map&lt;String, Object&gt;、List&lt;User&gt;等，以及自定义的数据转换器和处理器。  \n总之，@RequestBody注解允许将HTTP请求的内容转换为方法参数，并方便地在Spring框架中处理和使用请求体数据。\n","slug":"（开发笔记）注解总结之-RequestBody","date":"2023-03-10T03:28:20.000Z","categories_index":"","tags_index":"开发,注解与反射","author_index":"Aurora"},{"id":"a2a04591aa24c2e458792273dc89fac0","title":"（开发笔记）平台数据库开发记录总结","content":"添加到数据库时  \n\n如果是Mapper，一般是用insert方法或save方法  \n而用这些方法前，一般会设置dto类，并创建dto方法，然后用BeansUtils将传输过来的类拷贝到这个dto类，但是dto类依然有些属性是空着，要自己从其他地方添加。\n\n","slug":"（开发笔记）平台数据库开发记录总结","date":"2023-02-21T07:42:36.000Z","categories_index":"","tags_index":"开发","author_index":"Aurora"},{"id":"cc0c0ae272578c20aede8e365a202e3c","title":"MySQL笔记简要复习总结","content":"阅读来源：SQL语法基础知识总结 | JavaGuide(Java面试 + 学习指南)\nselect聚类    select 语句中，如果没有 GROUP BY 语句，那么 cust_name、order_num 会返回若干个值，而 sum(quantity * item_price) 只返回一个值，通过 group by cust_name 可以让 cust_name 和 sum(quantity * item_price) 一一对应起来，或者说聚类，所以同样的，也要对 order_num 进行聚类。\n\n\n\n\n\n\n\n\n\n一句话，select 中的字段要么都聚类，要么都不聚类\n排序检索数据ORDER BY 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 DESC 关键字。\n知识点：\n\n逗号作用是用来隔开列与列之间的。\nORDER BY 是有 BY 的，需要撰写完整，且位置正确\n知识点：DISTINCT 用于返回列中的唯一不同值、\n注意limit的使用，这个作用筛选某些值，比如筛选前面的几个值\n\n过滤数据WHERE 可以过滤返回的数据。\n下面的运算符可以在 WHERE 子句中使用：\n\n\n\n运算符\n描述\n\n\n\n&#x3D;\n等于\n\n\n&lt;&gt;\n不等于。 注释： 在 SQL 的一些版本中，该操作符可被写成 !&#x3D;\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;&#x3D;\n小于等于\n\n\nBETWEEN\n在某个范围内\n\n\nLIKE\n搜索某种模式\n\n\nIN\n指定针对某个列的多个可能值\n\n\n用通配符进行过滤SQL 通配符必须与 LIKE 运算符一起使用\n在 SQL 中，可使用以下通配符：\n\n\n\n通配符\n描述\n\n\n\n%\n代表零个或多个字符\n\n\n_\n仅替代一个字符\n\n\n[charlist]\n字符列中的任何单一字符\n\n\n[^charlist] 或者 [!charlist]\n不在字符列中的任何单一字符\n\n\n使用函数处理数据知识点：\n\n截取函数SUBSTRING()：截取字符串，substring(str ,n ,m)（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；\n\n拼接函数CONCAT()：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。\n\n大写函数 UPPER()：将指定字符串转换为大写。\n\n\n知识点：\n\n日期格式：YYYY-MM-DD\n时间格式：HH:MM:SS\n\n日期和时间处理相关的常用函数：\n\n\n\n函 数\n说 明\n\n\n\nADDDATE()\n增加一个日期（天、周等）\n\n\nADDTIME()\n增加一个时间（时、分等）\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nDATE()\n返回日期时间的日期部分\n\n\nDATEDIFF\n计算两个日期之差\n\n\nDATE_FORMAT()\n返回一个格式化的日期或时间串\n\n\nDAY()\n返回一个日期的天数部分\n\n\nDAYOFWEEK()\n对于一个日期，返回对应的星期几\n\n\nHOUR()\n返回一个时间的小时部分\n\n\nMINUTE()\n返回一个时间的分钟部分\n\n\nMONTH()\n返回一个日期的月份部分\n\n\nNOW()\n返回当前日期和时间\n\n\nSECOND()\n返回一个时间的秒部分\n\n\nTIME()\n返回一个日期时间的时间部分\n\n\nYEAR()\n返回一个日期的年份部分\n\n\n汇总数据汇总数据相关的函数：\n\n\n\n函 数\n说 明\n\n\n\nAVG()\n返回某列的平均值\n\n\nCOUNT()\n返回某列的行数\n\n\nMAX()\n返回某列的最大值\n\n\nMIN()\n返回某列的最小值\n\n\nSUM()\n返回某列值之和\n\n\n分组数据GROUP BY：\n\nGROUP BY 子句将记录分组到汇总行中。\nGROUP BY 为每个组返回一个记录。\nGROUP BY 通常还涉及聚合COUNT，MAX，SUM，AVG 等。\nGROUP BY 可以按一列或多列进行分组。\nGROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。\n\nHAVING：\n\nHAVING 用于对汇总的 GROUP BY 结果进行过滤。\nHAVING 必须要与 GROUP BY 连用。\nWHERE 和 HAVING 可以在相同的查询中。\n\nHAVING vs WHERE：\n\nWHERE：过滤指定的行，后面不能加聚合函数（分组函数）。\nHAVING：过滤分组，必须要与 GROUP BY 连用，不能单独使用。\n\n使用子查询子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 SELECT 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。\n子查询可以嵌入 SELECT、INSERT、UPDATE 和 DELETE 语句中，也可以和 =、&lt;、&gt;、IN、BETWEEN、EXISTS 等运算符一起使用。\n子查询常用在 WHERE 子句和 FROM 子句后边：\n\n当用于 WHERE 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。\n当用于 FROM 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 FROM 后面是表的规则。这种做法能够实现多表联合查询。\nfrom\n\n\n\n\n\n\n\n\n\n\n注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。\n用于 WHERE 子句的子查询的基本语法如下：\ntxtSELECT column_name [, column_name ]\nFROM table1 [, table2 ]\nWHERE column_name operator\n(SELECT column_name [, column_name ]\nFROM table1 [, table2 ]\n[WHERE])\n子查询需要放在括号( )内。\noperator 表示用于 WHERE 子句的运算符，可以是比较运算符（如 =, &lt;, &gt;, &lt;&gt; 等）或逻辑运算符（如 IN, NOT IN, EXISTS, NOT EXISTS 等），具体根据需求来确定。\n\n用于 FROM 子句的子查询的基本语法如下：\ntxtSELECT column_name [, column_name ]\nFROM (SELECT column_name [, column_name ]\n      FROM table1 [, table2 ]\n      [WHERE]) AS temp_table_name [, ...]\n[JOIN type JOIN table_name ON condition]\nWHERE condition;\n用于 FROM 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。\n子查询需要放在括号 ( ) 内。\n可以指定多个临时表名，并使用 JOIN 语句连接这些表\n\n连接表JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。\n连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间。\n使用 JOIN 连接两个表的基本语法如下：\ntxtSELECT table1.column1, table2.column2...\nFROM table1\nJOIN table2\nON table1.common_column1 = table2.common_column2;table1.common_column1 = table2.common_column2 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、between、like 或者 not，但是最常见的是使用 &#x3D;。\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n另外，如果两张表的关联字段名相同，也可以使用 USING子句来代替 ON，举个例子：\ntxt# join....on\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nON c.cust_id = o.cust_id\nORDER BY c.cust_name\n\n# 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....USING()\nSELECT c.cust_name, o.order_num\nFROM Customers c\nINNER JOIN Orders o\nUSING(cust_id)\nORDER BY c.cust_nameON 和 WHERE 的区别：\n\n连接表时，SQL 会根据连接条件生成一张新的临时表。ON 就是连接条件，它决定临时表的生成。\nWHERE 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。\n\n所以总结来说就是：SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选。\nSQL 允许在 JOIN 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：\n\n\n\n连接类型\n说明\n\n\n\nINNER JOIN 内连接\n（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。\n\n\nLEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接\n返回左表中的所有行，即使右表中没有满足条件的行也是如此。\n\n\nRIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接\n返回右表中的所有行，即使左表中没有满足条件的行也是如此。\n\n\nFULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接\n只要其中有一个表存在满足条件的记录，就返回行。\n\n\nSELF JOIN\n将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。\n\n\nCROSS JOIN\n交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。\n\n\n下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。\n组合查询UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。\nUNION 基本规则：\n\n所有查询的列数和列顺序必须相同。\n每个查询中涉及表的列的数据类型必须相同或兼容。\n通常返回的列名取自第一个查询。\n\n默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\ntxtSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\nJOIN vs UNION：\n\nJOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。\nUNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。\n\n使用 union 组合查询时，只能使用一条 order by 字句，他必须位于最后一条 select 语句之后 或者直接使用or做\n在组合查询上，union的作用和or类似\n删除记录描述：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：\n\n\n\nFiled\nType\nNull\nKey\nExtra\nDefault\nComment\n\n\n\nid\nint(11)\nNO\nPRI\nauto_increment\n(NULL)\n自增 ID\n\n\nuid\nint(11)\nNO\n\n\n(NULL)\n用户 ID\n\n\nexam_id\nint(11)\nNO\n\n\n(NULL)\n试卷 ID\n\n\nstart_time\ndatetime\nNO\n\n\n(NULL)\n开始时间\n\n\nsubmit_time\ndatetime\nYES\n\n\n(NULL)\n提交时间\n\n\nscore\ntinyint(4)\nYES\n\n\n(NULL)\n分数\n\n\n要求：请删除exam_record表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;\n思路：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；\n\nDROP: 清空表，删除表结构，不可逆\nTRUNCATE: 格式化表，不删除表结构，不可逆\nDELETE：删除数据，可逆\n\n这里选用TRUNCATE的原因是：TRUNCATE 只能作用于表；TRUNCATE会清空表中的所有行，但表结构及其约束、索引等保持不变；TRUNCATE会重置表的自增值；使用TRUNCATE后会使表和索引所占用的空间会恢复到初始大小。\n这题也可以采用DELETE来做，但是在删除后，还需要手动ALTER表结构来设置主键初始值；\n同理也可以采用DROP来做，直接删除整张表，包括表结构，然后再新建表即可。\n","slug":"MySQL笔记简要总结","date":"2023-01-11T11:38:03.000Z","categories_index":"","tags_index":"MySQL","author_index":"Aurora"},{"id":"5b339b9c114d051588672244c783d1ca","title":"（开发笔记）平台开发时所使用的JSON记录总结","content":"JSONJSON的作用是实现序列化，用于将Java中的对象转化为JSON字符串，方便返回给前端。\n平台使用的JSON是fastjson，阿里开源的，但是Java和Spring版本不能过高，否则fastjson可能没法用。\n另外，SpringBoot内置的Jackson和谷歌开源的Gson也可以用（立下flag要学习使用）\nparseArrayJava中的JSON.parseArray()方法用于将JSON数组字符串解析为Java中的List对象。比如如果给一个JSON语句，然后第二个参数给Map.class，于是该方法就将该语句解析为一个List语句，其中该List里面的类是Map。\n","slug":"（开发笔记）平台开发时所使用的JSON记录总结","date":"2023-01-10T01:05:01.000Z","categories_index":"","tags_index":"开发","author_index":"Aurora"},{"id":"2389fbc827cd67eff59dca71550ede06","title":"(图论) B.Badge","content":"图论+dfs\n题目链接：Problem - B - Codeforces\nB. BadgeIn Summer Informatics School, if a student doesn’t behave well, teachers make a hole in his badge. And today one of the teachers caught a group of n students doing yet another trick.\nLet’s assume that all these students are numbered from 11 to n. The teacher came to student a and put a hole in his badge. The student, however, claimed that the main culprit is some other student papa.\nAfter that, the teacher came to student papa and made a hole in his badge as well. The student in reply said that the main culprit was student Ppa.\nThis process went on for a while, but, since the number of students was finite, eventually the teacher came to the student, who already had a hole in his badge.\nAfter that, the teacher put a second hole in the student’s badge and decided that he is done with this process, and went to the sauna.\nYou don’t know the first student who was caught by the teacher. However, you know all the numbers pi. Your task is to find out for every student a, who would be the student with two holes in the badge if the first caught student was a.\nInput\nThe first line of the input contains the only integer n (1≤n≤10001≤n≤1000) — the number of the naughty students.\nThe second line contains n integers p1, …, p (1≤pi≤n), where pi indicates the student who was reported to the teacher by student ii.\nOutput\nFor every student a from 11 to n print which student would receive two holes in the badge, if a was the first student caught by the teacher.\nExamples\ninput\ntxt3\n2 3 2output\ntxt2 2 3Note\nThe picture corresponds to the first example test case.\n\n\nWhen a&#x3D;1, the teacher comes to students 1, 2, 3, 2, in this order, and the student 2 is the one who receives a second hole in his badge.\nWhen a&#x3D;2,the teacher comes to students 2, 3, 2, and the student 2 gets a second hole in his badge. When a&#x3D;3, the teacher will visit students 3, 2, 3 with student 3 getting a second hole in his badge.\nFor the second example test case it’s clear that no matter with whom the teacher starts, that student would be the one who gets the second hole in his badge.\n上面的一些特殊的符号需要看看codeforces就行。\n这个是一个图论题，就是在不断根据指控把一个人的标记打上扣，一直继续下去，直到找出已打出两个扣的人。\nPython代码:\ntxtn = int(input())\nL = list(map(int, input().split()))\nL.insert(0,0)\nQ = [i for i in range(n)]\nfor i in range(1, n + 1):\n    vis = [0 for i in range(n + 1)]\n    cur = i\n    while True:\n        if vis[cur] != 0:\n            break\n        vis[cur] = 1\n        cur = L[cur]\n    print(cur, end=&quot; &quot;)","slug":"图论-B-Badge","date":"2022-10-06T08:32:24.000Z","categories_index":"","tags_index":"刷题：图论,刷题：DFS","author_index":"Aurora"},{"id":"eb70c1e0ff89e3aa1306966429c22736","title":"(图论) A. Love Triangle","content":"这个其实是一个很基础的图论题。\n\n\n题目链接：Problem - 939A - Codeforces\nA. Love TriangleAs you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are n planes on Earth, numbered from 1 to n, and the plane with number i likes the plane with number f**i, where 1 ≤ f**i ≤ n and f**i ≠ i.\nWe call a love triangle a situation in which plane A likes plane B, plane B likes plane C and plane C likes plane A. Find out if there is any love triangle on Earth.\nInput\nThe first line contains a single integer n (2 ≤ n ≤ 5000) — the number of planes.\nThe second line contains n integers f1, f2, …, f**n (1 ≤ f**i ≤ n, f**i ≠ i), meaning that the i-th plane likes the f**i-th.\nOutput\nOutput «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO».\nYou can output any letter in lower case or in upper case.\nExamples\ninput\nCopy\ntxt5\n2 4 5 1 3output\nCopy\ntxtYESinput\nCopy\ntxt5\n5 5 5 5 1output\nCopy\ntxtNONote\nIn first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle.\nIn second example there are no love triangles.\n这个是一个很基础的图论题，只要有f[f[f[i]]] &#x3D;&#x3D; i的话，就说明肯定存在三角关系。\nPython代码:\ntxtn = int(input())\nf = list(map(int, input().split()))\nf.insert(0, 0)\nflag = 0\nfor i in range(1, n + 1):\n    if f[f[f[i]]] == i:\n        flag = 1\n        break\nif flag:\n    print(&quot;YES&quot;)\nelse:\n    print(&quot;NO&quot;)","slug":"图论-A-Love-Triangle","date":"2022-10-06T05:24:49.000Z","categories_index":"","tags_index":"刷题：图论","author_index":"Aurora"},{"id":"1430b8946bb971c1a1aa8572d387e43f","title":"(数学)A. Restoring Three Numbers","content":"这个是一个数学题。不过不必是暴力的。\n\n\n题目链接：Problem - 1154A - Codeforces\nA. Restoring Three NumbersPolycarp has guessed three positive integers aa, bb and cc. He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: a+ba, a+c, b+c and a+b+c.\nYou have to guess three numbers aa, bb and cc using given numbers. Print three guessed integers in any order.\nPay attention that some given numbers a, b and c can be equal (it is also possible that a&#x3D;b&#x3D;c).\nInput\nThe only line of the input contains four positive integers x1,x2,x3,x4(2≤xi≤10^9) — numbers written on a board in random order. It is guaranteed that the answer exists for the given number x1,x2,x3,x4.\nOutput\nPrint such positive integers aa, bb and cc that four numbers written on a board are values a+b, a+c, b+c and a+b+c written in some order. Print a, b and c in any order. If there are several answers, you can print any. It is guaranteed that the answer exists.\nExamples\ninput\nCopy\ntxt3 6 5 4output\nCopy\ntxt2 1 3input\nCopy\ntxt40 40 40 60output\nCopy\ntxt40 40 40 60input\nCopy\ntxt201 101 101 200output\nCopy\ntxt1 100 100这个是一个数学题，不必是从1开始暴力，会超时的。可以从给出的4个数中选出最大的（a+b+c当然是最大的），然后减去其他中的一个，得到a或b或c，最后把剩下的两个减去这个数，得到相应的数。\nPython代码:\ntxtQ = map(int, input().split()) # 最后得到的就是一个tuple类型\nL = list(Q) # 将tuple类型转换为list类型。\nL.sort() # 排序，为了得到a + b + c的值。\nm = L[3]\nc = m - L[2]\na = L[0] - c\nb = L[1] - c\nprint(a, b, c)","slug":"数学-A-Restoring-Three-Numbers","date":"2022-10-06T03:19:50.000Z","categories_index":"","tags_index":"刷题：Math","author_index":"Aurora"},{"id":"8c96df63a0315585096b5e2bf6169ee7","title":"Java基础复习简要总结（黑马视频）","content":"为了打好基础，我跟着Java黑马教程学习一段时间，现在将Java基础与面对对象知识进行总结并标记重要地方（主要对自己不太了解的知识总结）\n视频来源：黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题和大厂java面试题）_哔哩哔哩_bilibili\n面向对象-就近原则和this关键字、构造方法\nthis表示当前对象的地址\n\nthis可以区分成员变量和局部变量\n\nthis 本质 代表方法调用者的地址值，Car c &#x3D; new Car()上，c和this的地址值是一样的，所以指代的也一样。\n\n\n\n就近原则 指的是谁离我近，就用谁\njavaprivate int age;\nvoid show1(age)&#123;\n    age = age;\n&#125;根据就近原则，左边的age算是局部变量，age&#x3D;null，所以返回null\n\n构造方法的作用：\n\n给成员变量进行初始化，返回其地址\n\nCar c &#x3D; new Car() c保存的是地址。（看面向对象-07的对象内存图）\n\n\n\n标准的JavaBean类（只是一个有特定要求的类而已，类似的有工具类）\n\n类名需要见名知意\n\n成员变量至少需要用private修饰\n\n提供至少2个构造方法，比如无参构造和带全部参数的构造\n\n成员方法：提供每一个成员变量所提供的setXxxx()和getXxxx()，如果还其他行为，一并写上。\n\n在IDEA上，可以邮件 有PTG to javabean。\n\n\n\n\n面向对象-07 三种情况的对象内存图【重要 看视频 面试】需要看JVM面向对象-09 this的内存原理【看视频】面向对象进阶-03 static的注意事项， 02也可以看看一下\n总结\n\n静态方法没有this\n\n静态方法只能访问静态，因为静态随类加载而加载，此时对象可能未加载，所以没法访问\n\n非静态方法可以访问任意\n\n静态属于类，不属于对象\n\n\n\n非静态方法有一个隐藏的this\n\njavavoid show1(Student this)&#123;\n\n&#125;\n\n\n\n多线程 同步代码块 多线程 08\n把操作共享数据（比如用static定义的变量等）的代码锁起来。\n\nstatic定义的变量和方法可以被所有对象共享。\n\njavasynchronized(锁对象)&#123;\n\n&#125;最好在循坏内，否则会成单线程 具体见多线程-08\n看PPT的总结\n\n对于实例方法建议使用this作为锁对象。\n\n对于静态方法建议使用字节码（类名.class）对象作为锁对象。\n\n\n\n\n多线程 同步方法\n就是把synchronized关键字加到方法上。\n\n用Runnable创建进程对象时，因为只构建一个对象，所以成员变量不需要添加static作为共享变量。\n\n\n多线程 Lock锁javalock.lock()\nlock.unlock()\n要保证所有对象共享同一把锁。\n\n用Thread创建多个线程时，需要对Lock对对象添加static\n\n使用try-catch-finally\n\n\n多线程 死锁\n注意安排好线程的先后，否则会卡死\n\n多线程 线程池 多线程 29\n线程池是线程的复用技术\n1、创建线程池。2、提交任务，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下次提交任务时，不需要创建线程，只需要复用线程即可。3、池子中没有空闲线程时，也无法创建新的线程时，任务就排队等待。4、所有任务执行完毕时，会关闭线程池。\n\n","slug":"Java基础复习简要总结","date":"2022-08-07T03:30:37.000Z","categories_index":"","tags_index":"Java","author_index":"Aurora"},{"id":"f266ddc468c37e3de2feebaa8ae419d6","title":"scrapy提交表单——爬取火熊网最新上传一栏并下载图片","content":"前言我起初在爬这个火熊网却发现这个是JS加载，所以我就打开谷歌开发者工具，查看XHR，找到了http://cgartt.com/api/api.php?d=index&amp;c=Index&amp;action=getWorkList\n在这个链接中，用Google的JSON-handleg工具查看json，却发现这个json和preview是有所不同的：\n\n（上面两个无论是title还是id以及imageUrl均是不同的）\n所以我很困惑，一度误认为这个是JS加密或JS混淆的，所以就学了如何js加密的破解，不过还是没有找到关于这个的解决办法。后来，在Header一栏中，却发现有“Form data”：\n\n这时，我才想起，这个也许是需要通过提交表单才能获取preview上的json，所以就开始尝试提交表单了。\n开始爬取确定爬取的目标我确定在火熊网上爬取最新上传一栏的前10页，其中，对于排序并没有要求，能爬取并下载图片就行。网址：http://cgartt.com/\n确定爬取时所用的语言和框架Python的scrapy，同时，用scrapy的ImagePipeline来下载图片。\n爬虫程序Begin:pythonscrapy startproject Huoxiong\nscrapy genspider huoXiongImage cgartt.com/上面建立scrapy\nspider&#x2F;huoXiongImage.py这个是整个爬虫程序的重中之重，与爬虫是否成功息息相关的。\n\n其中，base_url_1指的是之前在开发者工具中找到的要查找的json所在的网址；而base_url_2是我在分析图片页的网址时，发现这个是共同的链接，比如：\n\nhttp://cgartt.com/index_writing_detail.php?work=0&amp;id=2761\n\nhttp://cgartt.com/index_writing_detail.php?work=0&amp;id=27614\n\nhttp://cgartt.com/index_writing_detail.php?work=0&amp;id=27676\n\n\n在上面随机选择的3个图片页的链接中，可以看出它们几乎相似，唯一不同的地方是id，所以从这个思路下手，得到图片页的链接；最后的base_url_3中，这个的查找方法和base_url_1类似，也需要提交表单才能得到需要的信息,用scrapy.Request()，method为‘POST’，指提交。\n\n接下来我觉得需要重写start_requests()，因为如果不重写，那程序将会从start_urls中开始爬取，不符合要从http://cgartt.com/api/api.php?d=index&c=Index&action=getWorkList提交表单的目的。\n\n下面就是通过base_url_1提交表单得到json后处理，主要是得到id，便于和base_url_2组成图片页的链接。\n\n然后就是对base_url_3进行提交表单，用**scrapy.FormRequest()**，不过用scrapy.Request()并不能得到需要的内容。最后就是获取图片页的各个图片的链接，图片的标题、作者名字等等。\n\n代码如下（HuoxiongimageSpider(scrapy.Spider)类里面）：\npythonname = &#39;huoXiongImage&#39;  # 这个name必不可少。\nallowed_domains = [&#39;cgartt.com&#39;]\nstart_urls = [&#39;http://cgartt.com/&#39;]\nbase_url_1 = &quot;http://cgartt.com/api/api.php?d=index&amp;c=Index&amp;action=getWorkList&quot;\nbase_url_2 = &quot;http://cgartt.com/index_writing_detail.php?work=0&amp;id=&quot;\nbase_url_3 = &quot;http://cgartt.com/api/api.php?d=find&amp;c=FindInfo&amp;action=getWorkDetial&quot;\n\n# 爬取前10页。\ndef start_requests(self):\n    for page in range(1, 11):\n        data = &#123;&#39;order&#39;: 2&#125;\n        data[&#39;page&#39;] = page\n        # 提交表单，为了得到最新上传一栏的1到10页的json。\n        yield Request(url=self.base_url_1, method=&#39;POST&#39;, body=json.dumps(data), callback=self.parse)\n\n# 分析提交表单后得到的数据。\ndef parse(self, response):\n    text = response.text\n    text = text[18:] # 这个是为了去掉空格，从而能确保转化为json过程中没有出错。\n    text = json.loads(text)\n    for list in text[&#39;list&#39;]:\n        id = list[&#39;id&#39;]\n        url = self.base_url_2 + id\n        yield Request(url=url, callback=self.parse_page, meta=&#123;&#39;id&#39;: id&#125;)\n\ndef parse_page(self, response):\n    id = response.meta[&#39;id&#39;]  # 这个不能写成response[&#39;id&#39;]\n    data = &#123;&#39;id&#39;: id&#125;\n    # 不知怎么的，用FormRequest能得到需要的数据，而Request不能，所以一个不能用时，考虑用另一个。\n    yield FormRequest(url=self.base_url_3, formdata=data, method=&#39;POST&#39;, callback=self.parse_detail)\n\n# 在图片页面获取图片的链接用于下载。另外也获取图片的id，标题和作者。\ndef parse_detail(self, response):\n    text = response.text\n    text = text[8:]\n    text = json.loads(text)\n    images = text[&#39;worksInfo&#39;][0]\n    for image in images[&#39;imageUrl&#39;]:\n        item = HuoxiongItem()\n        item[&#39;img&#39;] = image[&#39;imageUrl&#39;]\n        item[&#39;title&#39;] = images[&#39;title&#39;]\n        item[&#39;Name&#39;] = images[&#39;username&#39;]\n        item[&#39;id&#39;] = images[&#39;id&#39;]\n        yield item\n\nitems.py这个是构建Item()的.(HuoxiongItem(scrapy.Item)类)：\npython# define the fields for your item here like:\n# name = scrapy.Field()\ntitle = Field()\nimg = Field()\nName = Field()\nid = Field()pipelines.py&#x3D;需要引入scrapy.pipelines.images的ImagesPipeline\n并将HuoxiongPipeline()类继承imagesPipeline类，重写file_path()和get_media_requests()方法。\npythonclass HuoxiongPipeline(ImagesPipeline):\n# def process_item(self, item, spider):\n#     return item\ndef file_path(self, request, response=None, info=None):\n    item = request.meta[&#39;meta&#39;]\n    file_name = item[&#39;Name&#39;] + &quot;/&quot; + item[&#39;id&#39;] + &quot;/&quot; + item[&#39;title&#39;] + &quot;/&quot; + item[&#39;img&#39;].split(&quot;/&quot;)[-1] # 这个是构建一个具有层次结构的文件的小尝试。\n    return file_name\n\ndef get_media_requests(self, item, info):\n    yield Request(url=item[&#39;img&#39;], meta=&#123;&#39;meta&#39;: item&#125;)settings.py还得添加如下代码：\npythonITEM_PIPELINES = &#123;\n    &#39;Huoxiong.pipelines.HuoxiongPipeline&#39;: 300,\n&#125;\n\nIMAGES_STORE = &#39;./image&#39;需要去掉ITEM_PIPELINES所在的三行的注释，然后写上IMAGES_STORE &#x3D; ‘.&#x2F;image’，其中注意 “IMAGES_STORE” 不能写错。\n运行最后在Terminal上scrapy crawl huoXiongImage就可以爬了，目前可以正常爬取的。\nGithub完整的代码见于：\nliuweixu’s Github\n","slug":"scrapy提交表单——爬取火熊网最新上传一栏并下载图片","date":"2021-07-10T05:01:57.000Z","categories_index":"","tags_index":"爬虫","author_index":"Aurora"},{"id":"74b3c9299a9d2a5ecfa2b1ca58a5ff0a","title":"Scrapy爬取Bing美图","content":"\n\n这个是Image Pipeline 练习\n确定爬取的目标我们要爬取的是Bing美图，Bing今日美图，我们可以发现，这个网页没有ajax加载，有页面，其中URL里面只有页码不同，可以考虑先爬取页面的信息，然后在每个页面爬取每个图片的链接赋值给item。\n开始编写代码\n创建item\npython# -*- coding: utf-8 -*-\n\n# Define here the models for your scraped items\n#\n# See documentation in:\n# https://docs.scrapy.org/en/latest/topics/items.html\n\nimport scrapyclass BingItem(scrapy.Item):\ntxt# define the fields for your item here like:\n# name = scrapy.Field()\n# 图片标题\ntitle = scrapy.Field()\n# 图片链接\nurl = scrapy.Field()\n\ntxt建立图片的标题和链接作为“键”。\n\n- spiders/bing_images.py\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom Bing.items import BingItem\n\n\nclass BingImagesSpider(scrapy.Spider):\n    name = &#39;bing_images&#39;\n    allowed_domains = [&#39;bing.plmeizi.com&#39;]\n    start_urls = [&#39;http://bing.plmeizi.com/&#39;]\n\n    def parse(self, response):\n        base_url = &quot;http://bing.plmeizi.com/?page=&quot;\n        for page in range(1, 129):\n            url = base_url + str(page)\n            yield scrapy.Request(url, callback=self.parse)\n        # 这个有必要进行循环，因为在pipeline.py 中scrapy.Request()里面的url是需要url的，而不是一个列表的。\n        for image in response.css(&quot;.clearfix .item&quot;):\n            item = BingItem()\n            item[&#39;url&#39;] = image.css(&quot;div img::attr(src)&quot;).extract_first()\n            item[&#39;title&#39;] = image.css(&quot;p::text&quot;).extract_first()\n            yield item  这个代码中，我们先循环获取1到128页的页面的源代码，回调到parse()中，然后用response.css()获取每个页面的的图片的链接和标题。注意，这个也需要循环，因为接下来的pipeline.py中的scrapyRequest()里面的URL是一个一个的，不是列表的。\n\npipelines.py\npython# -*- coding: utf-8 -*-\n\n# Define your item pipelines here\n#\n# Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting\n# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html\nfrom scrapy.pipelines.images import ImagesPipeline\nimport scrapyclass BingPipeline(ImagesPipeline):\ntxt# def process_item(self, item, spider):\n#     return item\n\n# 用来确定图片的文件名。\ndef file_path(self, request, response=None, info=None):\n    # 由于标题过长，会分成自动分成两半，前面的部作为文件夹的名字，后面的部分作为图片的名字。\n    # 所以，我们有必要进行删除一些不必要的名字的部分，可以发现，这些标题基本是在后面有一个括号，我们可以删去\n    # 这些无关紧要的括号就行。\n    file_name = request.meta[&#39;meta&#39;][&#39;title&#39;].split(&quot;(&quot;)[0] + &quot;.png&quot;\n    return file_name\n\ndef item_completed(self, results, item, info):\n    image_paths = [x[&#39;path&#39;] for ok, x in results if ok]\n    if not image_paths:\n        raise scrapy.DropItem(&#39;Image Download Failed&#39;)\n    return item\n\ndef get_media_requests(self, item, info):\n    yield scrapy.Request(url=item[&#39;url&#39;], meta=&#123;&#39;meta&#39;: item&#125;)\n\ntxt注意先导入ImagesPipeline，并且BingPipeline需要**继承**ImagesPipeline，这个是必须的。然后就是重写file_path()、item_completed()和get_media_requests()。其中file_path()就是确定图片的文件名，不过这个文件名需要处理下，因为这个得到的文件名过长。在item_completed()中，是用来确定当爬取图片失败后的返回警告信息。而get_media_requests()是用来处理spider传递过来的每个item。\n\n- settings.py\n\n```python\nROBOTSTXT_OBEY = False\n\nROBOTSTXT_OBEY = &#123;\n   &#39;Bing.pipelines.BingPipeline&#39;: 300,\n&#125;\n\nIMAGES_STORE = &quot;./images&quot;  需要对ROBOTSTXT_OBEY和ROBOTSTXT_OBEY去掉注释。然后添加IMAGES_STORE，作为保存的文件夹。\nGithub这些完整的代码见于 Github\n参考\n《Python3 网络爬虫开发实战》崔庆才\n\n","slug":"Scrapy爬取Bing美图","date":"2021-07-10T04:59:38.000Z","categories_index":"","tags_index":"爬虫","author_index":"Aurora"},{"id":"acb53f06d1c58527ddd8b9d7be584840","title":"scrapy爬取笔趣看的小说","content":"前言之前用了requests和Beautifulsoup爬取笔趣看的小说了《极品家丁》，不过现在用爬虫框架——Scrapy爬取，这个框架比较好用，自带分布式，可以让我们省下时间快速爬取自己需要的内容，这个是一个很优秀的轮子，我们干嘛不能学和用呢？不过这个scrapy学习相对来说比较难上手。\n开始入门准备工作安装好Scrapy，在windows可以用pip install scrapy就安装好，其他的可以看看崔庆才博客\n创建项目pythonscrapy startproject Jipin这个可以在cmd的命令行运行，也可以在Pycharm的下面的Terminal运行，我用的是Pycharm，所以接下来的步骤都是在Pycharm上运行的，不在Pycharm的，也可以运行的。\n创建Spiderpythoncd Jipin\nscrapy genspider jipinjiading www.biqukan.com/3_3053然后在Pycharm打开Jipin文件夹。\n开始编写代码\n首先在items.py中,需要定义item（也可以不用定义Item），这个Item可以理解为字典，下面的两行可以认为是定义字典的键。\npython# -*- coding: utf-8 -*-\nimport scrapy\nfrom urllib import parse\nfrom Jipin.items import JipinItemclass JipinjiadingSpider(scrapy.Spider):\ntxtname = &#39;jipinjiading&#39;\nallowed_domains = [&#39;www.biqukan.com&#39;]\nstart_urls = [&#39;http://www.biqukan.com/3_3053/&#39;]\n\n# 抓取目录页的标题的链接\ndef parse(self, response):\n    links = response.css(&quot;.listmain dl dd a::attr(href)&quot;).extract()\n    for link in links:\n        yield scrapy.Request(url=parse.urljoin(response.url, link), callback=self.parse_page)\n\n# 抓取文章页面的标题和内容。\ndef parse_page(self, response):\n    item = JipinItem()\n    item[&#39;title&#39;] = response.css(&quot;.content h1::text&quot;).extract_first()\n    texts = response.xpath(&quot;//*[@id=\\&quot;content\\&quot;]/text()&quot;).extract()\n    item[&#39;text&#39;] = &quot;&quot;.join(texts).replace(&quot;\\xa0&quot; * 8, &quot;&quot;)\n    yield item\n\ntxt- spider/jipinjiading.py\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\nfrom urllib import parse\nfrom Jipin.items import JipinItem\n\n\nclass JipinjiadingSpider(scrapy.Spider):\n    name = &#39;jipinjiading&#39;\n    allowed_domains = [&#39;www.biqukan.com&#39;]\n    start_urls = [&#39;http://www.biqukan.com/3_3053/&#39;]\n\n    # 抓取目录页的标题的链接\n    def parse(self, response):\n        links = response.css(&quot;.listmain dl dd a::attr(href)&quot;).extract()\n        for link in links:\n            yield scrapy.Request(url=parse.urljoin(response.url, link), callback=self.parse_page)\n\n    # 抓取文章页面的标题和内容。\n    def parse_page(self, response):\n        item = JipinItem()\n        item[&#39;title&#39;] = response.css(&quot;.content h1::text&quot;).extract_first()\n        texts = response.xpath(&quot;//*[@id=\\&quot;content\\&quot;]/text()&quot;).extract()\n        item[&#39;text&#39;] = &quot;&quot;.join(texts).replace(&quot;\\xa0&quot; * 8, &quot;&quot;)\n        yield item  注意这个allowed_domains 里面的是域名，start_urls里面的可以是小说的目录页的链接。接下来就是爬取了。\n  在抓取目录页的标题的链接中，parse()方法的参数response是start_urls里面的链接爬取后的结果，所以在parse()方法中，我们可以直接对response变量包含的内容进行解析，解析的方式有正则表达式，Xpath或css选择器。有：\npythonlinks = response.css(&quot;.listmain dl dd a::attr(href)&quot;).extract()  其中，extract()里的extract的意思是提取，它的作用就是对于response.css()或response.xpath()获取的结果提取为整个列表。\n  然后循环遍历\npythonfor link in links:\n    yield scrapy.Request(url=parse.urljoin(response.url, link), callback=self.parse_page)  这两行代码比较重要，也比较难理解。\n\nscrapy会根据yield返回的示例类型来执行不同的操作。在上面的代码中，对于scrapy.Request对象，scrapy框架会去获得该对象指向的链接并在请求完成后调用该对象的回调函数。\n\n在callback回调函数中，我个人觉得就是对于这个scrapy.Request()获取的链接调到这个回调函数，而回调函数里面会对这个链接的内容进一步处理，得到需要的内容。\n在parse_page()函数中，这个作用就是使用item，把上面的回调过来的链接用Request获取内容作为值赋值给item，然后用yield把这个item传给Item Pipeline。\npython# -*- coding: utf-8 -*-\nimport scrapy\nfrom urllib import parse\nfrom Jipin.items import JipinItemclass JipinjiadingSpider(scrapy.Spider):   name &#x3D; ‘jipinjiading’   allowed_domains &#x3D; [‘www.biqukan.com&#39;]   start_urls &#x3D; [‘http://www.biqukan.com/3_3053/&#39;]\n抓取目录页的标题的链接   def parse(self, response):\ntxt   links = response.css(&quot;.listmain dl dd a::attr(href)&quot;).extract()\n   for link in links:\n       yield scrapy.Request(url=parse.urljoin(response.url, link), callback=self.parse_page)抓取文章页面的标题和内容。   def parse_page(self, response):\ntxt   item = JipinItem()\n   item[&#39;title&#39;] = response.css(&quot;.content h1::text&quot;).extract_first()\n   texts = response.xpath(&quot;//*[@id=\\&quot;content\\&quot;]/text()&quot;).extract()\n   item[&#39;text&#39;] = &quot;&quot;.join(texts).replace(&quot;\\xa0&quot; * 8, &quot;&quot;)\n   yield item # 这个是难点，需要理解。\n\ntxt- pipelines.py\n\n这个是Item Pipeline，即项目管道。面对Spider传递过来的**一个一个**的item，获取item的内容，保存到文件中。\n\n```python\n# -*- coding: utf-8 -*-\n\n# Define your item pipelines here\n#\n# Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting\n# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html\nimport os\n\n\nclass JipinPipeline(object):\n    def process_item(self, item, spider):\n        try:\n            path = &quot;Jipinjiading&quot;\n            if not os.path.exists(path):\n                os.makedirs(path)\n            text = item[&#39;text&#39;]\n            title = item[&#39;title&#39;]\n            print(len(title))\n            with open(&quot;./&quot; + path + &quot;/&#123;&#125;.txt&quot;.format(title), &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:\n                f.write(text)\n        except:\n            pass\n        return item  注意不能用数组，比如*for i in item[‘text’]*等等，因为由于是异步，所以Spider是一个一个向Item Pipeline传递item，而每个item一般包含一组信息。而这个Item Pipeline则会一个一个处理item，这个循环是内定的。我这么理解的。\n\nsettings.py\npythonITEM_PIPELINES = &#123;\n   &#39;Jipin.pipelines.JipinPipeline&#39;: 300,\n&#125;这个需要去掉注释，如果不这样做，就不能实现将Item Pipeline 的作用了。\n\n\nGithub这些完整的代码见于：Github\n参考\n《Python3 网络爬虫开发实战》崔庆才\n\n","slug":"scrapy爬取笔趣看的小说","date":"2021-07-07T04:47:28.000Z","categories_index":"","tags_index":"爬虫","author_index":"Aurora"},{"id":"3c1bb9fa0166d0dcb073cf074128c466","title":"Beautifulsoup 简单爬取笔趣阁的一本小说","content":"我写这个代码的主要目的是针对一个关于上面的题目的博文进行修改，其实，这个博文讲的不错，但是由于网站更新了，他的代码有些地方是不灵的。所以我就修改了一些。\n\n\n\n\n\n\n\n\n\n这个博文\n修改后的代码：(解释见注释)\ntxtfrom bs4 import BeautifulSoup\nimport requests, sys\n\nclass downloader(object):\n    def __init__(self):\n        self.server = &quot;http://www.biqukan.com/&quot;\n        self.target = &quot;http://www.biqukan.com/1_1094/&quot;\n        self.name = []\n        self.url = []\n        self.nums = 0\n\n    def get_download_url(self):\n        req = requests.get(url = self.target)   # 获取网页的内容。\n        req.encoding = req.apparent_encoding    # 为了防止出现乱码，如果没有加这个的话，会出现乱码的。\n        html = req.text\n        div_soup = BeautifulSoup(html, &quot;lxml&quot;)  # 解析，注意要加上&#39;lxml&#39;\n        div = div_soup.find_all(&#39;div&#39;, class_ = &#39;listmain&#39;) # div的类型是bs4.element.ResultSet，是一个列表，不过在这个列表中，它的长度仅为1。\n                                                            # 所以用div[0]读取内容。\n        a_soup = BeautifulSoup(str(div[0]), &quot;lxml&quot;) # Beautifulsoup()里面传入的是str类型。\n        a = a_soup.find_all(&#39;a&#39;)\n        self.nums = len(a[16:])\n        for i in a[16:]:\n            self.name.append(i.string)\n            self.url.append(self.server + i.get(&#39;href&#39;))    # i.get(&#39;href&#39;)是str类型。\n\n    def get_content(self, target):\n        req = requests.get(target)\n        req.encoding = req.apparent_encoding    # 这个也是为了防止出现乱码的。\n        html = req.text\n\n        soup = BeautifulSoup(html, &#39;lxml&#39;)\n        texts = soup.find_all(&#39;div&#39;, class_ = &#39;showtxt&#39;)\n        texts = texts[0].text.replace(&#39; &#39;,&#39;\\n&#39;).replace(&#39;\\xa0&#39;*8,&#39; &#39;) # 这个我不懂为什么为什么要加这个。反正只要加了这个，\n                                                                      # 就会输出需要的内容。\n        return texts\n\n    def writer(self, name, path, text):\n        with open(path, &#39;a&#39;, encoding= &#39;utf-8&#39;) as f:\n            f.write(name + &#39;\\n&#39;)\n            f.writelines(text)\n            f.write(&#39;\\n\\n&#39;)\nif __name__ == &#39;__main__&#39;:\n    dl = downloader()\n    dl.get_download_url()\n    print(&quot;开始下载：&quot;)\n    for i in range(dl.nums):\n        dl.writer(dl.name[i], &#39;一念永恒.txt&#39;, dl.get_content(dl.url[i]))\n        # print(&quot;  已下载:%.3f%%&quot; %  float(i/dl.nums) + &#39;\\r&#39;)\n        sys.stdout.write(&quot;\\r&quot; + &quot;已下载:%.2f%%&quot; %  float(100.0 * i/dl.nums)) # 在一行动态输出，下面的一行也必须要写。\n        sys.stdout.flush()\n    print(&quot;下载结束&quot;)其中，关于在一行动态输出的博文可以见：python实现原地刷新方式输出-可用于百分比进度显示输出_weixin_33736048的博客-CSDN博客\n","slug":"Beautifulsoup-简单爬取笔趣阁的一本小说","date":"2021-07-03T03:23:00.000Z","categories_index":"","tags_index":"爬虫","author_index":"Aurora"},{"id":"57287119be964990fe44e1874987acf7","title":"Beautifulsoup和requests爬取笔趣看","content":"\n\n这个是用来爬取笔趣看的一本书的所有文章，理论上可以成功地爬取笔趣看的每本书。\n关于讲解这个代码之前，我觉得需要注意的一些必要的内容：\n\n这个爬虫实质上就是利用某种工具帮助我们从网上爬取相应的HTML或其他结构，而一般来说，这个HTML或其他结构里面会有我们需要的内容，并且这些一般是字符串类型，也有可能是json类型。\n爬取到这些字符串后，我们接下来用Xpath、Beautifulsoup或PyQuery等等工具解析，因为这样会让我们更高效的找到自己所需要的内容。当然，我们可以不用这些，直接利用字符串的操作函数来找，比如python的split()等等，不过我觉得会比较费事和费力的，我个人不太推荐这个方式的。如果没有特殊的情况的话，还是先用这些解析工具比较好。\n最后利用这些解析工具或用自己的方式找到这些需要的数据以某种形式保存下去，保存的方式有：保存到csv文件，json文件，txt文件，以及保存到MySQL、MongoDB、Redis等等，选自己喜欢的就好。\n这个爬虫，我们需要面对静态页面和有js加载的动态页面，而前者会更简单，可以“可见即可爬”，后者比较困难，不能做到“可见即可爬”，需要利用Google等浏览器的开发者工具来帮助我们查找，就算如此，也有可能碰壁，这时我们可以利用Selenium等工具来帮助我们查找，做到“可见即可爬”，所以，我们有必要区分这两个页面类型，从而选取合适的爬虫方式。\n当我们学爬虫到一定的程度时，我们最好先学习框架，比如Python的Scrapy或Java的WebMagic等等，因为这些优秀的框架可以帮助我们省下不少的爬虫功夫，直接用好的轮子总会比自己闷头造轮子更好的吧。\n最后爬虫的流程一般是：\n\n接下来讲解代码：\n\n首先我们可以打开Google，进入笔趣看的极品家丁的目录页，然后打开开发者工具（用Ctrl+Shift+I），确定需要爬取的各个标题的位置。\n\n然后用requests.get(url) 这个url是目录页的链接，这个功能是爬取网页的源代码（在静态网页上是通用的，而动态网页也许是失效的），其中，为了反爬，特意添加headers，构建一个请求头，具体过程如下：\n\n最后注意编码格式的问题，因为一般来说，中文网的编码格式是gbk的，而我们如果不注意这个情况，爬下来的源代码中涉及到的中文可能出现乱码，因此我们需要进行处理：text.encoding &#x3D; text.apparent_encoding,\n也可以用text.encoding &#x3D; “utf-8”。\n\n然后就是利用Beautifulsoup解析了，关于Beautifulsoup的推荐链接是：崔庆才的博客， 最后并把爬下来的各个标题的链接进行整理，用于接下来的爬虫。\n\n用requests遍历，爬取每个链接里面的内容，其中注意“&amp;nbsp”，这个是\\xa0，最好替换掉，否则会爬不出内容，这个也是反爬的一个比较简单的措施。最后把爬取的内容一个一个的保存到txt文件就行。\n\n\n代码见下面。\ntxtimport requests\nfrom bs4 import BeautifulSoup\n\nheaders = &#123;\n    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\\\n     Chrome/77.0.3865.90 Safari/537.36&quot;\n&#125;\n\nlist_url = []\nlist_title = []\ntarget = &quot;https://www.biqukan.com&quot; # 这个是用来和在目录页爬取的链接相结合，从而得到一个可以访问的链接。\n\n\n# 爬取笔趣看的《极品家丁》的目录页\ndef getHtmlList(url):\n    text = requests.get(url, headers=headers)\n    text.encoding = text.apparent_encoding\n    if text.status_code == 200:\n        text = text.text\n        soup = BeautifulSoup(text, &#39;lxml&#39;)\n        soup = soup.prettify()\n        soup = BeautifulSoup(soup, &#39;lxml&#39;)\n        div = soup.find_all(&quot;div&quot;, class_=&quot;listmain&quot;)\n        a_soup = div[0].find_all(&quot;a&quot;)\n        for item in a_soup:\n            list_url.append(target + item.get(&quot;href&quot;))\n            list_title.append(item.string.replace(&quot;\\n&quot;, &quot;&quot;).strip())\n    else:\n        return None\n\n\n# 爬取每个目录文章的内容，由于在笔趣看的书中，每个目录的的内容格式是几乎一样的。\ndef getHtmlContent(url):\n    txt = requests.get(url, headers=headers)\n    txt.encoding = txt.apparent_encoding\n    if txt.status_code == 200:\n        return txt.text\n    else:\n        return None\n\n\n# 用Beautifulsoup解析爬取的内容，注意&quot;\\xa0&quot;。\ndef parse_content(txt):\n    soup = BeautifulSoup(txt, &#39;lxml&#39;)\n    div = soup.find_all(&#39;div&#39;, class_=&#39;showtxt&#39;)\n    text = div[0].text.replace(&quot; &quot;, &quot;\\n&quot;).replace(&quot;\\xa0&quot; * 8, &#39; &#39;)\n    return text\n\n\n# 保存到txt文件中\ndef save_text(text, path):\n    with open(&quot;./极品家丁/&#123;&#125;.txt&quot;.format(path), &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:\n        f.writelines(text)\n\n\nif __name__ == &#39;__main__&#39;:\n    url = &#39;https://www.biqukan.com/3_3053/&#39;\n    getHtmlList(url)\n    list_url = list_url[13:]\n    list_title = list_title[13:]\n    for i in range(len(list_url)):\n        text = getHtmlContent(list_url[i])\n        text = parse_content(text)\n        save_text(text, list_title[i])\n        print(&quot;\\r&quot; + &quot;下载进度：&#123;:.2f&#125;%&quot;.format(i / len(list_url) * 100), end=&quot;&quot;, flush=True) # 这个可以实现原地刷新，flush=True 和\\r 这两个不能少。","slug":"Beautifulsoup和requests爬取笔趣看","date":"2021-07-01T03:46:00.000Z","categories_index":"","tags_index":"爬虫","author_index":"Aurora"},{"id":"34d456b5a83eea087e8a8a1bd513e081","title":"(brute force, implementation)A. Fafa and his Company","content":"水题\n\n\n题目链接：935A - Fafa and his Company\nA. Fafa and his CompanyFafa owns a company that works on huge projects. There are n employees in Fafa’s company. Whenever the company has a new project to start working on, Fafa has to divide the tasks of this project among all the employees.\nFafa finds doing this every time is very tiring for him. So, he decided to choose the best l employees in his company as team leaders. Whenever there is a new project, Fafa will divide the tasks among only the team leaders and each team leader will be responsible of some positive number of employees to give them the tasks. To make this process fair for the team leaders, each one of them should be responsible for the same number of employees. Moreover, every employee, who is not a team leader, has to be under the responsibility of exactly one team leader, and no team leader is responsible for another team leader.\nGiven the number of employees n, find in how many ways Fafa could choose the number of team leaders l in such a way that it is possible to divide employees between them evenly.\nInput\nThe input consists of a single line containing a positive integer n (2 ≤ n ≤ 105) — the number of employees in Fafa’s company.\nOutput\nPrint a single integer representing the answer to the problem.\nExamples\ninput\nCopy\ntxt2复制\noutput\nCopy\ntxt1input\nCopy\ntxt10output\nCopy\ntxt3Note\nIn the second sample Fafa has 3 ways:\n\nchoose only 1 employee as a team leader with 9 employees under his responsibility.\nchoose 2 employees as team leaders with 4 employees under the responsibility of each of them.\nchoose 5 employees as team leaders with 1 employee under the responsibility of each of them.\n\n这个是一个基础的题，注意题目中的 “find in how many ways” ，可以看出，这个是求分配的方案的总数，这个分配必须保证每个领导带领的人是一样的。因此可以采取模拟。\nPython代码：\ntxtn = int(input())\nsum = 0\ni = 1\nwhile i &lt;= n // 2:\n    if (n - i) % i == 0:\n        sum += 1\n    i += 1\nprint(sum)C++代码：\ntxt#include&lt;iostream&gt;\nusing namespace std;\nint main() &#123;\n    int n;\n    cin &gt;&gt; n;\n    int sum = 0;\n    int i = 1;\n    while (i &lt;= n / 2) &#123;\n        if ((n - i) % i == 0) &#123;\n            sum++;\n        &#125;\n        i++;\n    &#125;\n    cout &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n&#125;","slug":"brute-force-implementation-A-Fafa-and-his-Company","date":"2020-09-06T02:35:56.000Z","categories_index":"","tags_index":"刷题：","author_index":"Aurora"},{"id":"d2a2df109c822658374a25b0dbe541ec","title":"Ajax处理之半次元周榜部分爬虫","content":"Ajax数据爬取的一个简单的例子\n\n\n前言这个是在动态页面的爬虫，而一般来说，现在大部分动态页面通过Ajax加载的，Ajax即Asynchronous Javascript and XML，这个Ajax的作用就是可以让页面在不被全部刷新的情况下可以进行全部更新，我们不能直接用requests.get(url)直接爬取页面的源代码，因为一般来说很难爬到或爬不全我们需要的信息。\n确定页面的类型我们先打开半次元周榜（https://bcy.net/illust/toppost100），当我们下滑到底部时，会发现底部新加载了一些图片，我们可以确定这个网址用Ajax加载的。\nAjax分析接下来打开开发者工具(Ctrl+Shift+I或F12)，然后打开NetWork, 为了更快的找到自己需要找的信息，我们可以直接点击“XHR”（XMLHttpRequests，这个与Ajax加载有关），最后在不断的下滑中，会发现这个XHR界面不断出现一些东西，其中一些东西就是我们需要找的目标。\n\n这个Preview界面我们可以看出里面有一些我们需要的信息，对了，这个没有JS加密，所以可以直接爬，但是 ，这个比较难以用Beautifulsoup或Xpath解析，不过，由于它是json格式的，可以利用json的特点来查找我们需要的信息（即图片的链接）。对了，为了方便分析和查找，推荐使用Google的json-handle插件，这个会让Preview的json更有条理和清晰（直接点击“itemInfo?p&#x3D;4….”，就可以看见这个处理好的json）。\n效果图：\n\nAjax爬取\n首先，我们确定爬取的链接，点击Headers，可以看见有Requests URL，我们可以看出这个请求链接有个规律，除了p有所不同外，其他是一样的，我们可以认为这个p是page，页码，同时，这个链接里面是用“&amp;”链接各个部分的。于是可以利用urllib的urlencode，先构造合适的参数，然后用urlencode解析这个参数，进而得到链接，然后就用requests.get()直接爬取这个json，为了应对可能的反爬，可以添加请求头。\ntxtdef getHTMLText(page):\n    # 构建请求头\n    headers = &#123;\n        &quot;accept&quot;: &quot;*/*&quot;,\n        &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;,\n        &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en-CN;q=0.8,en;q=0.7,ja-CN;q=0.6,ja;q=0.5&quot;,\n        &quot;x-requested-with&quot;: &quot;xmlhttprequest&quot;,\n        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \\\n        (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&quot;\n    &#125;\n    # 构建参数\n    params = &#123;\n        &#39;p&#39;: page,\n        &#39;ttype&#39;: &#39;illust&#39;,\n        &#39;sub_type&#39;: &#39;week&#39;,\n        &#39;date&#39;: &#39;20190923&#39;\n    &#125;\n    # 利用urlencode将参数解析为带有&quot;&amp;&quot;链接的的字符串，和base_url组成可以访问的链接。\n    url = base_url + urlencode(params)\n    txt = requests.get(url, headers=headers, timeout=50)\n    if txt.status_code == 200:\n        return txt.json()  # 返回json文件\n    else:\n        return None\n然后利用这个爬取得到的json，我们可以利用json的特点（类似于字典）一步一步得到我们需要的图片链接：\ntxt# 解析，不过由于返回的是json文件，可以利用json的特点（类似字典）来查找自己需要找的信息。\ndef parse_page(json):\n    if json:\n        for i in range(20):\n            ls = json[&#39;data&#39;][&#39;top_list_item_info&#39;][i][&#39;item_detail&#39;][&#39;multi&#39;]\n            for item in ls:\n                links.append(item[&#39;path&#39;])\n最后就是保存图片，可以利用保存txt文件的方式来保存图片，只不过后缀名需要从“.txt”改为”.jpg”或”.png”等等。\ntxtdef Image_save(links, num):\n    for i in range(1, num + 1):\n        html = requests.get(links[i - 1])\n        with open(&quot;./Image/&#123;&#125;.jpg&quot;.format(i), &quot;wb&quot;) as f:\n            f.write(html.content)\n\n全部代码：txt# encoding=&#39;utf-8&#39;\nimport requests\nfrom urllib.parse import urlencode\n\nlinks = []\nbase_url = &quot;https://bcy.net/apiv3/rank/list/itemInfo?&quot;\n\n\ndef getHTMLText(page):\n    # 构建请求头\n    headers = &#123;\n        &quot;accept&quot;: &quot;*/*&quot;,\n        &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;,\n        &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en-CN;q=0.8,en;q=0.7,ja-CN;q=0.6,ja;q=0.5&quot;,\n        &quot;x-requested-with&quot;: &quot;xmlhttprequest&quot;,\n        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 \\\n        (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&quot;\n    &#125;\n    # 构建参数\n    params = &#123;\n        &#39;p&#39;: page,\n        &#39;ttype&#39;: &#39;illust&#39;,\n        &#39;sub_type&#39;: &#39;week&#39;,\n        &#39;date&#39;: &#39;20190923&#39;\n    &#125;\n    # 利用urlencode将参数解析为带有&quot;&amp;&quot;链接的的字符串，和base_url组成可以访问的链接。\n    url = base_url + urlencode(params)\n    txt = requests.get(url, headers=headers, timeout=50)\n    if txt.status_code == 200:\n        return txt.json()  # 返回json文件\n    else:\n        return None\n\n\n# 解析，不过由于返回的是json文件，可以利用json的特点（类似字典）来查找自己需要找的信息。\ndef parse_page(json):\n    if json:\n        for i in range(20):\n            ls = json[&#39;data&#39;][&#39;top_list_item_info&#39;][i][&#39;item_detail&#39;][&#39;multi&#39;]\n            for item in ls:\n                links.append(item[&#39;path&#39;])\n\n\ndef Image_save(links, num):\n    for i in range(1, num + 1):\n        html = requests.get(links[i - 1])\n        with open(&quot;./Image/&#123;&#125;.jpg&quot;.format(i), &quot;wb&quot;) as f:\n            f.write(html.content)\n\n\nif __name__ == &quot;__main__&quot;:\n    for page in range(1, 4):\n        json = getHTMLText(page)\n        parse_page(json)\n    length = len(links)\n    Image_save(links, length)对了，大家如果有时间，可以看看保存在Github的这个代码：Ajax处理\n参考链接\n崔庆才博客\n《Python3网络爬虫》崔庆才\n\n","slug":"Ajax处理之半次元周榜部分爬虫","date":"2020-07-11T11:51:17.000Z","categories_index":"","tags_index":"爬虫,Python","author_index":"Aurora"},{"id":"1559d2cf4b481d8b25de999a80211dc5","title":"Ubuntu18.04 主题美化（MaxOS主题）","content":"\n\nUbuntu时可以进行主题的美化，可以改为MacOS主题。\n安装工具要安装主题，首先要安装三个包\ntxtsudo apt update\nsudo apt install gnome-tweak-tool\nsudo apt install gnome-shell-extensions\nsudo apt install gnome-shell-extension-dashtodockTweak修改（注意，下面这些已经经过主题美化了）\n经过安装三个包后，我们可以打开Tweaks\n\n\n像上面修改，我们可以发现本来在右上角的按钮放到了左上角了。\n\n修改鼠标的指针的样式\n\n如图，我们可以通过修改cursor ,修改鼠标的箭头的样式。\n\n去掉Shell的无法修改的感叹号\nExtensions -&gt; User themes 打开它\n\n重启，然后可以发现那个感叹号不见了。\n\n将侧边栏放到底部。\nExtensions -&gt; Dash to dock 点击settings图标，像下面的图，然后进一步修改。\n\n\n\n安装主题安装GTK主题McHigh Sierra https://www.pling.com/s/Gnome/p/1013714/\nMcSierra Compact https://www.pling.com/s/Gnome/p/1013741/\n在第一个链接中。\n\n下载这个，到桌面或其他比较便于管理的位置。\n然后再这个位置打开terminal\ntxttar xvf Sierra-light.tar.xz得到解压后的文件。\ntxtsudo mv Sierra-light /usr/share/themes最后在Tweaks中\n\n在applications中修改为Sierra-light，我们可以发现GTK主题改变了。\n安装shell主题其实，shell主题和GTK主题一样，也可以在shell中修改为Sierra-light 也可以。\n\n也可以安装其他主题，比如Sierra-compact-light主题等等。可以在https://www.pling.com/s/Gnome/ 中寻找。\n安装icons主题我选的是MacOS11主题，不过由于这个主题比较大，下载费时，所以下面给出了百度云链接：\n 链接：百度网盘 请输入提取码提取码：f34j\n然后放到某一位置，解压，并把解压后得到的文件夹移动到&#x2F;usr&#x2F;share&#x2F;icons\n最后打开Tweaks，在Appearance 中打开icon，选MacOS11就行。\n\n安装GDM主题（登陆界面主题）百度云链接：百度网盘 请输入提取码 提取码：yetv \n来源：High Ubunterra - Gnome-look.org\n把下载得到的文件解压，得到文件夹，文件夹的内容：\n\n备份&#x2F;usr&#x2F;share&#x2F;gnome-shell&#x2F;theme&#x2F;ubuntu.css\ntxtsudo cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.backup用上图中的ubuntu.css替换掉系统自带的&#x2F;usr&#x2F;share&#x2F;gnome-shell&#x2F;theme&#x2F;ubuntu.css\ntxtsudo cp -i ~/Desktop/liu/setaswallpaper/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css（上面的注意位置别写错）\n把SetAsWallpaper脚本文件复制到~&#x2F;.local&#x2F;share&#x2F;nautilus&#x2F;scripts&#x2F;目录下，然后修改下权限（如果需要）\ntxtsudo cp ~/Desktop/liu/setaswallpaper/SetAsWallpaper ~/.local/share/nautilus/scripts/\nsudo chmod +x SetAsWallpaper然后重启nautilus（下面的命令是关闭）\ntxtnautilus -q执行如下命令，修改下 &#x2F;usr&#x2F;share&#x2F;backgrounds 的权限.\ntxtsudo chmod 777 /usr/share/backgrounds/去~&#x2F;.local&#x2F;share&#x2F;nautilus&#x2F;scripts&#x2F; 目录下执行下SetAsWallpaper脚本。\ntxtsudo ./SetAsWallpape重启系统（这个必须的）\n不过此时壁纸应该会没了，可以重新设置，另外，最好先设置自己喜欢的壁纸，这样的话得到的登陆界面的模糊界面可以是基于自己选的壁纸了。\n效果图\n\n其他主题的一些修改桌面壁纸和锁屏界面壁纸修改在桌面右键点击，点Change background。可以修改壁纸，当然，我们也可以从网上下载自己喜欢的壁纸，存到~&#x2F;Pictures就行。\n头像的修改在Settings中，Details -&gt; Users 点击头像，可以选择自己喜欢的图作为自己的头像。\n最终成色\n\n\n\n\n参考链接：\n给Ubuntu18.04(18.10)安装mac os主题\n[Gnome-look.org\n\n","slug":"Ubuntu18-04-主题美化（MaxOS主题）","date":"2019-09-10T01:56:43.000Z","categories_index":"","tags_index":"Linux,Ubuntu","author_index":"Aurora"},{"id":"57f18ce89cdf822fac0e36fea55160b3","title":"配置VMware的Ubuntu","content":"在上一篇中，我们已经在VMware虚拟机中安装了Ubuntu。接下来还需要对于这个Ubuntu进行配置，使其能够进行一定程度的开发（VMware的Ubuntu的配置和装到硬盘的Ubuntu的配置几乎一样，已经装好了双系统的人，也可以看看这个博文，希望能够给大家带来一些帮助）\n配置内容前言当我们安装好了Ubuntu后，还需要进行一些配置，比如安装vim，切换软件源为清华源，安装搜狗拼音输入法等等。\n###安装VMware tools\n​ 这个VMware tools十分有用，当安装好了后， 界面的大小可以自动适应屏幕，还可以打开共享文件夹。\n​ 首先，点击界面的左上方的“虚拟机”，然后点击“安装VMware tools”，等待一些时间，我们可以在桌面中看见：\n\n（忽略背景和主题，这些是我已经进行美化了，具体的美化方法可以见我的下一篇博文）\n步骤：\n然后在这个VMware tools界面中， ctrl + alt + t， 打开terminal，输入\n\ntxtsudo mv VMwareTools-10.2.5-8068393.tar.gz ~/Desktop移动压缩文件到桌面，方便管理。\n\n解压安装包\n\ntxtcd ~/Desktop\ntar xvf VMwareTools-10.2.5-8068393.tar.gz\n进到vmware-tools-distrib, 用sudo 运行 vmware-install.pl, 安装VMware tools。安装过程第一次询问的时候，输入 yes, 之后一路回车即可。\n\ntxtcd vmware-tools-distrib\nsudo ./vmware-install.pl\n当我们再点击界面左上方的虚拟机时，如果出现“重新安装VMware Tools”时，安装VMware就算是完成了。\n关于自动调整大小，需要在虚拟机界面中 查看-&gt;自动调整大小 勾选自动适应客户机就可以了。\n\n切换软件源为国内源，比如清华源。​ 这个是有必要做的，因为这个会大大加快apt upgrade 和 apt install 的速度，可以在较短的时间内安装和升级包，节省不少时间。\n清华源的网址： ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n我们选择与自己的版本相对应的。目前没有19.04版本(2019年8月21日)，不过有18.04已经够了。\n步骤：\n切换源之前把相应的配置文件备份一份，保险。\n\ntxtsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n打开清华源官网，如图：\n\n\ntxtsudo gedit /etc/apt/sources.list用gedit 打开这个配置文件，把上面几行网址（去掉注释）替代配置文件上的内容，然后保存。也可以用vi，不过对于linux新手来说可能是比较麻烦的。\n\n更新软件包缓存\n\ntxtsudo apt update\nsudo apt upgrade到此，我们算是正式完成切换到国内源，当然，也可以换成其他的国内源，比如阿里源等等。\n&#x3D;### 打开共享文件夹\n当我们安装好了VMware Tools后，就可以打开共享文件夹了。\n步骤：\n在虚拟机界面左上角点击虚拟机。如图\n\n\n点击共享文件夹，点击启用\n\n\n然后点击下面的添加，如果没有，就建立一个，继续点下一个，勾选“启用其共享”\n\n\n这个已建立的文件夹中，如果我们放入一些文件其中，我们便可以在虚拟机中的ubuntu里的 &#x2F;mnt&#x2F;hgfs&#x2F;share 中找到一样的东西，因此，我们可以先在windows中下载一些东西，然后放到这个已建立的文件夹中，我们可以在ubuntu中用这些东西，很方便。\n安装VIMLinux虽然有vi，不过Ubuntu自带的vi非常难用，比如在插入模式下方向键不能用，而是会输出ABCD的文字。所以我们得更新vi到vim。\ntxtsudo apt install vim(我们可能会见到要输入[Y&#x2F;n], 我们只需要输入Y就行)。\nps: VIM的主题如何修改： 只需要在VIM界面中用右键点击，点preferences，然后再color中修改就行。\n安装gittxtsudo apt install git安装gcc&#x2F;g++txtsudo apt install g++\nsudo apt install gcc安装搜狗拼音输入法​ 不过Ubuntu18.04已经有了中文输入法，我们可以在相应的设置中进行修改就可以得到。但是，我个人觉得这个输入法不如搜狗拼音输入法好用，所以我就安装搜狗拼音输入法了。\n步骤：\n卸载ibus。\n我们安装搜狗输入法前，必须卸载ibus才能行，否则一安装后，就不得不面对用搜狗输入法打字时却同时出现Ubuntu自带的中文输入法候选框和搜狗拼音输入法的候选框的bug ，所以还不如先卸载ibus，而且卸载ibus不会给Ubuntu带来一些问题。\n\n\ntxtsudo apt remove ibus清除ibus配置。\ntxtsudo apt purge ibus卸载顶部面板任务栏上的键盘指示。\ntxtsudo  apt-get remove indicator-keyboard安装fcitx输入法框架\ntxtsudo apt install fcitx-table-wbpy fcitx-config-gtk切换为 Fcitx输入法\ntxtim-config -n fcitxim-config 配置需要重启系统才能生效（下面的命令就是重启）\ntxtsudo shutdown -r now\n下载和安装搜狗输入法\n搜狗输入法linux版本的百度云链接：链接：百度网盘 请输入提取码\n提取码：lxe6 \n我们可以从这个链接下载deb文件，然后放到相应的位置上，在这个位置打开terminal\n\n\ntxtsudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb​ 这个deb文件用dpkg命令实现安装。\n\n修复损坏缺少的包和打开fcitx输入法配置。\n修复：\ntxtsudo apt-get install -f然后重启（这个再次重启比较好）\n然后打开Fcitx 输入法配置：\ntxtsudo killall fcitx如图：\n\n如果有Sogou Pinyin，就OK了。\n\n最后：\n我们还需要打开setting中的region and language的设置，在Input source 中添加Chinese。\n然后输入一些字时，打开搜狗拼音输入法的设置，然后关闭（这样的话能够可以实现shift切换中英文，如果不这样做的话，shift 键的功能就失效了，emmmmm）。\n\n\n注意事项\n换国内源，移动文件，打开文件等等操作时，最好用sudo，因为如果不用sudo ，这些操作未必都能实现。\n\n如果出现了搜狗输入法的候选框的乱码时：\n用下面就行\ntxtsudo killall fcitx\ncd ~/.config\nsudo rm -rf SogouPY* sogou*\n可以用ctrl+shift+f 实现简体和繁体的转换。\n\n\n参考链接\n良许Linux-手把手教你配置虚拟机\n清华源\nubuntu 18.04 LTS 安装搜狗输入法\n[VMware下共享文件夹的实现\n\n","slug":"配置VMware的Ubuntu","date":"2019-09-06T05:49:08.000Z","categories_index":"","tags_index":"Linux,Ubuntu","author_index":"Aurora"},{"id":"1e74df27348c841e726ea8afb123d960","title":"使用VMware虚拟机安装Ubuntu18.04","content":"这个是利用VMware虚拟机安装Ubuntu的。由于我的笔记本电脑的硬盘有点问题，所以利用USB安装Ubuntu时，却经常扫描不到硬盘，所以最后放弃安装双系统。改为利用虚拟机了。\nVMware 的百度云链接：百度网盘 请输入提取码提取码：sr62 \nUbuntu 的百度云链接：百度网盘 请输入提取码\n提取码：hbz4 \nVMware 的安装我们可以在上面给出的链接进行下载。这个链接长期有效。然后根据提示一步一步安装，最后根据给出的密钥进行注册。\nUbuntu18.04下载这个要注意！！！，必须从官网进行下载，这个必须的，因为如果不是从官网下载的话，安装过程可能会出错的。推荐下载Ubuntu Desktop 18.04 LTS。当然，如果嫌慢的话，也可以从我给的链接下载（如果你有超级会员或其他破解工具的话），这个是从官网亲自下载的，保证正确。\n虚拟机的配置\n打开虚拟机，点击创建虚拟机，然后得到如下图：\n\n可以直接点下一步。\n\n然后得到下面的图，像这样。再点下一步。\n\n\n既然是要安装Ubuntu，用Ubuntu64就行。\n\n\n下面自己设置就行\n\n\n\n​ 这个步骤，磁盘大小最好至少20GB，当然，设置更大就更好了，对了，起初是占用不多，才几GB，然后往里面添加一些文件才会变大。\n\n接下来就是继续点下一步，直至完成。然后还要点击编辑虚拟机设置。\n\n​ 最后在下面的图中：\n\n\n\n用这个，浏览Ubuntu镜像保存的位置。最后点击确定。\nUbuntu安装最后，VMware虚拟机配置好了，接下来就是点击开启此虚拟机，开始安装。安装步骤不难（和那个让我头大的生双系统安装相比太简单了，几乎是傻瓜式的）：（先不放图了）\n\n点击“Install Ubuntu”（我觉得最好用English比较好，因为用中文可能会有一些bug。。。用English权当练习英语吧）\n点continue,并且在‘Update and other software’ 中划上 ‘minimal installation’ （会省下一些时间）, 也划上 ‘Download updates while installation’ ,再点continue。\n在Installation Type选默认就行。弹出的提示也点继续就行，（注意！！！！，在安装双系统时，这个不能点，要点最下边的那个，方便分区）\n在Where Are You?点击中国，接下来就是填写个人信息，注意密码不能忘了，切记。\n最后就是点击安装了，我这个渣渣的校园网安装这个花了半小时左右。\n安装完毕后，点击restart now,重启虚拟机，当然，有可能会碰上重启时卡了，还一闪一闪的，可以直接打开windows进程，杀死VMware进程，然后进入VMware，点打开虚拟机，启动就行。\n\n参考链接：\n良许LInux-知乎-手把手教你安装Linux虚拟机\n\n","slug":"使用VMware虚拟机安装Ubuntu18-04","date":"2019-09-06T03:35:47.000Z","categories_index":"","tags_index":"Linux,Ubuntu","author_index":"Aurora"}]