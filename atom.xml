<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuweixu</title>
  
  <subtitle>liuweixu个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-25T15:42:52.898Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liuweixu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找进阶-最小化最大值问题</title>
    <link href="http://example.com/2023/09/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BF%9B%E9%98%B6-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/09/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BF%9B%E9%98%B6-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/</id>
    <published>2023-09-20T15:10:01.000Z</published>
    <updated>2023-09-25T15:42:52.898Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最小化最大值介绍"><a href="#最小化最大值介绍" class="headerlink" title="最小化最大值介绍"></a>最小化最大值介绍</h4><p>参考：<a href="https://www.cnblogs.com/cs-whut/p/11216941.html#:~:text=%E8%A6%81%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%8C%96,%E8%A2%AB%E5%88%86%E4%B8%BAm%E4%B8%AA%E9%83%A8%E5%88%86%E3%80%82">二分法（二）：采用二分法解决“最小化最大值问题” - aTeacher - 博客园 (cnblogs.com)</a> </p><p>二分法除了可以进行有序查找、解方程等外，还可以用来解决一些实际问题。这些问题中，非常典型的应用就是“最小化最大值问题”和“最大化最小值问题”</p><p>   “最小化最大值问题”和“最大化最小值问题”在优化问题中比较常见，简单来说，“最小化最大值”是为了压制优化目标中表现最突出的成分，“最大化最小值”为了提升优化目标中表现最差的成分。</p><p>   （1）“最小化最大值问题”</p><p>   一般来说，优化时考虑的是目标函数的最大化或最小化的问题。但是在某些情况下，则要求最大值的最小化才有意义。例如，在城市规划中需要确定急救中心、消防中心的位置，可取的目标函数应该是到所有地点最大距离的最小值（即急救中心、消防中心的建设位置应保证它到最远需求点的距离尽可能小），而不是到达所有目的地距离和的最小值。因为城市同时发生事故或同时着火的几率极低，因此更多应该考虑如何降低最恶劣情况的影响，即使是最远的地方出事了，中心到它们的距离也能达到最小。</p><p>   （2）“最大化最小值问题”</p><p>   这个问题在通信链路中应用比较多，如基站同时和多用户通信，每个基站到用户的通信为一个通信链路，且基站的发射功率是固定的。为了保证所有的通信链路都正常工作，应该去优化最差链路的通信情况，降低信道较好链路的基站发射功率，增加信道较差链路的基站发射功率，这是一个最大化最小值问题。</p><h4 id="典型的-leetcode题"><a href="#典型的-leetcode题" class="headerlink" title="典型的 leetcode题"></a>典型的 leetcode题</h4><h5 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a>410. 分割数组的最大值</h5><p>该题是典型的最小化最大值问题，即将各个连续数组的和最大值取得最小值。</p><p><strong>思路：</strong>要解决这个最小化最大值的问题，基本思路就是选取任意一个范围（输入数组的最大值到数组所有元素的和），然后在这个范围内进行二分法，每次把范围的中间值mid当作最小值，然后判断在mid值下数组是否能够被分为m个部分。如果判断出值为mid时可以将数组分成m个部分，就先让mid变大再试试，即增大下界（left&#x3D;mid+1）；如果分不成m个部分，说明当前的mid太大了，就先让mid变小再进行判断，即减小上界（right&#x3D;mid-1）。直到求出一个最大的mid就是最终的答案。</p><p>因为要求各个子数组和的最大值中的最小，所以该值肯定大于等于所有数组的最大值，并且肯定小于等于数组的所有和，并且这个数值是连续递增，于是可以用二分解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> mid, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; mid)&#123;</span><br><span class="line">                sum = a[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count + <span class="number">1</span> &lt;= m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left)&#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(judge(nums, mid, k))&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2560-打家劫舍IV"><a href="#2560-打家劫舍IV" class="headerlink" title="2560. 打家劫舍IV"></a>2560. 打家劫舍IV</h5><p><a href="https://leetcode.cn/problems/house-robber-iv/description/">2560. 打家劫舍 IV - 力扣（LeetCode）</a></p><p>该题和之前的三个打家劫舍问题不同的是，其题是最小化最大值问题，所以更适合用二分方法。</p><p><strong>思路：</strong></p><p>从中可知，最大值是小偷窃取过程中能从单间房屋中窃取的<strong>最大金额</strong>，所以最小值就是该数组的最小值，而最大值则是该数组的最大值，并且可以认为这些数值是递增，所以可以用二分【针对二分出来的答案是否在nums的问题，可以见<a href="https://leetcode.cn/problems/house-robber-iv/solutions/2093952/er-fen-da-an-dp-by-endlesscheng-m558/">2560. 打家劫舍 IV - 力扣（LeetCode）</a> 的题解】。</p><p>求解时需要得到一个最大的下限，该值可以能够满足至少窃取 $k$ 个房屋后，小偷的最小窃取能力。求解该问题时，可以用贪心思路，即在从左到右遍历数组时，能偷就偷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCapability</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Arrays.stream(nums).min().getAsInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Arrays.stream(nums).max().getAsInt();</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= middle)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    i++; <span class="comment">//如果当前偷了，就必须跳过下一个房子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= k)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">最小化最大值问题的二分求解方法</summary>
    
    
    
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-基数排序</title>
    <link href="http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-17T04:25:43.000Z</published>
    <updated>2023-09-25T04:30:27.005Z</updated>
    
    <content type="html"><![CDATA[<p>基数排序适合针对位数比较大的数值的排序，比如手机号等，其思路是构建多个桶，然后每个桶按照其个位数放，然后取出来，接着按照十位数放，再取出来，这样循环处理，就可以对数值进行排序。</p><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">针对11位的手机号排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadisSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radisSort</span><span class="params">(String[] a)</span>&#123;</span><br><span class="line">        List&lt;String&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从低位向高位排序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a[<span class="number">0</span>].length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">                buckets[s.charAt(i) - <span class="string">&#x27;0&#x27;</span>].add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;String&gt; bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : bucket) &#123;</span><br><span class="line">                    a[k++] = s;</span><br><span class="line">                &#125;</span><br><span class="line">                bucket.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] a = &#123;<span class="string">&quot;1113123123&quot;</span>, <span class="string">&quot;1133123123&quot;</span>, <span class="string">&quot;1133123087&quot;</span>, <span class="string">&quot;1133123123&quot;</span>, <span class="string">&quot;1233123123&quot;</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        radisSort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展</strong></p><p>如果数值里面有 abc 等字符时，如何排序？</p><p>只需要将桶的个数增加就行，比如增加到 128，刚好存下 ASCII 的字符。</p>]]></content>
    
    
    <summary type="html">基数排序总结</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-桶排序</title>
    <link href="http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-17T03:39:29.000Z</published>
    <updated>2023-09-25T03:50:24.997Z</updated>
    
    <content type="html"><![CDATA[<p>桶排序是在计数排序的基础上改进的，差不多对于有 n 个元素的计数排序上，就有 n 个桶，每个桶放一个元素，但是对于元素很大的数组时，这个情况存在数据超出容量的问题，所以需要设置每个桶放多个元素，并且放完后，需要对桶里面的元素排序。</p><p>然后需要创建动态数组，因为不确定每个桶里面会有多少个元素，所以针对每个桶要分别加个动态数组，此处可以使用 2 个 ArrayList 或 DynamicArray 来创建。</p><p>最后，需要注意的是，针对-9-9这个较为极端的情况下，需要手动设置每个桶放置的元素个数，并且需要借鉴计数排序，求出最大值和最小值，然后计算合适的桶的个数，以及怎么将每个元素放到合适的桶上（关键点是最小值）。</p><p>其平均时间复杂度是 O(n+k)，但是最差的时间复杂度可以有 O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketsort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            max = Math.max(max, a[i]);</span><br><span class="line">            min = Math.min(min, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (max - min) / range + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            buckets.get((a[i] - min) / range).add(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++)&#123;</span><br><span class="line">            Collections.sort(buckets.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; buckets.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(buckets.get(i).toArray()));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets.get(i).size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = buckets.get(i).get(<span class="number">0</span>);</span><br><span class="line">                buckets.get(i).remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">17</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bucketsort(a, <span class="number">3</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">桶排序简要总结</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-计数排序</title>
    <link href="http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-17T03:00:56.000Z</published>
    <updated>2023-09-25T03:03:11.626Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序不需要元素交换<br>要点：  </p><ol><li>找到最大值，创建一个大小为最大值+1的count数组  </li><li>count 数组的索引对应原始数组的元素，用来统计该元素的出现次数  </li><li>遍历count数组，根据count数组的索引（即原始数组的元素）以及出现次数，生成排序后的内容<br>count 数组的索引是：已排序好的</li></ol><p>上述技术排序的前提：待排序元素 &gt;&#x3D; 0，且不能太大<br>如何改进？（对负数排序）<br>也要找最小值，将最小值映射为索引为0</p><p>时间复杂度大概在 O(N + K)，比较低了，属于以空间换时间的一个典型例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingsort</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; max)&#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; min)&#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            count[a[i] - min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = i + min;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">2</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        countingsort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">计数排序练习</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-希尔排序</title>
    <link href="http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-16T03:17:21.000Z</published>
    <updated>2023-09-24T03:20:46.909Z</updated>
    
    <content type="html"><![CDATA[<p>对插入排序的优化<br>要点：  </p><ul><li>实现分组插入，每组元素之间的间隙为 gap  </li><li>每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序。  </li><li>对插入排序优化，让元素更快速交换到最终位置。  </li><li>插入排序可以视为希尔排序上的 gap 为 1 时的特殊情况 ，所以<strong>程序上和插入排序类似</strong>。</li><li>平均时间复杂度是 **O(nlogn)**，最差时间复杂度是 O(n^2) ，最好的时间复杂度是O(nlogn)</li><li>算法是<strong>不稳定</strong>的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对插入排序的优化</span></span><br><span class="line"><span class="comment">要点：</span></span><br><span class="line"><span class="comment">- 实现分组插入，每组元素之间的间隙为gap</span></span><br><span class="line"><span class="comment">- 每轮排序后gap逐渐变小，直至gap为1完成排序。</span></span><br><span class="line"><span class="comment">- 对插入排序优化，让元素更快速交换到最终位置。</span></span><br><span class="line"><span class="comment">- 插入排序可以视为希尔排序上的gap为1时的特殊情况</span></span><br><span class="line"><span class="comment">- 平均时间复杂度是O(nlogn)，最差时间复杂度是O(n^2)，最好的时间复杂度是O(nlogn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellsort</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="comment">//a.length / 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length &gt;&gt; <span class="number">1</span>; gap &gt;=<span class="number">1</span>  ; gap &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> gap; low &lt; a.length; low++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - gap;</span><br><span class="line">                <span class="comment">//自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置</span></span><br><span class="line">                <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i])&#123;</span><br><span class="line">                    a[i+gap] = a[i];</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i != low - gap)&#123;</span><br><span class="line">                    a[i+gap] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        shellsort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">希尔排序学习</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-插入排序</title>
    <link href="http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-16T02:50:12.000Z</published>
    <updated>2023-09-24T02:54:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>注意要和选择排序区分<br>插入排序的要点：【插入】  </p><ol><li>将数组分为两部分[0…low-1][low…a.length -1]<br>左边是已排序的部分<br>右边是未排序的部分  </li><li>每次从未排序区域取出low位置的元素，插入到已排序的区域。</li><li>有递归版本和非递归版本，下面使用的是非递归版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意和选择排序区分</span></span><br><span class="line"><span class="comment">插入排序的要点：【插入】</span></span><br><span class="line"><span class="comment">1. 将数组分为两部分[0...low-1][low...a.length -1]</span></span><br><span class="line"><span class="comment">    左边是已排序的部分</span></span><br><span class="line"><span class="comment">    右边是未排序的部分</span></span><br><span class="line"><span class="comment">2. 每次从未排序区域取出low位置的元素，插入到已排序的区域。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    非递归版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>; low &lt; a.length; low++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i])&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != low - <span class="number">1</span>)&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        insertion(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">插入排序</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-堆排序</title>
    <link href="http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-16T01:29:56.000Z</published>
    <updated>2023-09-24T02:54:48.187Z</updated>
    
    <content type="html"><![CDATA[<p>在掌握堆排序前需要先理解堆的数据结构：</p><ul><li><p>堆是一个完全二叉树。</p></li><li><p>在构建堆时，需要重点掌握下潜算法、上浮算法和建堆。</p></li><li><p>以大顶堆为例，下潜算法指的是如果所在的节点的数值比左右子节点要小，就需要交换，此时可以使用递归方法。</p></li><li><p>还是以大顶堆为例，上浮算法指的是如果所在的节点的值比其父节点的值要大，就要逐步交换，可以使用while函数</p></li><li><p>如果要从小到大的排序，则需要使用大顶堆</p><ul><li><p>建立大顶堆</p></li><li><p>每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让其重新符合大顶堆的特性，并逐步缩减，直至堆的元素数量为1为止。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    建堆 Floyd建堆方法， 时间复杂度O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下潜</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; size &amp;&amp; array[max] &lt; array[left])&#123;</span><br><span class="line">            max = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; size &amp;&amp; array[max] &lt; array[right])&#123;</span><br><span class="line">            max = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != parent)&#123;</span><br><span class="line">            swap(max, parent);</span><br><span class="line">            down(max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取堆顶函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除指定索引处的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    替换堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == array.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    上浮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span>(child &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(offered &gt; array[parent])&#123;</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            child = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">Heap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(array);</span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(heap.size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            heap.swap(<span class="number">0</span>, heap.size - <span class="number">1</span>);</span><br><span class="line">            heap.size--;</span><br><span class="line">            heap.down(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public class Heap &#123;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">堆排序复习</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找的记录</title>
    <link href="http://example.com/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E8%AE%B0%E5%BD%95/</id>
    <published>2023-09-14T12:30:33.000Z</published>
    <updated>2023-09-25T14:46:51.483Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分查找程序"><a href="#二分查找程序" class="headerlink" title="二分查找程序"></a>二分查找程序</h4><p>在二分查找上，根据区间的确定，主要有二种不同的写法：左闭右闭，左闭右开。</p><p>在左闭右闭上，需要在 while 循环内满足 $left \leq right$，并且在 right 要为$middle-1$。</p><p>而在左闭右开上，则是需要在 while 循环内满足 $left &lt; right$，并且在 right 要为 $middle$。</p><p>以左闭右闭为例，程序有:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line">        System.out.println(binarysearch(a, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找的最大查找次数"><a href="#二分查找的最大查找次数" class="headerlink" title="二分查找的最大查找次数"></a>二分查找的最大查找次数</h4><p>在上述程序进行修改，就可以得到计算查找次数的程序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(a[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                candidate = middle;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line">        System.out.println(binarysearch(a, <span class="number">15</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是 4 ，也就是说，如果查找不到元素时，最大的查找次数就是 4，而如果数组长度为 7，相应的最大查找次数是 3，这个是有相应的公式：</p><p>$$<br>res &#x3D; \lfloor log_2(N) \rfloor +1<br>$$</p><p> 其中$N$为数组的长度。</p><h4 id="二分查找时的最左和最右元素"><a href="#二分查找时的最左和最右元素" class="headerlink" title="二分查找时的最左和最右元素"></a>二分查找时的最左和最右元素</h4><p>问题：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p>需要在一个有序数组上，查找某个元素的第一个和最后一个位置，也可以在上述的程序的基础上，加以修改得到的，关键是如果 $left &#x3D;&#x3D; right$ 时，针对 $middle$ 加一或减一，从而让指针向右移动或向左移动，得到目标元素的最后一个位置或第一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                candidate = middle;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &lt; target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                candidate = middle;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder(nums, target), rightBorder(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找的总结与记录</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二分" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）JVM简要总结</title>
    <link href="http://example.com/2023/09/02/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89JVM%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/09/02/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89JVM%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-09-02T06:01:29.000Z</published>
    <updated>2023-09-07T06:11:11.598Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h4 id="字节码-1"><a href="#字节码-1" class="headerlink" title="字节码"></a>字节码</h4><ol><li><p>Java分为编译时与运行时，而字节码与编译时有关。</p></li><li><p><strong>类加载机制</strong>与字节码密切相关。</p></li><li><p>IDEA 默认会用 Fernflower 反编译工具将<strong>字节码文件（后缀为 .class 的文件，也就是 Java 源代码编译后的文件）</strong>反编译为我们可以看得懂的 Java 源代码。</p></li><li><p>在编译阶段，Java会将Java源代码文件编译为字节码文件。在这个阶段，编译器会进行一些检查工作，比如说，某个关键字是不是写错了，语法上是不是符合预期了，不能有很明显的错误，否则带到运行时再检查出来就会比较麻烦了。</p></li><li><p>Java 字节码是沟通 JVM 与 Java 代码的桥梁，可以用javap查看。</p></li><li><p>Java虚拟机采用基于栈的架构，其指令由操作码与操作数组成。</p><p>0xb2 getstatic 获取静态字段的值<br>0x12 ldc 常量池中的常量值入栈<br>0xb6 invokevirtual 运行时方法绑定调用方法<br>0xb1 return void 函数返回</p></li><li><p>JVM会在<strong>准备阶段</strong>对类变量（静态变量， static修饰）<strong>分配内存并初始化</strong>（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p><p>也就是说，假如有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">chenmo</span> <span class="operator">=</span> <span class="string">&quot;沉默&quot;</span>; <span class="comment">//会查看常量池是否存在，只创建一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">cmower</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br></pre></td></tr></table></figure><p>chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 <code>null</code>。</p><p>需要注意的是，<code>static final</code> 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 <code>null</code>。</p></li></ol><h4 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h4><p><a href="https://tobebetterjavaer.com/jvm/class-file-jiegou.html">详解Java的类文件（class文件）结构 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><ul><li>使用xxd命令后，得到16进制内容，其中如果开头有cafe base这个魔数，说明这个class文件可以被JVM接受。</li></ul><p>上面往后抽空看。</p><h4 id="Javap与字节码"><a href="#Javap与字节码" class="headerlink" title="Javap与字节码"></a>Javap与字节码</h4><p><a href="https://tobebetterjavaer.com/jvm/bytecode.html">从javap的角度轻松看懂字节码 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p>上面抽空看</p><ol><li><p>Java 内置了一个反编译命令 javap，可以通过 <code>javap -help</code> 了解 javap 的基本用法</p></li><li><p>常量池</p><p>Constant pool，也就是字节码文件最重要的常量池部分。可以把常量池理解为<strong>字节码文件中的资源仓库，主要存放两大类信息。</strong></p><p>1）<strong>字面量</strong>（Literal），有点类似 Java 中的常量概念，比如文本字符串，final 常量等。</p><p>2）<strong>符号引用</strong>（Symbolic References），属于编译原理方面的概念，包括 3 种：</p><ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ul><p>Java 虚拟机是在加载字节码文件的时候才进行的动态链接，也就是说，字段和方法的符号引用只有经过<strong>运行期转换后才能获得真正的内存地址</strong>。当 <strong>Java 虚拟机运行</strong>时，需要从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。</p></li></ol><h4 id="JVM字节码详情"><a href="#JVM字节码详情" class="headerlink" title="JVM字节码详情"></a>JVM字节码详情</h4><h4 id="虚拟机-字节码"><a href="#虚拟机-字节码" class="headerlink" title="虚拟机 字节码"></a>虚拟机 字节码</h4><h4 id="HSDB"><a href="#HSDB" class="headerlink" title="HSDB"></a>HSDB</h4><h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><p><a href="https://tobebetterjavaer.com/jvm/asm.html">史上最通俗易懂的ASM教程 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p>前面有讲基础内容。</p><h4 id="自己编译JDK"><a href="#自己编译JDK" class="headerlink" title="自己编译JDK"></a>自己编译JDK</h4><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h4 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h4><ol><li><p>类<strong>加载</strong>过程</p><p>Loading</p><p>Verification</p><p>Preparation【编译时阶段】</p><p>Resolution【运行时阶段】</p><ul><li><p>该阶段将常量池中的<strong>符号引用</strong>转化为<strong>直接引用</strong>。</p><p><strong>符号引用</strong>以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。（<strong>就是不知道内存地址，先暂时用它的名字，也就是符号</strong>）</p><p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 <code>com.Wanger</code> 类引用了 <code>com.Chenmo</code> 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 <code>com.Chenmo</code>。</p><p><strong>直接引用</strong>通过对<strong>符号引用进行解析</strong>，找到引用的实际内存地址。</p></li></ul><p>Initialization</p><ul><li>该阶段是类加载过程的最后一步。<strong>在准备阶段，类变量已经被赋过默认初始值</strong>，而在初始化阶段【运行时阶段】，类变量将<strong>被赋值为代码期望赋的值</strong>。换句话说，初始化阶段是执行<strong>类构造器方法</strong>的过程。</li></ul></li><li><p>类加载器</p><p>Java 类加载器可以分为三种。<strong>【黑马八股文有讲】</strong></p><p>注意：这个三种是JDK8之前的情况，JDK9有改动。</p><p>1）启动类（或者说引导类）加载器（Bootstrap Class-Loader），加载 <code>jre/lib</code> 包下面的 jar 文件，比如说常见的 rt.jar，通常以null表示。</p><p>2）扩展类加载器（Extension or Ext Class-Loader），加载 <code>jre/lib/ext</code> 包下面的 jar 文件，它的父类加载器为引导类加载器。</p><p>3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。它的父类加载器为扩展类加载器。</p><p>JDK9的改动：</p><p>Java 9仍然保留了三层类加载器结构，<strong>不过为了支持模块系统</strong>，对它们做了一些调整。扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为<strong>平台类加载器（platform class loader）</strong>。可以通过<code>ClassLoader</code>的新方法<code>getPlatformClassLoader()</code>来获取。Java 9中的内置类加载器如下所示。</p><ul><li><p>引导类加载器：定义<strong>核心</strong>Java SE和JDK模块。</p></li><li><p>平台类加载器：定义<strong>部分</strong>Java SE和JDK模块。</p></li><li><p>应用或系统类加载器：定义<strong>CLASSPATH上的类和模块路径中的模块</strong>。</p></li></ul><p><strong>关键程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```Java</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderMain.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line">  classLoader = classLoader.getParent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre></li><li><p>双亲委派模型</p><p>如果以上三种类加载器不能满足要求的话，程序员还可以自定义类加载器（继承 <code>java.lang.ClassLoader</code> 类），它们之间的层级关系如下图所示。</p><p>【图片见<a href="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/jvm/class-load-02.png%E3%80%91">https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/jvm/class-load-02.png】</a></p><p>自定义类加载器的父类是应用类加载器（JDK8前）</p><p>这种层次关系被称作为<strong>双亲委派模型</strong>：如果一个类加载器收到了加载类的请求，它会<strong>先把请求委托给上层加载器去完成</strong>，上层加载器<strong>又会委托</strong>上上层加载器，一直到最顶层的类加载器；如果上层加载器<strong>无法完成类的加载工作时</strong>，当前类加载器才会尝试自己去加载这个类。</p><p>使用双亲委派模型有一个很明显的好处，那就是 Java 类随着它的类加载器一起具备了<strong>一种带有优先级的层次关系</strong>，这对于保证 Java 程序的稳定运作很重要。</p><p>上文中曾提到，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，<strong>那这两个类就必定不相等</strong>——双亲委派模型能够保证同一个类最终会被特定的类加载器加载。</p></li></ol><h2 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ol><li><p>程序计数器（Program Counter Register）所占的内存空间不大，很小一块，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个计数器的值来选取下一条需要执行的字节码指令，像分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p></li><li><p>在 JVM 中，多线程是通过线程轮流切换来获得 CPU 执行时间的，因此，在任一具体时刻，一个 CPU 的内核只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，并且不能互相干扰，否则就会影响到程序的正常执行次序。</p><p>也就是说，我们要求程序计数器是<strong>线程私有</strong>的。</p></li><li><p>《Java 虚拟机规范》中规定，如果线程执行的是非本地（native）方法，则程序计数器中保存的是当前需要执行的指令地址；如果线程执行的是本地方法，则程序计数器中的值是 undefined。</p><p>为什么本地方法在程序计数器中的值是 undefined 的？因为本地方法大多是通过 C&#x2F;C++ 实现的，并未编译成需要执行的字节码指令。</p><p>由于程序计数器中存储的数据所占的空间不会随程序的执行而发生大小上的改变，因此，程序计数器是不会发生内存溢出现象（OutOfMemory）的。</p></li></ol><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><a href="https://tobebetterjavaer.com/jvm/how-jvm-run-zijiema-zhiling.html">Java虚拟机是如何执行字节码指令的？ | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ol><li>所有线程共享的一块内存区域。在 <strong>Java 虚拟机启动的时候创建</strong>，用来存储<strong>对象</strong>（数组也是一种对象，new创建）。</li><li>以前，Java 中“几乎”所有的对象都会在堆中分配，但随着 JIT（Just-In-Time）编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么“绝对”了。<strong>从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了</strong>，意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</li><li>堆是 Java 垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度来看，由于垃圾收集器基本都采用了分代垃圾收集的算法，所以堆还可以细分为：<strong>新生代和老年代</strong>。新生代还可以细分为：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是<strong>更好地回收内存，或者更快地分配内存。</strong></li><li>堆这最容易出现的就是 OutOfMemoryError 错误，分为以下几种表现形式：<ul><li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>：当JVM花费太多时间执行垃圾回收并且只能回收很少的堆空间时，会发生这个错误的，就是堆空间爆满。</li><li><code>java.lang.OutOfMemoryError: Java heap space</code>：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。和本机的物理内存无关，和我们配置的虚拟机内存大小有关！</li></ul></li></ol><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p><a href="https://tobebetterjavaer.com/jvm/neicun-jiegou.html#_05%E3%80%81%E5%85%83%E7%A9%BA%E9%97%B4">https://tobebetterjavaer.com/jvm/neicun-jiegou.html#_05、元空间</a></p><ol><li><p>JDK8后，元空间取代方法区（或者说永久代），方法区和堆一样，是线程共享的区域，它用来存储已经被 <strong>Java 虚拟机加载的类信息、常量、静态变量，以及编译后的代码</strong>等。</p></li><li><p>在方法区中，还有一块非常重要的部分，也就是<strong>运行时常量池</strong>【字节码上很重要】。在讲 <a href="https://mp.weixin.qq.com/s/uMEZ2Xwctx4n-_8zvtDp5A">class 文件</a>的时候，提到了每个 class 文件都会有个常量池，用来存放字符串常量、类和接口的名字、字段名、常量等等。运行时常量池和 class 文件的常量池是一一对应的，它就是通过 class 文件中的常量池来构建的。</p><p>JDK 7 <strong>之前</strong>，运行时常量池中包含着字符串常量池，都在方法区。</p><p>JDK 7 的时候，字符串常量池从方法区中拿出来放到了堆中，运行时常量池中的其他东西还在方法区中</p></li><li><p>JDK 8 的时候，HotSpot <strong>移除了永久代</strong>，也就是说方法区不存在了，取而代之的是元空间。也就意味着<strong>字符串常量池在堆中</strong>，<strong>运行时常量池跑到了元空间</strong>。</p><p>再来说说为什么要将永久代 (PermGen) 或者说方法区替换为元空间 (MetaSpace) 。</p><p>第一，永久代放在 Java 虚拟机中，就会受到 Java 虚拟机内存大小的限制，<strong>而元空间使用的是本地内存，也就脱离了 Java 虚拟机内存的限制。</strong></p><p>第二，JDK 8 的时候，在 HotSpot 中融合了 JRockit 虚拟机，<strong>而 JRockit 中并没有永久代的概念</strong>，因此新的 HotSpot 就没有必要再开辟一块空间来作为永久代了。</p></li></ol><h3 id="Java创建对象"><a href="#Java创建对象" class="headerlink" title="Java创建对象"></a>Java创建对象</h3><p>问题：创建对象的时候，对象是在堆内存中创建的。但堆内存又分为新生代和老年代，新生代又细分为 Eden 空间、From Survivor 空间、To Survivor 空间。<strong>那我们创建的对象到底在哪里</strong>？</p><p><a href="https://tobebetterjavaer.com/jvm/whereis-the-object.html">Java 创建的对象到底放在哪？ | 二哥的Java进阶之路</a></p><p><img src="https://secure2.wostatic.cn/static/g4Tmp6tkHhSsMFaviUqmud/image.png?auth_key=1694067059-tMcx5kvXmCjJkU6RezCDC4-0-159c031a18e37cc9103f32f89208db95"></p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p><a href="https://tobebetterjavaer.com/jvm/gc.html">咱们从头到尾说一次Java垃圾回收 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p><a href="https://tobebetterjavaer.com/jvm/tujie-gc.html">图解Java的垃圾回收机制 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p><a href="https://tobebetterjavaer.com/jvm/meituan-9-gc.html">Java中9种常见的CMS GC问题分析与解决 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p>]]></content>
    
    
    <summary type="html">JVM简要总结（尚未完成）</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（秋招笔试-美团）平均数为k的最长连续子数组</title>
    <link href="http://example.com/2023/09/01/%EF%BC%88%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%A2%EF%BC%89%E5%B9%B3%E5%9D%87%E6%95%B0%E4%B8%BAk%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2023/09/01/%EF%BC%88%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%A2%EF%BC%89%E5%B9%B3%E5%9D%87%E6%95%B0%E4%B8%BAk%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-09-01T04:17:24.000Z</published>
    <updated>2023-09-07T01:02:12.885Z</updated>
    
    <content type="html"><![CDATA[<p>题的来源：</p><p><a href="https://www.nowcoder.com/questionTerminal/2e47f99735584ac5ba30d75ac14d6524?page=1&onlyReference=false">平均数为k的最长连续子数组__牛客网 (nowcoder.com)</a></p><p>【重要的参考资料：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/">560. 和为 K 的子数组 - 力扣（LeetCode）</a>】</p><p>题解：</p><p>因为题意中，有：“连续子数组”与“平均数”这两个重要条件，所以可以用上前缀和，这是因为平均数乘以k就是一个子数组的和，另外，这个题与DP无关的。另外，注意结果要用Long。</p><p>又因为数据范围过大，需要使用哈希表，防止超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> in.nextLong();</span><br><span class="line">        Map&lt;Long, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0L</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> pre + in.nextLong() - k;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(cur))&#123;</span><br><span class="line">                ans = Math.max(ans, i - hashMap.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hashMap.put(cur, i);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述没有建立前缀和数组。</p>]]></content>
    
    
    <summary type="html">前缀和与哈希的题</summary>
    
    
    
    
    <category term="刷题：前缀和" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="刷题：哈希表" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="秋招" scheme="http://example.com/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）多线程简要总结</title>
    <link href="http://example.com/2023/08/28/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/08/28/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-28T03:58:30.000Z</published>
    <updated>2023-09-07T06:01:04.766Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><ul><li><p>Syschronized是关键字，可以修饰实例方法、静态方法和代码块。</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁；</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁；</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ul><p>可以让实例方法、静态方法等变为一个临界区</p><p>Java的锁都是基于<strong>对象</strong>的。</p></li><li><p>synchronized可以保证原子性、可见性（能够替代volatile）和有序性。</p><p>而volatile只能保证可见性与有序性，不能保证原子性。</p></li><li><p>synchronized是悲观锁。</p></li><li><p>几个锁的等级排序【要回顾】</p><p>无锁&lt;偏向锁&lt;轻量级锁&lt;重量级锁</p></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ol><li><p>synchronized是悲观锁</p><p>而CAS是乐观锁</p><p><strong>悲观锁：</strong></p><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p><strong>乐观锁：</strong></p><p>乐观锁又称为“<strong>无锁</strong>”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为<strong>CAS</strong>的技术来保证<strong>线程执行的安全性</strong>。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说<strong>乐观锁天生免疫死锁</strong>。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p></li></ol><h3 id="锁总结-重要，查阅该网址"><a href="#锁总结-重要，查阅该网址" class="headerlink" title="锁总结[重要，查阅该网址]"></a>锁总结[重要，查阅该网址]</h3><p><a href="https://javabetter.cn/thread/suo.html">公司空降一个美团大佬，彻底把Java中的锁”讲清楚了 | 二哥的Java进阶之路 (javabetter.cn)</a></p><p><img src="https://secure2.wostatic.cn/static/cVT9qmnz3xTwL7aR9HPYpS/image.png?auth_key=1694066438-3YDQC8JfwDMXoryS64KkXq-0-6d773945dfe8f3d988052210c57e10b9"></p>]]></content>
    
    
    <summary type="html">多线程复习总结（简要）</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）面对对象</title>
    <link href="http://example.com/2023/08/22/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2023/08/22/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</id>
    <published>2023-08-22T05:55:12.000Z</published>
    <updated>2023-09-07T05:57:55.297Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li><p>在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被<strong>分配内存空间</strong>。每次使用 <code>new</code> 关键字创建对象的时候，构造方法至少会被调用一次。构造方法有无参构造方法与有参构造方法两种。</p><p>注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过<strong>构造方法初始化值</strong>——描写对象有哪些<strong>初始化状态</strong>。</p><p>必须得要有构造方法，这样才能让类的对象初始化为null或其他值。</p><p><strong>没有返回值，但是返回的是类的对象。</strong></p><p><strong>不仅能做初始化工作，还可以做其他工作，比如启动线程、调用其他方法等</strong>。</p></li><li><p>构造方法必须符合以下<strong>规则</strong>：</p><p>1）构造方法的名字必须和类名一样；</p><p>2）构造方法<strong>没有返回类型</strong>，包括 void，否则会当成普通方法来处理。</p><p>3）构造方法<strong>不能是抽象</strong>的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</p><p>简单解析一下最后一条规则：</p><p>1）由于构造方法<strong>不能被子类继承</strong>，所以用 final 和 abstract 关键字修饰没有意义；</p><p>2）构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；</p><p>3）多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</p></li><li><p>方法与构造方法之间的<strong>区别</strong>：</p><p><img src="https://secure2.wostatic.cn/static/srA7J9pcmRUVvGVNsTP6AZ/image.png?auth_key=1694066108-wbvoTLTecKhRTraVMeMRYt-0-11c19ff298088815d26bd98274099f63"></p></li><li><p>复制对象的方式</p><p>复制一个对象可以通过下面三种方式完成：</p><ul><li>通过构造方法</li><li>通过对象的值</li><li>通过 Object 类的 <code>clone()</code> 方法</li></ul></li></ol><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ol><li><p>补充一些关于 Java 包和类文件的知识：</p><p>1）Java 中的包主要是为了防止<strong>类文件命名冲突</strong>以及方便<strong>进行代码组织和管理</strong>；</p><p>2）对于一个 <strong>Java 源代码文件</strong>，如果存在 public 类的话，<strong>只能有一个 public 类</strong>，且此时源代码文件的名称必须和 <strong>public 类的名称完全相同</strong>。</p><p>另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。</p></li></ol>]]></content>
    
    
    <summary type="html">复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）数组与字符串</title>
    <link href="http://example.com/2023/08/21/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2023/08/21/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-08-21T01:52:34.000Z</published>
    <updated>2023-09-07T05:54:35.418Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/array/array.html">掌握Java数组：一个非常特殊的对象 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="数组的初始化方式"><a href="#数组的初始化方式" class="headerlink" title="数组的初始化方式"></a>数组的初始化方式</h3><ol><li>int[] anArray &#x3D; new int[10]; new 方式创建数组对象</li><li>int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};</li></ol><h3 id="无效的数组初始化方式"><a href="#无效的数组初始化方式" class="headerlink" title="无效的数组初始化方式"></a>无效的数组初始化方式</h3><p>以下是一些初始化数组的无效方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效，因为未提供维度</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[];</span><br><span class="line"><span class="comment">// 无效，因为未提供最左侧的维度值</span></span><br><span class="line"><span class="type">int</span>[][] aa = <span class="keyword">new</span> <span class="title class_">int</span>[][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>以下是在java中声明数组的一些其他变体，但强烈建议不要使用它们以避免混淆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] twoArrInt[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> twoIntArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br></pre></td></tr></table></figure><h3 id="String的声明（String不可变）"><a href="#String的声明（String不可变）" class="headerlink" title="String的声明（String不可变）"></a>String的声明（String不可变）</h3><ol><li>“第一，String 类是 final的，意味着它不能被子类继承。”</li><li>“第二，String 类实现了 <a href="https://javabetter.cn/io/Serializbale.html">Serializable 接口</a>，意味着它可以<a href="https://javabetter.cn/io/serialize.html">序列化</a>。”</li><li>“第三，String 类实现了 <a href="https://javabetter.cn/basic-extra-meal/comparable-omparator.html">Comparable 接口</a>，意味着最好不要用‘&#x3D;&#x3D;’来<a href="https://javabetter.cn/string/equals.html">比较两个字符串是否相等</a>，而应该用 <code>compareTo()</code> 方法去比较。”</li></ol>]]></content>
    
    
    <summary type="html">复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）Java数据类型笔记</title>
    <link href="http://example.com/2023/08/20/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/08/20/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-20T03:46:43.000Z</published>
    <updated>2023-09-07T05:51:59.095Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javabetter.cn/basic-grammar/basic-data-type.html">二哥的Java</a></p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li><p>字符字面量应该用单引号（’’）包围，而不是双引号（””），因为<a href="https://javabetter.cn/string/constant-pool.html">双引号表示字符串字面量</a></p></li><li><p>char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p><p>自动转换：</p><p>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double<br>char -&gt; int -&gt; long -&gt; float -&gt; double</p><p>强制转换：</p><p>double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</p></li><li><p>Integer.toBinaryString() 将证书转为二进制数，String类型的</p></li><li><p>字符常量</p><p>必须使用单引号</p><p>‘\n’也算是字符常量</p></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>接口不能初始化，也就是说不能使用new。</li></ol><h3 id="基本数据与引用数据之间的区别"><a href="#基本数据与引用数据之间的区别" class="headerlink" title="基本数据与引用数据之间的区别"></a>基本数据与引用数据之间的区别</h3><p>基本数据类型：</p><ul><li>1、变量名指向具体的数值。</li><li>2、基本数据类型存储在<strong>栈</strong>上。</li></ul><p>引用数据类型：</p><ul><li>1、变量名指向的是存储对象的内存地址，在栈上。</li><li>2、内存地址<strong>指向的对象</strong>存储在<strong>堆</strong>上。</li></ul><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆：</p><ul><li>是程序运行时在内存中申请的空间（可理解为动态的过程），不是在编译时。</li><li>动态申请的数据存储位置，比如数组与创建的对象（new方式）等。</li></ul><p>栈：</p><ul><li>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。</li><li>一般放的是编程语句等，对象引用也行，即：Object o这样子，作为对象的引用。</li></ul><p>一个例子：【<a href="https://blog.csdn.net/pop1586082213/article/details/118071050#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%9F%201%20new%20Phone%20%28%29%20%E6%98%AF%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E3%80%82%20%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%B0%B1%E6%98%AF%20new,3%20%E5%BD%93%E7%94%A8%E7%AD%89%E5%8F%B7%E8%B5%8B%E5%80%BC%E6%97%B6%EF%BC%8C%E6%98%AF%E5%B0%86%E5%8F%B3%E4%BE%A7%20new%20Phone%20%28%29%20%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E8%B5%8B%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%20phone%20%E3%80%82">参考</a>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>;</span><br></pre></td></tr></table></figure><p>通常会认为 phone 就是 Phone 类的对象。实际上，phone 是创建 Phone 类的<strong>对象的引用</strong>。</p><p>这个表述实际上执行的操作：</p><ol><li><strong>new Phone()</strong> 是在内存中为对象开辟空间。其实也就是 new 关键字表示在内存的 <strong>堆（heap）</strong> 上为对象<strong>开辟空间</strong>，该空间保存了对象的属性和方法。</li><li>Phone phone ：phone 指代一个 Phone 对象，被称为 <strong>对象引用</strong>。实际上，phone 并不是对象本身，而是一个<strong>类似执行对象的指针</strong>。phone 存在于<strong>内存的栈（stack）</strong> 中。</li><li>当用等号赋值时，是将右侧 new Phone() 在堆中创建对象的地址<strong>赋给</strong>对象引用 phone 。</li></ol><p>为什么要这样操作？简单来讲，有以下几种优点：</p><ol><li>栈的读取速度比堆块，但栈上存储的数据受到有效范围的限制。</li><li>一个对象引用可以赋值给另一个对象引用，此时复制的实际上是对象的地址。因此，一个对象可以由多个对象引用，减少对内存的消耗。</li></ol>]]></content>
    
    
    <summary type="html">Java复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台开发总结记录（随时间更新）</title>
    <link href="http://example.com/2023/05/07/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2023/05/07/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-05-07T02:32:25.000Z</published>
    <updated>2023-09-07T02:52:55.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li>查看是否登录时，一般会看看线程是否有这个用户（网关处理时会把数据保存到线程上）</li></ul><h2 id="MP"><a href="#MP" class="headerlink" title="MP"></a>MP</h2><ul><li>要掌握如何进行分页  <ul><li>MP在处理多个表时，有时用xml更好，尤其是在查询列表时</li></ul></li><li>项目审核上  <ul><li>一般需要一个公共的方法，外加一个code，表示审核失败和审核成功  </li><li>查询验证信息 就是查询是否对象是否存在</li></ul></li><li>进行消息传递时，如果需要传递类，可以用HashMap包装</li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><ul><li>Mono类  </li><li>拦截器 过滤器  </li><li>要加上@Component  </li><li>获取用户的方法  <ul><li>利用网关过滤器，将登录信息包装到thread，然后可以直接读取该thread的信息，得到用户的信息  </li><li>根据传过来的json信息来得到用户的信息</li></ul></li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li>AppThreadLocalUtil  </li><li>线程读取用户的id  </li><li>重要，需要认真学习</li></ul><h2 id="延迟任务-用于处理文章定时审核和上架"><a href="#延迟任务-用于处理文章定时审核和上架" class="headerlink" title="延迟任务 用于处理文章定时审核和上架"></a>延迟任务 用于处理文章定时审核和上架</h2><ul><li>延迟任务的实现  <ul><li>用的是Redis的延迟队列，其中有2个队列，当前队列和未来队列  </li><li>需要用上乐观锁  </li><li>也可以用RabbitMQ</li></ul></li><li>分布式锁的解决方案（<strong>因为@Schedule存在做集群任务的重复执行问题，后续的xxl-job任务可以解决</strong>）  <ul><li>SETNX 用的是StringRedisTemplate</li></ul></li><li>定时刷新  <ul><li>未来任务定时刷新到当前任务  <ul><li>是在redis上的处理，就是先清楚掉未来任务的数据（zset），然后将这个数据加入到当前队列（list）</li></ul></li><li>数据库定时刷新到redis（即数据库定时同步到redis）  <ul><li>要先清理缓存中的数据，然后从数据库中查询符合条件的数据，并加入到redis</li></ul></li></ul></li><li>GetMapping 和 PostMapping的区别是GetMapping上的连接必须有占位符，即{}，并且参数要有@PathVariable。这个与Http的Get请求特点有关的。  </li><li>延迟任务上，使用的序列化方法是Protostuff，特点是比Jdk的序列化方法快  </li><li>延迟任务上，会使用到的@Scheduled注解，里面用上2个参数  <ul><li>cron  </li><li>fixedRate  </li><li>然后会用上EnableScheduling注解，用于开启调度任务</li></ul></li><li>在文章审核上，需要使用@Asyns实现异步调用，保证文章微服务挂掉时，不影响文章的审核（自媒体的微服务部分）  </li><li>区分延迟任务和定时任务</li></ul><h2 id="Kafka-用于通知文章上下架"><a href="#Kafka-用于通知文章上下架" class="headerlink" title="Kafka 用于通知文章上下架"></a>Kafka 用于通知文章上下架</h2><ul><li>自媒体文章上下架  <ul><li>自媒体微服务如何通知文章微服务？？  <ul><li>Feign远程调用 有耦合性  </li><li>消息队列 RabbitMQ Kafka 系统解耦 流量削峰  </li><li>KafkaProducer 创建Kafka对象</li></ul></li></ul></li><li>Kafka入门  <ul><li>程序设置  生产者和消费者<ul><li>写程序时需要先用Properties创建配置类（<strong>也可以写入yml配置文件</strong>），里面保存连接信息，key和value的序列化或反序列化，另外消费者还需要添加消费者组，其使用的重要参数有：1. 连接信息。2. key和value的序列化或反序列化。3. ack 消息确认机制 开发中不会专门去设置 默认 ack&#x3D;1。4. retries 尝试重试次数 一般设置10次。5. 消息压缩 snappy</li><li>创建生产者对象或消费者对象 传入配置类</li><li>发送消息或订阅主题并拉取消息</li><li>生产者还需要关闭消息通道</li></ul></li><li>消费者组  <ul><li>一对一接收 同一个消费者组有多个消费者就行 （Topic中的一个消费者组的消息只能由一个消费者消费，这也保证消息的有序性）  </li><li>而一对多时，只需要将不同的消费者放在不同的消费组就行  </li><li>消费组的设置：ConsumerConfig类</li></ul></li><li>Kafka的分区设计和高可用设计 这一块需要查阅资料  </li><li>Kafka的生产者上，有同步和异步发送消息  </li><li>Kafka的参数配置  </li><li>Kafka的消息有序性 （按顺序处理Topic的所有消息，就只提供一个分区）  </li><li>偏移量 提交方式： 同步与异步组合方式提交  </li><li>SpringBoot结合Kafka  <ul><li>用yml写入kafka的一些配置  </li><li>用KafkaTemplate（发送信息）  </li><li>注解接收信息 @KafkaListener  </li><li>序列化处理，使用JSON方法，发送消息时，将对象转为JSON字符串，然后接收消息时，将JSON字符串转化为对象</li></ul></li></ul></li></ul><h2 id="ElasticSearch-搜索总结"><a href="#ElasticSearch-搜索总结" class="headerlink" title="ElasticSearch 搜索总结"></a>ElasticSearch 搜索总结</h2><ul><li>ElasticSearch  <ul><li>数据库批量导入ES  <ul><li>RestHighLevelClient  </li><li>要复习ES  </li><li>SearchRequest  <ul><li>QueryBuilders  </li><li>SearchSourceBuilders</li></ul></li><li>IndexRequest</li></ul></li><li>保存搜索记录  <ul><li>用mongodb数据库  </li><li>mongoTemplate  <ul><li>save  </li><li>findById  </li><li>find  </li><li>remove</li></ul></li><li>Query(与Criteria搭配使用，用于组合查询或排序)  <ul><li>query</li></ul></li><li>更新时间方式  <ul><li>用new Date()就行</li></ul></li><li>Sort</li></ul></li><li>联想词查询  <ul><li>实际上是模糊查询</li></ul></li></ul></li></ul><h2 id="关注、取消、点赞等CRUD处理"><a href="#关注、取消、点赞等CRUD处理" class="headerlink" title="关注、取消、点赞等CRUD处理"></a>关注、取消、点赞等CRUD处理</h2><ul><li>关注与取消关注  <ul><li>添加到Redis，使用zset</li></ul></li><li>点赞  <ul><li>因为点赞只能点赞一次，所以要判断是否点赞，此时可以用哈希表</li></ul></li><li>阅读  <ul><li>要更新登录次数  </li><li>用哈希表</li></ul></li><li>不喜欢  <ul><li>根据交流可知，似乎这个与点赞是区分的，都可以点击，也算是不足之处吧  </li><li>用哈希表</li></ul></li><li>收藏  <ul><li>要判断是否已经收藏 只能收藏一次</li></ul></li><li>每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！</li></ul><h2 id="定时任务热点文章计算（问题很大）"><a href="#定时任务热点文章计算（问题很大）" class="headerlink" title="定时任务热点文章计算（问题很大）"></a>定时任务热点文章计算（问题很大）</h2><ul><li>定时任务框架（xxl-job也许主流？？？？ 分布式消息队列？？？？）  <ul><li>定时任务框架-xxl-job 分布式任务调度框架  </li><li>可以解决的问题：  <ul><li>做集群任务的重复执行问题  </li><li>cron表达式定义在代码中，修改不方便  </li><li>定时任务失败，无法重试也没有统计  </li><li>如果任务量过大，不能有效分片执行</li></ul></li></ul></li></ul><h2 id="实时任务-热点文章计算"><a href="#实时任务-热点文章计算" class="headerlink" title="实时任务 热点文章计算"></a>实时任务 热点文章计算</h2><ul><li>SerDe是Serializer&#x2F;Deserializer的缩写。 Serdes.String().getClass() 实际上是得到一个序列化器  </li><li>Topology类 这个可能要注意  </li><li>重要的对象 KStream 键值类型的  </li><li>Duration.ofSeconds  <ul><li>KakfaStream 的flatMapValues方法：<br>在Kafka中，<code>flatMapValues</code>是一个操作符（operator），用于对每个记录的值进行扁平化处理（<strong>就是对一个数据流的数据进行分开处理</strong>），<br>并生成零个或多个新的记录。<code>flatMapValues</code>操作符的功能类似于<code>flatMap</code>操作符，但它只应用于记录的值部分，而不改变键部分。</li></ul></li><li>Kafka的流式处理模块是单独的，需要生产者的topic和消费者的topic  </li><li>需要自己添加配置类，因为SpringBoot对kafkaStream的yml集成效果不太好  <ul><li>需要学习的注解  </li><li>@ConfigurationProperties  </li><li>@Bean  </li><li>@Value</li></ul></li><li>所谓热点文章，就是同时考虑点赞行为和阅读行为，对文章的分值进行计算，要实时的，这个可以用KafkaStream完成的。  </li><li><strong>enum 枚举类或集合方法的撰写 必须要学会</strong>  </li><li><strong>常量类上的方法使用 static 和 final</strong>  </li><li>String.format()</li></ul><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ul><li>mongodb处理 <ul><li>分页列表并不像MP那样有插件，需要自己实现  </li><li>涉及到MongoDB的数据操作，是没有mapper的，因为mongoTemplate里面有数据操作的方法</li></ul></li></ul>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台开发的注意事项简要记录</title>
    <link href="http://example.com/2023/04/23/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/04/23/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-23T03:30:58.000Z</published>
    <updated>2023-09-07T03:35:45.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nacos配置问题"><a href="#nacos配置问题" class="headerlink" title="nacos配置问题"></a>nacos配置问题</h4><p>每次正确添加nacos配置后，如果碰上某个微服务的错误，此时要考虑是不是不小心加上了无关的依赖库，尤其是okhttp 。</p><h4 id="延迟队列问题"><a href="#延迟队列问题" class="headerlink" title="延迟队列问题"></a>延迟队列问题</h4><p>延迟队列  </p><ul><li><p>延迟队列上，判断数据是否到期，就是和当前时间进行比较，用的是System.currentTimeMillis() 。</p></li><li><p>如何将Redis的未来队列的数据同步到list  </p><ul><li><p>从zset中查出数据，并删除  </p></li><li><p>把数据存入到list  </p></li><li><p>用管道方式更快</p></li></ul></li></ul><h4 id="拦截器问题"><a href="#拦截器问题" class="headerlink" title="拦截器问题"></a>拦截器问题</h4><p>每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！  </p><h4 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h4><p>部分程序存在 ，存在Claims类（自己编写失误）将未登录的用户的id默认为0的情况，此时需要在此处加个判断，将未登录用户不能直接登录。</p>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台使用的技术简要总结_杂记（随时间更新）</title>
    <link href="http://example.com/2023/04/01/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93-%E6%9D%82%E8%AE%B0%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2023/04/01/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93-%E6%9D%82%E8%AE%B0%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-04-01T12:50:20.000Z</published>
    <updated>2023-09-07T02:30:48.607Z</updated>
    
    <content type="html"><![CDATA[<p>JSON 阿里巴巴的fastjson  </p><p>StringUtils  </p><ul><li><p>不同的包也有不同的方法  </p></li><li><p>isNotBlank 和 isEmpty也是不同的方法</p></li></ul><p>BeansUtils springframework的  </p><p>@RequestBody  </p><p>Arrays类，比如asList  </p><p>IDEA快捷键，比如Ctrl+SHIFT+t 可以构建测试类  </p><p>DFA算法，雪花算法 DFA有点像前缀树  </p><p>spring.factories 作用探讨  </p><p>Tess4j 图片识别 把图片的文字提出来，然后识别文字是否存在问题  </p><p>同步 异步 @Aynsn  </p><p>Freemarker Template Configuration  </p><p>StringWriter  </p><p>apArticleService.update(Wrappers.<ApArticle>lambdaUpdate().eq(ApArticle::getId,apArticle.getId()).set(ApArticle::getStaticUrl,path)); set用法  </p><p>乐观锁 悲观锁  </p><ul><li><p>乐观锁： 每次拿数据的时候都认为别人不会修改，所以不上锁，但是每次更新时会判断之前被人是否改过，用版本号机制等判断  </p><p>用@Version 标明是版本号，用乐观锁  </p><p>MP对乐观锁有支持，只需要加个拦截器配置，分页机制也是  </p></li><li><p>悲观锁：而悲观锁则是每次拿数据时都认为别人会修改，所以每次拿数据都会上锁</p></li></ul><p>StringRedisTemplate StringRedisConnection  </p><ul><li><p>Scan方法  </p></li><li><p>分布式锁 Setnx</p></li></ul><p>Calendar Date 日期类  </p><p>getTime()  </p><p>测试类  </p><ul><li>@SpringBootTest(classes &#x3D; ScheduleApplication.class)<br>@RunWith(SpringRunner.class)</li></ul><p>@Schedule  </p><p>@PostConstruct 有初始化的方法  </p><p>@PathVariable 占位符  </p><p>Feign（重点！！！！！）  </p><p>枚举类的撰写  </p><p>Protostuff序列化  </p><p>@Scheduled @EnableScheduling  </p><p>MP如何更新数据  </p><p>DigestUtils  </p><p>定时任务框架-xxljob</p>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）注解总结之@RequestBody</title>
    <link href="http://example.com/2023/03/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93%E4%B9%8B-RequestBody/"/>
    <id>http://example.com/2023/03/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93%E4%B9%8B-RequestBody/</id>
    <published>2023-03-10T03:28:20.000Z</published>
    <updated>2023-09-07T03:30:04.344Z</updated>
    
    <content type="html"><![CDATA[<p><code>@RequestBody</code> 是一个Spring框架中的注解，用于将HTTP请求的内容（例如JSON、XML等）绑定到方法的参数上。它通常与Spring MVC或Spring Boot中的控制器方法一起使用。  </p><p>使用<code>@RequestBody</code>注解时，Spring框架会自动将请求体的内容解析，并尝试将其转换为指定的参数类型。  </p><p>以下是<code>@RequestBody</code>的示例用法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span>  </span><br><span class="line">        <span class="keyword">public</span> ResponseEntity&lt;?&gt; createUser(<span class="meta">@RequestBody</span> User user) &#123;  </span><br><span class="line">        <span class="comment">// 处理请求，使用接收到的User对象  </span></span><br><span class="line">        <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().build();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>createUser()</code>方法使用<code>@RequestBody</code>注解来接收HTTP POST请求中的请求体，并将其转换为User对象。Spring框架会根据请求的内容类型（例如JSON）以及User类的定义，自动完成请求体到User对象的转换。  </p><p>需要注意的是，在使用<code>@RequestBody</code>时，通常还需要指定请求的Content-Type。例如，如果请求的Content-Type是application&#x2F;json，则Spring会使用相应的JSON转换器将JSON字符串转换为User对象。  </p><p>另外，<code>@RequestBody</code>注解还支持其他参数类型，如<code>Map&lt;String, Object&gt;</code>、<code>List&lt;User&gt;</code>等，以及自定义的数据转换器和处理器。  </p><p>总之，<code>@RequestBody</code>注解允许将HTTP请求的内容转换为方法参数，并方便地在Spring框架中处理和使用请求体数据。</p>]]></content>
    
    
    <summary type="html">对@RequestBody的总结</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="注解与反射" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台数据库开发记录总结</title>
    <link href="http://example.com/2023/02/21/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/02/21/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-21T07:42:36.000Z</published>
    <updated>2023-09-07T02:03:38.586Z</updated>
    
    <content type="html"><![CDATA[<p>添加到数据库时  </p><ul><li>如果是Mapper，一般是用insert方法或save方法  </li><li>而用这些方法前，一般会设置dto类，并创建dto方法，然后用BeansUtils将传输过来的类拷贝到这个dto类，但是dto类依然有些属性是空着，要自己从其他地方添加。</li></ul>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记简要复习总结</title>
    <link href="http://example.com/2023/01/11/MySQL%E7%AC%94%E8%AE%B0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/01/11/MySQL%E7%AC%94%E8%AE%B0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-11T11:38:03.000Z</published>
    <updated>2023-09-07T01:43:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>阅读来源：<a href="https://javaguide.cn/database/sql/sql-syntax-summary.html">SQL语法基础知识总结 | JavaGuide(Java面试 + 学习指南)</a></p><h2 id="select聚类"><a href="#select聚类" class="headerlink" title="select聚类"></a>select聚类</h2><p>    select 语句中，如果没有 <code>GROUP BY</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity * item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity * item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p><blockquote><p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p></blockquote><h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><p><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</p><p>知识点：</p><ul><li>逗号作用是用来隔开列与列之间的。</li><li>ORDER BY 是有 BY 的，需要撰写完整，且位置正确</li><li>知识点：<code>DISTINCT</code> 用于返回列中的唯一不同值、</li><li>注意limit的使用，这个作用筛选某些值，比如筛选前面的几个值</li></ul><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>WHERE</code> 可以过滤返回的数据。</p><p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。 <strong>注释：</strong> 在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p><p>在 SQL 中，可使用以下通配符：</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>%</code></td><td>代表零个或多个字符</td></tr><tr><td><code>_</code></td><td>仅替代一个字符</td></tr><tr><td><code>[charlist]</code></td><td>字符列中的任何单一字符</td></tr><tr><td><code>[^charlist]</code> 或者 <code>[!charlist]</code></td><td>不在字符列中的任何单一字符</td></tr></tbody></table><h2 id="使用函数处理数据"><a href="#使用函数处理数据" class="headerlink" title="使用函数处理数据"></a>使用函数处理数据</h2><p>知识点：</p><ul><li><p>截取函数<code>SUBSTRING()</code>：截取字符串，<code>substring(str ,n ,m)</code>（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；</p></li><li><p>拼接函数<code>CONCAT()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。</p></li><li><p>大写函数 <code>UPPER()</code>：将指定字符串转换为大写。</p></li></ul><p>知识点：</p><ul><li>日期格式：<code>YYYY-MM-DD</code></li><li>时间格式：<code>HH:MM:SS</code></li></ul><p>日期和时间处理相关的常用函数：</p><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>ADDDATE()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>ADDTIME()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CURDATE()</code></td><td>返回当前日期</td></tr><tr><td><code>CURTIME()</code></td><td>返回当前时间</td></tr><tr><td><code>DATE()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DATEDIFF</code></td><td>计算两个日期之差</td></tr><tr><td><code>DATE_FORMAT()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>DAY()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DAYOFWEEK()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>HOUR()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>MINUTE()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>MONTH()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>NOW()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>SECOND()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>TIME()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>YEAR()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>汇总数据相关的函数：</p><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><code>GROUP BY</code>：</p><ul><li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li><li><code>GROUP BY</code> 为每个组返回一个记录。</li><li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li><li><code>GROUP BY</code> 可以按一列或多列进行分组。</li><li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li></ul><p><code>HAVING</code>：</p><ul><li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li><li><code>HAVING</code> 必须要与 <code>GROUP BY</code> 连用。</li><li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li></ul><p><code>HAVING</code> vs <code>WHERE</code>：</p><ul><li><code>WHERE</code>：过滤指定的行，后面不能加聚合函数（分组函数）。</li><li><code>HAVING</code>：过滤分组，必须要与 <code>GROUP BY</code> 连用，不能单独使用。</li></ul><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p><p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li><li><strong>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</strong></li><li>from</li></ul><blockquote><p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name [, column_name ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">WHERE column_name operator</span><br><span class="line">(SELECT column_name [, column_name ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">[WHERE])</span><br></pre></td></tr></table></figure><ul><li>子查询需要放在括号<code>( )</code>内。</li><li><code>operator</code> 表示用于 <code>WHERE</code> 子句的运算符，可以是比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code> 等）或逻辑运算符（如 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code>, <code>NOT EXISTS</code> 等），具体根据需求来确定。</li></ul><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name [, column_name ]</span><br><span class="line">FROM (SELECT column_name [, column_name ]</span><br><span class="line">      FROM table1 [, table2 ]</span><br><span class="line">      [WHERE]) AS temp_table_name [, ...]</span><br><span class="line">[JOIN type JOIN table_name ON condition]</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><ul><li>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</li><li>子查询需要放在括号 <code>( )</code> 内。</li><li>可以指定多个临时表名，并使用 <code>JOIN</code> 语句连接这些表</li></ul><h2 id="连接表"><a href="#连接表" class="headerlink" title="连接表"></a>连接表</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">JOIN table2</span><br><span class="line">ON table1.common_column1 = table2.common_column2;</span><br></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p><p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># join....on</span><br><span class="line">SELECT c.cust_name, o.order_num</span><br><span class="line">FROM Customers c</span><br><span class="line">INNER JOIN Orders o</span><br><span class="line">ON c.cust_id = o.cust_id</span><br><span class="line">ORDER BY c.cust_name</span><br><span class="line"></span><br><span class="line"># 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....USING()</span><br><span class="line">SELECT c.cust_name, o.order_num</span><br><span class="line">FROM Customers c</span><br><span class="line">INNER JOIN Orders o</span><br><span class="line">USING(cust_id)</span><br><span class="line">ORDER BY c.cust_name</span><br></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td>INNER JOIN 内连接</td><td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td></tr><tr><td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td><td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td></tr><tr><td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td><td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td></tr><tr><td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td><td>只要其中有一个表存在满足条件的记录，就返回行。</td></tr><tr><td>SELF JOIN</td><td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td>CROSS JOIN</td><td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li></ul><p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column_name(s) FROM table2;</span><br></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code>：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后 或者直接使用or做</p><p>在组合查询上，union的作用和or类似</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增 ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户 ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷 ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>分数</td></tr></tbody></table><p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;</p><p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p><ul><li><code>DROP</code>: 清空表，删除表结构，不可逆</li><li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li><li><code>DELETE</code>：删除数据，可逆</li></ul><p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p><p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p><p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>]]></content>
    
    
    <summary type="html">JavaGuide的MySQL笔记复习总结</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
