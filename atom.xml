<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuweixu</title>
  
  <subtitle>liuweixu个人博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-24T02:54:16.497Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liuweixu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-排序算法-插入排序</title>
    <link href="http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-16T02:50:12.000Z</published>
    <updated>2023-09-24T02:54:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>注意要和选择排序区分<br>插入排序的要点：【插入】  </p><ol><li>将数组分为两部分[0…low-1][low…a.length -1]<br>左边是已排序的部分<br>右边是未排序的部分  </li><li>每次从未排序区域取出low位置的元素，插入到已排序的区域。</li><li>有递归版本和非递归版本，下面使用的是非递归版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意和选择排序区分</span></span><br><span class="line"><span class="comment">插入排序的要点：【插入】</span></span><br><span class="line"><span class="comment">1. 将数组分为两部分[0...low-1][low...a.length -1]</span></span><br><span class="line"><span class="comment">    左边是已排序的部分</span></span><br><span class="line"><span class="comment">    右边是未排序的部分</span></span><br><span class="line"><span class="comment">2. 每次从未排序区域取出low位置的元素，插入到已排序的区域。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    非递归版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>; low &lt; a.length; low++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//自右向左找插入位置，如果比待插入元素大，则不断右移，空出插入位置</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i])&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != low - <span class="number">1</span>)&#123;</span><br><span class="line">                a[i+<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        insertion(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">插入排序</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序算法-堆排序</title>
    <link href="http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-16T01:29:56.000Z</published>
    <updated>2023-09-24T02:54:48.187Z</updated>
    
    <content type="html"><![CDATA[<p>在掌握堆排序前需要先理解堆的数据结构：</p><ul><li><p>堆是一个完全二叉树。</p></li><li><p>在构建堆时，需要重点掌握下潜算法、上浮算法和建堆。</p></li><li><p>以大顶堆为例，下潜算法指的是如果所在的节点的数值比左右子节点要小，就需要交换，此时可以使用递归方法。</p></li><li><p>还是以大顶堆为例，上浮算法指的是如果所在的节点的值比其父节点的值要大，就要逐步交换，可以使用while函数</p></li><li><p>如果要从小到大的排序，则需要使用大顶堆</p><ul><li><p>建立大顶堆</p></li><li><p>每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让其重新符合大顶堆的特性，并逐步缩减，直至堆的元素数量为1为止。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        heapify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    建堆 Floyd建堆方法， 时间复杂度O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            down(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下潜</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; size &amp;&amp; array[max] &lt; array[left])&#123;</span><br><span class="line">            max = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; size &amp;&amp; array[max] &lt; array[right])&#123;</span><br><span class="line">            max = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max != parent)&#123;</span><br><span class="line">            swap(max, parent);</span><br><span class="line">            down(max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取堆顶函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    删除指定索引处的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    替换堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == array.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    上浮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span>(child &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(offered &gt; array[parent])&#123;</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            child = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">Heap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(array);</span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(heap.size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            heap.swap(<span class="number">0</span>, heap.size - <span class="number">1</span>);</span><br><span class="line">            heap.size--;</span><br><span class="line">            heap.down(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public class Heap &#123;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">堆排序复习</summary>
    
    
    
    
    <category term="刷题" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）JVM简要总结</title>
    <link href="http://example.com/2023/09/02/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89JVM%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/09/02/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89JVM%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-09-02T06:01:29.000Z</published>
    <updated>2023-09-07T06:11:11.598Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><h4 id="字节码-1"><a href="#字节码-1" class="headerlink" title="字节码"></a>字节码</h4><ol><li><p>Java分为编译时与运行时，而字节码与编译时有关。</p></li><li><p><strong>类加载机制</strong>与字节码密切相关。</p></li><li><p>IDEA 默认会用 Fernflower 反编译工具将<strong>字节码文件（后缀为 .class 的文件，也就是 Java 源代码编译后的文件）</strong>反编译为我们可以看得懂的 Java 源代码。</p></li><li><p>在编译阶段，Java会将Java源代码文件编译为字节码文件。在这个阶段，编译器会进行一些检查工作，比如说，某个关键字是不是写错了，语法上是不是符合预期了，不能有很明显的错误，否则带到运行时再检查出来就会比较麻烦了。</p></li><li><p>Java 字节码是沟通 JVM 与 Java 代码的桥梁，可以用javap查看。</p></li><li><p>Java虚拟机采用基于栈的架构，其指令由操作码与操作数组成。</p><p>0xb2 getstatic 获取静态字段的值<br>0x12 ldc 常量池中的常量值入栈<br>0xb6 invokevirtual 运行时方法绑定调用方法<br>0xb1 return void 函数返回</p></li><li><p>JVM会在<strong>准备阶段</strong>对类变量（静态变量， static修饰）<strong>分配内存并初始化</strong>（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p><p>也就是说，假如有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">chenmo</span> <span class="operator">=</span> <span class="string">&quot;沉默&quot;</span>; <span class="comment">//会查看常量池是否存在，只创建一个对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="string">&quot;王二&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">cmower</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br></pre></td></tr></table></figure><p>chenmo 不会被分配内存，而 wanger 会；但 wanger 的初始值不是“王二”而是 <code>null</code>。</p><p>需要注意的是，<code>static final</code> 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 cmower 在准备阶段的值为“沉默王二”而不是 <code>null</code>。</p></li></ol><h4 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h4><p><a href="https://tobebetterjavaer.com/jvm/class-file-jiegou.html">详解Java的类文件（class文件）结构 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><ul><li>使用xxd命令后，得到16进制内容，其中如果开头有cafe base这个魔数，说明这个class文件可以被JVM接受。</li></ul><p>上面往后抽空看。</p><h4 id="Javap与字节码"><a href="#Javap与字节码" class="headerlink" title="Javap与字节码"></a>Javap与字节码</h4><p><a href="https://tobebetterjavaer.com/jvm/bytecode.html">从javap的角度轻松看懂字节码 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p>上面抽空看</p><ol><li><p>Java 内置了一个反编译命令 javap，可以通过 <code>javap -help</code> 了解 javap 的基本用法</p></li><li><p>常量池</p><p>Constant pool，也就是字节码文件最重要的常量池部分。可以把常量池理解为<strong>字节码文件中的资源仓库，主要存放两大类信息。</strong></p><p>1）<strong>字面量</strong>（Literal），有点类似 Java 中的常量概念，比如文本字符串，final 常量等。</p><p>2）<strong>符号引用</strong>（Symbolic References），属于编译原理方面的概念，包括 3 种：</p><ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ul><p>Java 虚拟机是在加载字节码文件的时候才进行的动态链接，也就是说，字段和方法的符号引用只有经过<strong>运行期转换后才能获得真正的内存地址</strong>。当 <strong>Java 虚拟机运行</strong>时，需要从常量池获取对应的符号引用，然后在类创建或者运行时解析并翻译到具体的内存地址上。</p></li></ol><h4 id="JVM字节码详情"><a href="#JVM字节码详情" class="headerlink" title="JVM字节码详情"></a>JVM字节码详情</h4><h4 id="虚拟机-字节码"><a href="#虚拟机-字节码" class="headerlink" title="虚拟机 字节码"></a>虚拟机 字节码</h4><h4 id="HSDB"><a href="#HSDB" class="headerlink" title="HSDB"></a>HSDB</h4><h4 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h4><p><a href="https://tobebetterjavaer.com/jvm/asm.html">史上最通俗易懂的ASM教程 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p>前面有讲基础内容。</p><h4 id="自己编译JDK"><a href="#自己编译JDK" class="headerlink" title="自己编译JDK"></a>自己编译JDK</h4><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h4 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h4><ol><li><p>类<strong>加载</strong>过程</p><p>Loading</p><p>Verification</p><p>Preparation【编译时阶段】</p><p>Resolution【运行时阶段】</p><ul><li><p>该阶段将常量池中的<strong>符号引用</strong>转化为<strong>直接引用</strong>。</p><p><strong>符号引用</strong>以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。（<strong>就是不知道内存地址，先暂时用它的名字，也就是符号</strong>）</p><p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 <code>com.Wanger</code> 类引用了 <code>com.Chenmo</code> 类，编译时 Wanger 类并不知道 Chenmo 类的实际内存地址，因此只能使用符号 <code>com.Chenmo</code>。</p><p><strong>直接引用</strong>通过对<strong>符号引用进行解析</strong>，找到引用的实际内存地址。</p></li></ul><p>Initialization</p><ul><li>该阶段是类加载过程的最后一步。<strong>在准备阶段，类变量已经被赋过默认初始值</strong>，而在初始化阶段【运行时阶段】，类变量将<strong>被赋值为代码期望赋的值</strong>。换句话说，初始化阶段是执行<strong>类构造器方法</strong>的过程。</li></ul></li><li><p>类加载器</p><p>Java 类加载器可以分为三种。<strong>【黑马八股文有讲】</strong></p><p>注意：这个三种是JDK8之前的情况，JDK9有改动。</p><p>1）启动类（或者说引导类）加载器（Bootstrap Class-Loader），加载 <code>jre/lib</code> 包下面的 jar 文件，比如说常见的 rt.jar，通常以null表示。</p><p>2）扩展类加载器（Extension or Ext Class-Loader），加载 <code>jre/lib/ext</code> 包下面的 jar 文件，它的父类加载器为引导类加载器。</p><p>3）应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。它的父类加载器为扩展类加载器。</p><p>JDK9的改动：</p><p>Java 9仍然保留了三层类加载器结构，<strong>不过为了支持模块系统</strong>，对它们做了一些调整。扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为<strong>平台类加载器（platform class loader）</strong>。可以通过<code>ClassLoader</code>的新方法<code>getPlatformClassLoader()</code>来获取。Java 9中的内置类加载器如下所示。</p><ul><li><p>引导类加载器：定义<strong>核心</strong>Java SE和JDK模块。</p></li><li><p>平台类加载器：定义<strong>部分</strong>Java SE和JDK模块。</p></li><li><p>应用或系统类加载器：定义<strong>CLASSPATH上的类和模块路径中的模块</strong>。</p></li></ul><p><strong>关键程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```Java</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderMain.class.getClassLoader();</span><br><span class="line"><span class="keyword">while</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">  System.out.println(classLoader);</span><br><span class="line">  classLoader = classLoader.getParent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre></li><li><p>双亲委派模型</p><p>如果以上三种类加载器不能满足要求的话，程序员还可以自定义类加载器（继承 <code>java.lang.ClassLoader</code> 类），它们之间的层级关系如下图所示。</p><p>【图片见<a href="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/jvm/class-load-02.png%E3%80%91">https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/jvm/class-load-02.png】</a></p><p>自定义类加载器的父类是应用类加载器（JDK8前）</p><p>这种层次关系被称作为<strong>双亲委派模型</strong>：如果一个类加载器收到了加载类的请求，它会<strong>先把请求委托给上层加载器去完成</strong>，上层加载器<strong>又会委托</strong>上上层加载器，一直到最顶层的类加载器；如果上层加载器<strong>无法完成类的加载工作时</strong>，当前类加载器才会尝试自己去加载这个类。</p><p>使用双亲委派模型有一个很明显的好处，那就是 Java 类随着它的类加载器一起具备了<strong>一种带有优先级的层次关系</strong>，这对于保证 Java 程序的稳定运作很重要。</p><p>上文中曾提到，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，<strong>那这两个类就必定不相等</strong>——双亲委派模型能够保证同一个类最终会被特定的类加载器加载。</p></li></ol><h2 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ol><li><p>程序计数器（Program Counter Register）所占的内存空间不大，很小一块，可以看作是当前线程所执行的字节码指令的行号指示器。字节码解释器会在工作的时候改变这个计数器的值来选取下一条需要执行的字节码指令，像分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p></li><li><p>在 JVM 中，多线程是通过线程轮流切换来获得 CPU 执行时间的，因此，在任一具体时刻，一个 CPU 的内核只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，并且不能互相干扰，否则就会影响到程序的正常执行次序。</p><p>也就是说，我们要求程序计数器是<strong>线程私有</strong>的。</p></li><li><p>《Java 虚拟机规范》中规定，如果线程执行的是非本地（native）方法，则程序计数器中保存的是当前需要执行的指令地址；如果线程执行的是本地方法，则程序计数器中的值是 undefined。</p><p>为什么本地方法在程序计数器中的值是 undefined 的？因为本地方法大多是通过 C&#x2F;C++ 实现的，并未编译成需要执行的字节码指令。</p><p>由于程序计数器中存储的数据所占的空间不会随程序的执行而发生大小上的改变，因此，程序计数器是不会发生内存溢出现象（OutOfMemory）的。</p></li></ol><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><a href="https://tobebetterjavaer.com/jvm/how-jvm-run-zijiema-zhiling.html">Java虚拟机是如何执行字节码指令的？ | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ol><li>所有线程共享的一块内存区域。在 <strong>Java 虚拟机启动的时候创建</strong>，用来存储<strong>对象</strong>（数组也是一种对象，new创建）。</li><li>以前，Java 中“几乎”所有的对象都会在堆中分配，但随着 JIT（Just-In-Time）编译器的发展和逃逸技术的逐渐成熟，所有的对象都分配到堆上渐渐变得不那么“绝对”了。<strong>从 JDK 7 开始，Java 虚拟机已经默认开启逃逸分析了</strong>，意味着如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</li><li>堆是 Java 垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度来看，由于垃圾收集器基本都采用了分代垃圾收集的算法，所以堆还可以细分为：<strong>新生代和老年代</strong>。新生代还可以细分为：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是<strong>更好地回收内存，或者更快地分配内存。</strong></li><li>堆这最容易出现的就是 OutOfMemoryError 错误，分为以下几种表现形式：<ul><li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>：当JVM花费太多时间执行垃圾回收并且只能回收很少的堆空间时，会发生这个错误的，就是堆空间爆满。</li><li><code>java.lang.OutOfMemoryError: Java heap space</code>：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发该错误。和本机的物理内存无关，和我们配置的虚拟机内存大小有关！</li></ul></li></ol><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p><a href="https://tobebetterjavaer.com/jvm/neicun-jiegou.html#_05%E3%80%81%E5%85%83%E7%A9%BA%E9%97%B4">https://tobebetterjavaer.com/jvm/neicun-jiegou.html#_05、元空间</a></p><ol><li><p>JDK8后，元空间取代方法区（或者说永久代），方法区和堆一样，是线程共享的区域，它用来存储已经被 <strong>Java 虚拟机加载的类信息、常量、静态变量，以及编译后的代码</strong>等。</p></li><li><p>在方法区中，还有一块非常重要的部分，也就是<strong>运行时常量池</strong>【字节码上很重要】。在讲 <a href="https://mp.weixin.qq.com/s/uMEZ2Xwctx4n-_8zvtDp5A">class 文件</a>的时候，提到了每个 class 文件都会有个常量池，用来存放字符串常量、类和接口的名字、字段名、常量等等。运行时常量池和 class 文件的常量池是一一对应的，它就是通过 class 文件中的常量池来构建的。</p><p>JDK 7 <strong>之前</strong>，运行时常量池中包含着字符串常量池，都在方法区。</p><p>JDK 7 的时候，字符串常量池从方法区中拿出来放到了堆中，运行时常量池中的其他东西还在方法区中</p></li><li><p>JDK 8 的时候，HotSpot <strong>移除了永久代</strong>，也就是说方法区不存在了，取而代之的是元空间。也就意味着<strong>字符串常量池在堆中</strong>，<strong>运行时常量池跑到了元空间</strong>。</p><p>再来说说为什么要将永久代 (PermGen) 或者说方法区替换为元空间 (MetaSpace) 。</p><p>第一，永久代放在 Java 虚拟机中，就会受到 Java 虚拟机内存大小的限制，<strong>而元空间使用的是本地内存，也就脱离了 Java 虚拟机内存的限制。</strong></p><p>第二，JDK 8 的时候，在 HotSpot 中融合了 JRockit 虚拟机，<strong>而 JRockit 中并没有永久代的概念</strong>，因此新的 HotSpot 就没有必要再开辟一块空间来作为永久代了。</p></li></ol><h3 id="Java创建对象"><a href="#Java创建对象" class="headerlink" title="Java创建对象"></a>Java创建对象</h3><p>问题：创建对象的时候，对象是在堆内存中创建的。但堆内存又分为新生代和老年代，新生代又细分为 Eden 空间、From Survivor 空间、To Survivor 空间。<strong>那我们创建的对象到底在哪里</strong>？</p><p><a href="https://tobebetterjavaer.com/jvm/whereis-the-object.html">Java 创建的对象到底放在哪？ | 二哥的Java进阶之路</a></p><p><img src="https://secure2.wostatic.cn/static/g4Tmp6tkHhSsMFaviUqmud/image.png?auth_key=1694067059-tMcx5kvXmCjJkU6RezCDC4-0-159c031a18e37cc9103f32f89208db95"></p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p><a href="https://tobebetterjavaer.com/jvm/gc.html">咱们从头到尾说一次Java垃圾回收 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p><a href="https://tobebetterjavaer.com/jvm/tujie-gc.html">图解Java的垃圾回收机制 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p><p><a href="https://tobebetterjavaer.com/jvm/meituan-9-gc.html">Java中9种常见的CMS GC问题分析与解决 | Java程序员进阶之路 (tobebetterjavaer.com)</a></p>]]></content>
    
    
    <summary type="html">JVM简要总结（尚未完成）</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（秋招笔试-美团）平均数为k的最长连续子数组</title>
    <link href="http://example.com/2023/09/01/%EF%BC%88%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%A2%EF%BC%89%E5%B9%B3%E5%9D%87%E6%95%B0%E4%B8%BAk%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2023/09/01/%EF%BC%88%E7%A7%8B%E6%8B%9B%E7%AC%94%E8%AF%95-%E7%BE%8E%E5%9B%A2%EF%BC%89%E5%B9%B3%E5%9D%87%E6%95%B0%E4%B8%BAk%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</id>
    <published>2023-09-01T04:17:24.000Z</published>
    <updated>2023-09-07T01:02:12.885Z</updated>
    
    <content type="html"><![CDATA[<p>题的来源：</p><p><a href="https://www.nowcoder.com/questionTerminal/2e47f99735584ac5ba30d75ac14d6524?page=1&onlyReference=false">平均数为k的最长连续子数组__牛客网 (nowcoder.com)</a></p><p>【重要的参考资料：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/">560. 和为 K 的子数组 - 力扣（LeetCode）</a>】</p><p>题解：</p><p>因为题意中，有：“连续子数组”与“平均数”这两个重要条件，所以可以用上前缀和，这是因为平均数乘以k就是一个子数组的和，另外，这个题与DP无关的。另外，注意结果要用Long。</p><p>又因为数据范围过大，需要使用哈希表，防止超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> in.nextLong();</span><br><span class="line">        Map&lt;Long, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="number">0L</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> pre + in.nextLong() - k;</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(cur))&#123;</span><br><span class="line">                ans = Math.max(ans, i - hashMap.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hashMap.put(cur, i);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述没有建立前缀和数组。</p>]]></content>
    
    
    <summary type="html">前缀和与哈希的题</summary>
    
    
    
    
    <category term="刷题：前缀和" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="刷题：哈希表" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="秋招" scheme="http://example.com/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）多线程简要总结</title>
    <link href="http://example.com/2023/08/28/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/08/28/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-28T03:58:30.000Z</published>
    <updated>2023-09-07T06:01:04.766Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><ul><li><p>Syschronized是关键字，可以修饰实例方法、静态方法和代码块。</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁；</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁；</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ul><p>可以让实例方法、静态方法等变为一个临界区</p><p>Java的锁都是基于<strong>对象</strong>的。</p></li><li><p>synchronized可以保证原子性、可见性（能够替代volatile）和有序性。</p><p>而volatile只能保证可见性与有序性，不能保证原子性。</p></li><li><p>synchronized是悲观锁。</p></li><li><p>几个锁的等级排序【要回顾】</p><p>无锁&lt;偏向锁&lt;轻量级锁&lt;重量级锁</p></li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ol><li><p>synchronized是悲观锁</p><p>而CAS是乐观锁</p><p><strong>悲观锁：</strong></p><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><p><strong>乐观锁：</strong></p><p>乐观锁又称为“<strong>无锁</strong>”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为<strong>CAS</strong>的技术来保证<strong>线程执行的安全性</strong>。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说<strong>乐观锁天生免疫死锁</strong>。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p></li></ol><h3 id="锁总结-重要，查阅该网址"><a href="#锁总结-重要，查阅该网址" class="headerlink" title="锁总结[重要，查阅该网址]"></a>锁总结[重要，查阅该网址]</h3><p><a href="https://javabetter.cn/thread/suo.html">公司空降一个美团大佬，彻底把Java中的锁”讲清楚了 | 二哥的Java进阶之路 (javabetter.cn)</a></p><p><img src="https://secure2.wostatic.cn/static/cVT9qmnz3xTwL7aR9HPYpS/image.png?auth_key=1694066438-3YDQC8JfwDMXoryS64KkXq-0-6d773945dfe8f3d988052210c57e10b9"></p>]]></content>
    
    
    <summary type="html">多线程复习总结（简要）</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）面对对象</title>
    <link href="http://example.com/2023/08/22/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2023/08/22/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</id>
    <published>2023-08-22T05:55:12.000Z</published>
    <updated>2023-09-07T05:57:55.297Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/home.html">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li><p>在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被<strong>分配内存空间</strong>。每次使用 <code>new</code> 关键字创建对象的时候，构造方法至少会被调用一次。构造方法有无参构造方法与有参构造方法两种。</p><p>注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过<strong>构造方法初始化值</strong>——描写对象有哪些<strong>初始化状态</strong>。</p><p>必须得要有构造方法，这样才能让类的对象初始化为null或其他值。</p><p><strong>没有返回值，但是返回的是类的对象。</strong></p><p><strong>不仅能做初始化工作，还可以做其他工作，比如启动线程、调用其他方法等</strong>。</p></li><li><p>构造方法必须符合以下<strong>规则</strong>：</p><p>1）构造方法的名字必须和类名一样；</p><p>2）构造方法<strong>没有返回类型</strong>，包括 void，否则会当成普通方法来处理。</p><p>3）构造方法<strong>不能是抽象</strong>的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</p><p>简单解析一下最后一条规则：</p><p>1）由于构造方法<strong>不能被子类继承</strong>，所以用 final 和 abstract 关键字修饰没有意义；</p><p>2）构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；</p><p>3）多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</p></li><li><p>方法与构造方法之间的<strong>区别</strong>：</p><p><img src="https://secure2.wostatic.cn/static/srA7J9pcmRUVvGVNsTP6AZ/image.png?auth_key=1694066108-wbvoTLTecKhRTraVMeMRYt-0-11c19ff298088815d26bd98274099f63"></p></li><li><p>复制对象的方式</p><p>复制一个对象可以通过下面三种方式完成：</p><ul><li>通过构造方法</li><li>通过对象的值</li><li>通过 Object 类的 <code>clone()</code> 方法</li></ul></li></ol><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><ol><li><p>补充一些关于 Java 包和类文件的知识：</p><p>1）Java 中的包主要是为了防止<strong>类文件命名冲突</strong>以及方便<strong>进行代码组织和管理</strong>；</p><p>2）对于一个 <strong>Java 源代码文件</strong>，如果存在 public 类的话，<strong>只能有一个 public 类</strong>，且此时源代码文件的名称必须和 <strong>public 类的名称完全相同</strong>。</p><p>另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。</p></li></ol>]]></content>
    
    
    <summary type="html">复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）数组与字符串</title>
    <link href="http://example.com/2023/08/21/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2023/08/21/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-08-21T01:52:34.000Z</published>
    <updated>2023-09-07T05:54:35.418Z</updated>
    
    <content type="html"><![CDATA[<p>复习资料：<a href="https://javabetter.cn/array/array.html">掌握Java数组：一个非常特殊的对象 | 二哥的Java进阶之路 (javabetter.cn)</a></p><h3 id="数组的初始化方式"><a href="#数组的初始化方式" class="headerlink" title="数组的初始化方式"></a>数组的初始化方式</h3><ol><li>int[] anArray &#x3D; new int[10]; new 方式创建数组对象</li><li>int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};</li></ol><h3 id="无效的数组初始化方式"><a href="#无效的数组初始化方式" class="headerlink" title="无效的数组初始化方式"></a>无效的数组初始化方式</h3><p>以下是一些初始化数组的无效方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效，因为未提供维度</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[];</span><br><span class="line"><span class="comment">// 无效，因为未提供最左侧的维度值</span></span><br><span class="line"><span class="type">int</span>[][] aa = <span class="keyword">new</span> <span class="title class_">int</span>[][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>以下是在java中声明数组的一些其他变体，但强烈建议不要使用它们以避免混淆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] twoArrInt[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> twoIntArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];</span><br></pre></td></tr></table></figure><h3 id="String的声明（String不可变）"><a href="#String的声明（String不可变）" class="headerlink" title="String的声明（String不可变）"></a>String的声明（String不可变）</h3><ol><li>“第一，String 类是 final的，意味着它不能被子类继承。”</li><li>“第二，String 类实现了 <a href="https://javabetter.cn/io/Serializbale.html">Serializable 接口</a>，意味着它可以<a href="https://javabetter.cn/io/serialize.html">序列化</a>。”</li><li>“第三，String 类实现了 <a href="https://javabetter.cn/basic-extra-meal/comparable-omparator.html">Comparable 接口</a>，意味着最好不要用‘&#x3D;&#x3D;’来<a href="https://javabetter.cn/string/equals.html">比较两个字符串是否相等</a>，而应该用 <code>compareTo()</code> 方法去比较。”</li></ol>]]></content>
    
    
    <summary type="html">复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（Java复习总结）Java数据类型笔记</title>
    <link href="http://example.com/2023/08/20/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/08/20/%EF%BC%88Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%89Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-20T03:46:43.000Z</published>
    <updated>2023-09-07T05:51:59.095Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://javabetter.cn/basic-grammar/basic-data-type.html">二哥的Java</a></p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li><p>字符字面量应该用单引号（’’）包围，而不是双引号（””），因为<a href="https://javabetter.cn/string/constant-pool.html">双引号表示字符串字面量</a></p></li><li><p>char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p><p>自动转换：</p><p>byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double<br>char -&gt; int -&gt; long -&gt; float -&gt; double</p><p>强制转换：</p><p>double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</p></li><li><p>Integer.toBinaryString() 将证书转为二进制数，String类型的</p></li><li><p>字符常量</p><p>必须使用单引号</p><p>‘\n’也算是字符常量</p></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>接口不能初始化，也就是说不能使用new。</li></ol><h3 id="基本数据与引用数据之间的区别"><a href="#基本数据与引用数据之间的区别" class="headerlink" title="基本数据与引用数据之间的区别"></a>基本数据与引用数据之间的区别</h3><p>基本数据类型：</p><ul><li>1、变量名指向具体的数值。</li><li>2、基本数据类型存储在<strong>栈</strong>上。</li></ul><p>引用数据类型：</p><ul><li>1、变量名指向的是存储对象的内存地址，在栈上。</li><li>2、内存地址<strong>指向的对象</strong>存储在<strong>堆</strong>上。</li></ul><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆：</p><ul><li>是程序运行时在内存中申请的空间（可理解为动态的过程），不是在编译时。</li><li>动态申请的数据存储位置，比如数组与创建的对象（new方式）等。</li></ul><p>栈：</p><ul><li>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。</li><li>一般放的是编程语句等，对象引用也行，即：Object o这样子，作为对象的引用。</li></ul><p>一个例子：【<a href="https://blog.csdn.net/pop1586082213/article/details/118071050#:~:text=%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%9F%201%20new%20Phone%20%28%29%20%E6%98%AF%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%BC%80%E8%BE%9F%E7%A9%BA%E9%97%B4%E3%80%82%20%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%B0%B1%E6%98%AF%20new,3%20%E5%BD%93%E7%94%A8%E7%AD%89%E5%8F%B7%E8%B5%8B%E5%80%BC%E6%97%B6%EF%BC%8C%E6%98%AF%E5%B0%86%E5%8F%B3%E4%BE%A7%20new%20Phone%20%28%29%20%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E8%B5%8B%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%20phone%20%E3%80%82">参考</a>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>;</span><br></pre></td></tr></table></figure><p>通常会认为 phone 就是 Phone 类的对象。实际上，phone 是创建 Phone 类的<strong>对象的引用</strong>。</p><p>这个表述实际上执行的操作：</p><ol><li><strong>new Phone()</strong> 是在内存中为对象开辟空间。其实也就是 new 关键字表示在内存的 <strong>堆（heap）</strong> 上为对象<strong>开辟空间</strong>，该空间保存了对象的属性和方法。</li><li>Phone phone ：phone 指代一个 Phone 对象，被称为 <strong>对象引用</strong>。实际上，phone 并不是对象本身，而是一个<strong>类似执行对象的指针</strong>。phone 存在于<strong>内存的栈（stack）</strong> 中。</li><li>当用等号赋值时，是将右侧 new Phone() 在堆中创建对象的地址<strong>赋给</strong>对象引用 phone 。</li></ol><p>为什么要这样操作？简单来讲，有以下几种优点：</p><ol><li>栈的读取速度比堆块，但栈上存储的数据受到有效范围的限制。</li><li>一个对象引用可以赋值给另一个对象引用，此时复制的实际上是对象的地址。因此，一个对象可以由多个对象引用，减少对内存的消耗。</li></ol>]]></content>
    
    
    <summary type="html">Java复习总结</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台开发总结记录（随时间更新）</title>
    <link href="http://example.com/2023/05/07/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2023/05/07/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-05-07T02:32:25.000Z</published>
    <updated>2023-09-07T02:52:55.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li>查看是否登录时，一般会看看线程是否有这个用户（网关处理时会把数据保存到线程上）</li></ul><h2 id="MP"><a href="#MP" class="headerlink" title="MP"></a>MP</h2><ul><li>要掌握如何进行分页  <ul><li>MP在处理多个表时，有时用xml更好，尤其是在查询列表时</li></ul></li><li>项目审核上  <ul><li>一般需要一个公共的方法，外加一个code，表示审核失败和审核成功  </li><li>查询验证信息 就是查询是否对象是否存在</li></ul></li><li>进行消息传递时，如果需要传递类，可以用HashMap包装</li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><ul><li>Mono类  </li><li>拦截器 过滤器  </li><li>要加上@Component  </li><li>获取用户的方法  <ul><li>利用网关过滤器，将登录信息包装到thread，然后可以直接读取该thread的信息，得到用户的信息  </li><li>根据传过来的json信息来得到用户的信息</li></ul></li></ul><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li>AppThreadLocalUtil  </li><li>线程读取用户的id  </li><li>重要，需要认真学习</li></ul><h2 id="延迟任务-用于处理文章定时审核和上架"><a href="#延迟任务-用于处理文章定时审核和上架" class="headerlink" title="延迟任务 用于处理文章定时审核和上架"></a>延迟任务 用于处理文章定时审核和上架</h2><ul><li>延迟任务的实现  <ul><li>用的是Redis的延迟队列，其中有2个队列，当前队列和未来队列  </li><li>需要用上乐观锁  </li><li>也可以用RabbitMQ</li></ul></li><li>分布式锁的解决方案（<strong>因为@Schedule存在做集群任务的重复执行问题，后续的xxl-job任务可以解决</strong>）  <ul><li>SETNX 用的是StringRedisTemplate</li></ul></li><li>定时刷新  <ul><li>未来任务定时刷新到当前任务  <ul><li>是在redis上的处理，就是先清楚掉未来任务的数据（zset），然后将这个数据加入到当前队列（list）</li></ul></li><li>数据库定时刷新到redis（即数据库定时同步到redis）  <ul><li>要先清理缓存中的数据，然后从数据库中查询符合条件的数据，并加入到redis</li></ul></li></ul></li><li>GetMapping 和 PostMapping的区别是GetMapping上的连接必须有占位符，即{}，并且参数要有@PathVariable。这个与Http的Get请求特点有关的。  </li><li>延迟任务上，使用的序列化方法是Protostuff，特点是比Jdk的序列化方法快  </li><li>延迟任务上，会使用到的@Scheduled注解，里面用上2个参数  <ul><li>cron  </li><li>fixedRate  </li><li>然后会用上EnableScheduling注解，用于开启调度任务</li></ul></li><li>在文章审核上，需要使用@Asyns实现异步调用，保证文章微服务挂掉时，不影响文章的审核（自媒体的微服务部分）  </li><li>区分延迟任务和定时任务</li></ul><h2 id="Kafka-用于通知文章上下架"><a href="#Kafka-用于通知文章上下架" class="headerlink" title="Kafka 用于通知文章上下架"></a>Kafka 用于通知文章上下架</h2><ul><li>自媒体文章上下架  <ul><li>自媒体微服务如何通知文章微服务？？  <ul><li>Feign远程调用 有耦合性  </li><li>消息队列 RabbitMQ Kafka 系统解耦 流量削峰  </li><li>KafkaProducer 创建Kafka对象</li></ul></li></ul></li><li>Kafka入门  <ul><li>程序设置  生产者和消费者<ul><li>写程序时需要先用Properties创建配置类（<strong>也可以写入yml配置文件</strong>），里面保存连接信息，key和value的序列化或反序列化，另外消费者还需要添加消费者组，其使用的重要参数有：1. 连接信息。2. key和value的序列化或反序列化。3. ack 消息确认机制 开发中不会专门去设置 默认 ack&#x3D;1。4. retries 尝试重试次数 一般设置10次。5. 消息压缩 snappy</li><li>创建生产者对象或消费者对象 传入配置类</li><li>发送消息或订阅主题并拉取消息</li><li>生产者还需要关闭消息通道</li></ul></li><li>消费者组  <ul><li>一对一接收 同一个消费者组有多个消费者就行 （Topic中的一个消费者组的消息只能由一个消费者消费，这也保证消息的有序性）  </li><li>而一对多时，只需要将不同的消费者放在不同的消费组就行  </li><li>消费组的设置：ConsumerConfig类</li></ul></li><li>Kafka的分区设计和高可用设计 这一块需要查阅资料  </li><li>Kafka的生产者上，有同步和异步发送消息  </li><li>Kafka的参数配置  </li><li>Kafka的消息有序性 （按顺序处理Topic的所有消息，就只提供一个分区）  </li><li>偏移量 提交方式： 同步与异步组合方式提交  </li><li>SpringBoot结合Kafka  <ul><li>用yml写入kafka的一些配置  </li><li>用KafkaTemplate（发送信息）  </li><li>注解接收信息 @KafkaListener  </li><li>序列化处理，使用JSON方法，发送消息时，将对象转为JSON字符串，然后接收消息时，将JSON字符串转化为对象</li></ul></li></ul></li></ul><h2 id="ElasticSearch-搜索总结"><a href="#ElasticSearch-搜索总结" class="headerlink" title="ElasticSearch 搜索总结"></a>ElasticSearch 搜索总结</h2><ul><li>ElasticSearch  <ul><li>数据库批量导入ES  <ul><li>RestHighLevelClient  </li><li>要复习ES  </li><li>SearchRequest  <ul><li>QueryBuilders  </li><li>SearchSourceBuilders</li></ul></li><li>IndexRequest</li></ul></li><li>保存搜索记录  <ul><li>用mongodb数据库  </li><li>mongoTemplate  <ul><li>save  </li><li>findById  </li><li>find  </li><li>remove</li></ul></li><li>Query(与Criteria搭配使用，用于组合查询或排序)  <ul><li>query</li></ul></li><li>更新时间方式  <ul><li>用new Date()就行</li></ul></li><li>Sort</li></ul></li><li>联想词查询  <ul><li>实际上是模糊查询</li></ul></li></ul></li></ul><h2 id="关注、取消、点赞等CRUD处理"><a href="#关注、取消、点赞等CRUD处理" class="headerlink" title="关注、取消、点赞等CRUD处理"></a>关注、取消、点赞等CRUD处理</h2><ul><li>关注与取消关注  <ul><li>添加到Redis，使用zset</li></ul></li><li>点赞  <ul><li>因为点赞只能点赞一次，所以要判断是否点赞，此时可以用哈希表</li></ul></li><li>阅读  <ul><li>要更新登录次数  </li><li>用哈希表</li></ul></li><li>不喜欢  <ul><li>根据交流可知，似乎这个与点赞是区分的，都可以点击，也算是不足之处吧  </li><li>用哈希表</li></ul></li><li>收藏  <ul><li>要判断是否已经收藏 只能收藏一次</li></ul></li><li>每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！</li></ul><h2 id="定时任务热点文章计算（问题很大）"><a href="#定时任务热点文章计算（问题很大）" class="headerlink" title="定时任务热点文章计算（问题很大）"></a>定时任务热点文章计算（问题很大）</h2><ul><li>定时任务框架（xxl-job也许主流？？？？ 分布式消息队列？？？？）  <ul><li>定时任务框架-xxl-job 分布式任务调度框架  </li><li>可以解决的问题：  <ul><li>做集群任务的重复执行问题  </li><li>cron表达式定义在代码中，修改不方便  </li><li>定时任务失败，无法重试也没有统计  </li><li>如果任务量过大，不能有效分片执行</li></ul></li></ul></li></ul><h2 id="实时任务-热点文章计算"><a href="#实时任务-热点文章计算" class="headerlink" title="实时任务 热点文章计算"></a>实时任务 热点文章计算</h2><ul><li>SerDe是Serializer&#x2F;Deserializer的缩写。 Serdes.String().getClass() 实际上是得到一个序列化器  </li><li>Topology类 这个可能要注意  </li><li>重要的对象 KStream 键值类型的  </li><li>Duration.ofSeconds  <ul><li>KakfaStream 的flatMapValues方法：<br>在Kafka中，<code>flatMapValues</code>是一个操作符（operator），用于对每个记录的值进行扁平化处理（<strong>就是对一个数据流的数据进行分开处理</strong>），<br>并生成零个或多个新的记录。<code>flatMapValues</code>操作符的功能类似于<code>flatMap</code>操作符，但它只应用于记录的值部分，而不改变键部分。</li></ul></li><li>Kafka的流式处理模块是单独的，需要生产者的topic和消费者的topic  </li><li>需要自己添加配置类，因为SpringBoot对kafkaStream的yml集成效果不太好  <ul><li>需要学习的注解  </li><li>@ConfigurationProperties  </li><li>@Bean  </li><li>@Value</li></ul></li><li>所谓热点文章，就是同时考虑点赞行为和阅读行为，对文章的分值进行计算，要实时的，这个可以用KafkaStream完成的。  </li><li><strong>enum 枚举类或集合方法的撰写 必须要学会</strong>  </li><li><strong>常量类上的方法使用 static 和 final</strong>  </li><li>String.format()</li></ul><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ul><li>mongodb处理 <ul><li>分页列表并不像MP那样有插件，需要自己实现  </li><li>涉及到MongoDB的数据操作，是没有mapper的，因为mongoTemplate里面有数据操作的方法</li></ul></li></ul>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台开发的注意事项简要记录</title>
    <link href="http://example.com/2023/04/23/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/04/23/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-23T03:30:58.000Z</published>
    <updated>2023-09-07T03:35:45.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nacos配置问题"><a href="#nacos配置问题" class="headerlink" title="nacos配置问题"></a>nacos配置问题</h4><p>每次正确添加nacos配置后，如果碰上某个微服务的错误，此时要考虑是不是不小心加上了无关的依赖库，尤其是okhttp 。</p><h4 id="延迟队列问题"><a href="#延迟队列问题" class="headerlink" title="延迟队列问题"></a>延迟队列问题</h4><p>延迟队列  </p><ul><li><p>延迟队列上，判断数据是否到期，就是和当前时间进行比较，用的是System.currentTimeMillis() 。</p></li><li><p>如何将Redis的未来队列的数据同步到list  </p><ul><li><p>从zset中查出数据，并删除  </p></li><li><p>把数据存入到list  </p></li><li><p>用管道方式更快</p></li></ul></li></ul><h4 id="拦截器问题"><a href="#拦截器问题" class="headerlink" title="拦截器问题"></a>拦截器问题</h4><p>每次需要使用AppThred等类时，必须在所在的微服务上添加拦截器！！！！！  </p><h4 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h4><p>部分程序存在 ，存在Claims类（自己编写失误）将未登录的用户的id默认为0的情况，此时需要在此处加个判断，将未登录用户不能直接登录。</p>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台使用的技术简要总结_杂记（随时间更新）</title>
    <link href="http://example.com/2023/04/01/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93-%E6%9D%82%E8%AE%B0%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://example.com/2023/04/01/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93-%E6%9D%82%E8%AE%B0%EF%BC%88%E9%9A%8F%E6%97%B6%E9%97%B4%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-04-01T12:50:20.000Z</published>
    <updated>2023-09-07T02:30:48.607Z</updated>
    
    <content type="html"><![CDATA[<p>JSON 阿里巴巴的fastjson  </p><p>StringUtils  </p><ul><li><p>不同的包也有不同的方法  </p></li><li><p>isNotBlank 和 isEmpty也是不同的方法</p></li></ul><p>BeansUtils springframework的  </p><p>@RequestBody  </p><p>Arrays类，比如asList  </p><p>IDEA快捷键，比如Ctrl+SHIFT+t 可以构建测试类  </p><p>DFA算法，雪花算法 DFA有点像前缀树  </p><p>spring.factories 作用探讨  </p><p>Tess4j 图片识别 把图片的文字提出来，然后识别文字是否存在问题  </p><p>同步 异步 @Aynsn  </p><p>Freemarker Template Configuration  </p><p>StringWriter  </p><p>apArticleService.update(Wrappers.<ApArticle>lambdaUpdate().eq(ApArticle::getId,apArticle.getId()).set(ApArticle::getStaticUrl,path)); set用法  </p><p>乐观锁 悲观锁  </p><ul><li><p>乐观锁： 每次拿数据的时候都认为别人不会修改，所以不上锁，但是每次更新时会判断之前被人是否改过，用版本号机制等判断  </p><p>用@Version 标明是版本号，用乐观锁  </p><p>MP对乐观锁有支持，只需要加个拦截器配置，分页机制也是  </p></li><li><p>悲观锁：而悲观锁则是每次拿数据时都认为别人会修改，所以每次拿数据都会上锁</p></li></ul><p>StringRedisTemplate StringRedisConnection  </p><ul><li><p>Scan方法  </p></li><li><p>分布式锁 Setnx</p></li></ul><p>Calendar Date 日期类  </p><p>getTime()  </p><p>测试类  </p><ul><li>@SpringBootTest(classes &#x3D; ScheduleApplication.class)<br>@RunWith(SpringRunner.class)</li></ul><p>@Schedule  </p><p>@PostConstruct 有初始化的方法  </p><p>@PathVariable 占位符  </p><p>Feign（重点！！！！！）  </p><p>枚举类的撰写  </p><p>Protostuff序列化  </p><p>@Scheduled @EnableScheduling  </p><p>MP如何更新数据  </p><p>DigestUtils  </p><p>定时任务框架-xxljob</p>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）注解总结之@RequestBody</title>
    <link href="http://example.com/2023/03/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93%E4%B9%8B-RequestBody/"/>
    <id>http://example.com/2023/03/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93%E4%B9%8B-RequestBody/</id>
    <published>2023-03-10T03:28:20.000Z</published>
    <updated>2023-09-07T03:30:04.344Z</updated>
    
    <content type="html"><![CDATA[<p><code>@RequestBody</code> 是一个Spring框架中的注解，用于将HTTP请求的内容（例如JSON、XML等）绑定到方法的参数上。它通常与Spring MVC或Spring Boot中的控制器方法一起使用。  </p><p>使用<code>@RequestBody</code>注解时，Spring框架会自动将请求体的内容解析，并尝试将其转换为指定的参数类型。  </p><p>以下是<code>@RequestBody</code>的示例用法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span>  </span><br><span class="line">        <span class="keyword">public</span> ResponseEntity&lt;?&gt; createUser(<span class="meta">@RequestBody</span> User user) &#123;  </span><br><span class="line">        <span class="comment">// 处理请求，使用接收到的User对象  </span></span><br><span class="line">        <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().build();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>createUser()</code>方法使用<code>@RequestBody</code>注解来接收HTTP POST请求中的请求体，并将其转换为User对象。Spring框架会根据请求的内容类型（例如JSON）以及User类的定义，自动完成请求体到User对象的转换。  </p><p>需要注意的是，在使用<code>@RequestBody</code>时，通常还需要指定请求的Content-Type。例如，如果请求的Content-Type是application&#x2F;json，则Spring会使用相应的JSON转换器将JSON字符串转换为User对象。  </p><p>另外，<code>@RequestBody</code>注解还支持其他参数类型，如<code>Map&lt;String, Object&gt;</code>、<code>List&lt;User&gt;</code>等，以及自定义的数据转换器和处理器。  </p><p>总之，<code>@RequestBody</code>注解允许将HTTP请求的内容转换为方法参数，并方便地在Spring框架中处理和使用请求体数据。</p>]]></content>
    
    
    <summary type="html">对@RequestBody的总结</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="注解与反射" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台数据库开发记录总结</title>
    <link href="http://example.com/2023/02/21/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/02/21/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-02-21T07:42:36.000Z</published>
    <updated>2023-09-07T02:03:38.586Z</updated>
    
    <content type="html"><![CDATA[<p>添加到数据库时  </p><ul><li>如果是Mapper，一般是用insert方法或save方法  </li><li>而用这些方法前，一般会设置dto类，并创建dto方法，然后用BeansUtils将传输过来的类拷贝到这个dto类，但是dto类依然有些属性是空着，要自己从其他地方添加。</li></ul>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记简要复习总结</title>
    <link href="http://example.com/2023/01/11/MySQL%E7%AC%94%E8%AE%B0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/01/11/MySQL%E7%AC%94%E8%AE%B0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-11T11:38:03.000Z</published>
    <updated>2023-09-07T01:43:35.452Z</updated>
    
    <content type="html"><![CDATA[<p>阅读来源：<a href="https://javaguide.cn/database/sql/sql-syntax-summary.html">SQL语法基础知识总结 | JavaGuide(Java面试 + 学习指南)</a></p><h2 id="select聚类"><a href="#select聚类" class="headerlink" title="select聚类"></a>select聚类</h2><p>    select 语句中，如果没有 <code>GROUP BY</code> 语句，那么 <code>cust_name</code>、<code>order_num</code> 会返回若干个值，而 <code>sum(quantity * item_price)</code> 只返回一个值，通过 <code>group by</code> <code>cust_name</code> 可以让 <code>cust_name</code> 和 <code>sum(quantity * item_price)</code> 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 <code>order_num</code> 进行聚类。</p><blockquote><p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong></p></blockquote><h2 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h2><p><code>ORDER BY</code> 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。</p><p>知识点：</p><ul><li>逗号作用是用来隔开列与列之间的。</li><li>ORDER BY 是有 BY 的，需要撰写完整，且位置正确</li><li>知识点：<code>DISTINCT</code> 用于返回列中的唯一不同值、</li><li>注意limit的使用，这个作用筛选某些值，比如筛选前面的几个值</li></ul><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>WHERE</code> 可以过滤返回的数据。</p><p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。 <strong>注释：</strong> 在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p>SQL 通配符必须与 <code>LIKE</code> 运算符一起使用</p><p>在 SQL 中，可使用以下通配符：</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>%</code></td><td>代表零个或多个字符</td></tr><tr><td><code>_</code></td><td>仅替代一个字符</td></tr><tr><td><code>[charlist]</code></td><td>字符列中的任何单一字符</td></tr><tr><td><code>[^charlist]</code> 或者 <code>[!charlist]</code></td><td>不在字符列中的任何单一字符</td></tr></tbody></table><h2 id="使用函数处理数据"><a href="#使用函数处理数据" class="headerlink" title="使用函数处理数据"></a>使用函数处理数据</h2><p>知识点：</p><ul><li><p>截取函数<code>SUBSTRING()</code>：截取字符串，<code>substring(str ,n ,m)</code>（n 表示起始截取位置，m 表示要截取的字符个数）表示返回字符串 str 从第 n 个字符开始截取 m 个字符；</p></li><li><p>拼接函数<code>CONCAT()</code>：将两个或多个字符串连接成一个字符串，select concat(A,B)：连接字符串 A 和 B。</p></li><li><p>大写函数 <code>UPPER()</code>：将指定字符串转换为大写。</p></li></ul><p>知识点：</p><ul><li>日期格式：<code>YYYY-MM-DD</code></li><li>时间格式：<code>HH:MM:SS</code></li></ul><p>日期和时间处理相关的常用函数：</p><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>ADDDATE()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>ADDTIME()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CURDATE()</code></td><td>返回当前日期</td></tr><tr><td><code>CURTIME()</code></td><td>返回当前时间</td></tr><tr><td><code>DATE()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DATEDIFF</code></td><td>计算两个日期之差</td></tr><tr><td><code>DATE_FORMAT()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>DAY()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DAYOFWEEK()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>HOUR()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>MINUTE()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>MONTH()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>NOW()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>SECOND()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>TIME()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>YEAR()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>汇总数据相关的函数：</p><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><code>GROUP BY</code>：</p><ul><li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li><li><code>GROUP BY</code> 为每个组返回一个记录。</li><li><code>GROUP BY</code> 通常还涉及聚合<code>COUNT</code>，<code>MAX</code>，<code>SUM</code>，<code>AVG</code> 等。</li><li><code>GROUP BY</code> 可以按一列或多列进行分组。</li><li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li></ul><p><code>HAVING</code>：</p><ul><li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li><li><code>HAVING</code> 必须要与 <code>GROUP BY</code> 连用。</li><li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li></ul><p><code>HAVING</code> vs <code>WHERE</code>：</p><ul><li><code>WHERE</code>：过滤指定的行，后面不能加聚合函数（分组函数）。</li><li><code>HAVING</code>：过滤分组，必须要与 <code>GROUP BY</code> 连用，不能单独使用。</li></ul><h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 <code>SELECT</code> 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。</p><p>子查询可以嵌入 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句中，也可以和 <code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>IN</code>、<code>BETWEEN</code>、<code>EXISTS</code> 等运算符一起使用。</p><p>子查询常用在 <code>WHERE</code> 子句和 <code>FROM</code> 子句后边：</p><ul><li>当用于 <code>WHERE</code> 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。</li><li><strong>当用于 <code>FROM</code> 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 <code>FROM</code> 后面是表的规则。这种做法能够实现多表联合查询。</strong></li><li>from</li></ul><blockquote><p>注意：MySQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。</p></blockquote><p>用于 <code>WHERE</code> 子句的子查询的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name [, column_name ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">WHERE column_name operator</span><br><span class="line">(SELECT column_name [, column_name ]</span><br><span class="line">FROM table1 [, table2 ]</span><br><span class="line">[WHERE])</span><br></pre></td></tr></table></figure><ul><li>子查询需要放在括号<code>( )</code>内。</li><li><code>operator</code> 表示用于 <code>WHERE</code> 子句的运算符，可以是比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;&gt;</code> 等）或逻辑运算符（如 <code>IN</code>, <code>NOT IN</code>, <code>EXISTS</code>, <code>NOT EXISTS</code> 等），具体根据需求来确定。</li></ul><p>用于 <code>FROM</code> 子句的子查询的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name [, column_name ]</span><br><span class="line">FROM (SELECT column_name [, column_name ]</span><br><span class="line">      FROM table1 [, table2 ]</span><br><span class="line">      [WHERE]) AS temp_table_name [, ...]</span><br><span class="line">[JOIN type JOIN table_name ON condition]</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><ul><li>用于 <code>FROM</code> 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。</li><li>子查询需要放在括号 <code>( )</code> 内。</li><li>可以指定多个临时表名，并使用 <code>JOIN</code> 语句连接这些表</li></ul><h2 id="连接表"><a href="#连接表" class="headerlink" title="连接表"></a>连接表</h2><p>JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。</p><p>连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。<strong>连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间</strong>。</p><p>使用 <code>JOIN</code> 连接两个表的基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1.column1, table2.column2...</span><br><span class="line">FROM table1</span><br><span class="line">JOIN table2</span><br><span class="line">ON table1.common_column1 = table2.common_column2;</span><br></pre></td></tr></table></figure><p><code>table1.common_column1 = table2.common_column2</code> 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 &#x3D;、&gt;、&lt;、&lt;&gt;、&lt;&#x3D;、&gt;&#x3D;、!&#x3D;、<code>between</code>、<code>like</code> 或者 <code>not</code>，但是最常见的是使用 &#x3D;。</p><p>当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。</p><p>另外，如果两张表的关联字段名相同，也可以使用 <code>USING</code>子句来代替 <code>ON</code>，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># join....on</span><br><span class="line">SELECT c.cust_name, o.order_num</span><br><span class="line">FROM Customers c</span><br><span class="line">INNER JOIN Orders o</span><br><span class="line">ON c.cust_id = o.cust_id</span><br><span class="line">ORDER BY c.cust_name</span><br><span class="line"></span><br><span class="line"># 如果两张表的关联字段名相同，也可以使用USING子句：JOIN....USING()</span><br><span class="line">SELECT c.cust_name, o.order_num</span><br><span class="line">FROM Customers c</span><br><span class="line">INNER JOIN Orders o</span><br><span class="line">USING(cust_id)</span><br><span class="line">ORDER BY c.cust_name</span><br></pre></td></tr></table></figure><p><strong><code>ON</code> 和 <code>WHERE</code> 的区别</strong>：</p><ul><li>连接表时，SQL 会根据连接条件生成一张新的临时表。<code>ON</code> 就是连接条件，它决定临时表的生成。</li><li><code>WHERE</code> 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。</li></ul><p>所以总结来说就是：<strong>SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选</strong>。</p><p>SQL 允许在 <code>JOIN</code> 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：</p><table><thead><tr><th>连接类型</th><th>说明</th></tr></thead><tbody><tr><td>INNER JOIN 内连接</td><td>（默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。</td></tr><tr><td>LEFT JOIN &#x2F; LEFT OUTER JOIN 左(外)连接</td><td>返回左表中的所有行，即使右表中没有满足条件的行也是如此。</td></tr><tr><td>RIGHT JOIN &#x2F; RIGHT OUTER JOIN 右(外)连接</td><td>返回右表中的所有行，即使左表中没有满足条件的行也是如此。</td></tr><tr><td>FULL JOIN &#x2F; FULL OUTER JOIN 全(外)连接</td><td>只要其中有一个表存在满足条件的记录，就返回行。</td></tr><tr><td>SELF JOIN</td><td>将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。</td></tr><tr><td>CROSS JOIN</td><td>交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。</td></tr></tbody></table><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</p><p><code>UNION</code> 基本规则：</p><ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li></ul><p>默认地，<code>UNION</code> 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column_name(s) FROM table2;</span><br></pre></td></tr></table></figure><p><code>UNION</code> 结果集中的列名总是等于 <code>UNION</code> 中第一个 <code>SELECT</code> 语句中的列名。</p><p><code>JOIN</code> vs <code>UNION</code>：</p><ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul><p>使用 <code>union</code> 组合查询时，只能使用一条 <code>order by</code> 字句，他必须位于最后一条 <code>select</code> 语句之后 或者直接使用or做</p><p>在组合查询上，union的作用和or类似</p><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p><strong>描述</strong>：现有一张试卷作答记录表 exam_record，其中包含多年来的用户作答试卷记录，结构如下表：</p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Extra</th><th>Default</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>int(11)</td><td>NO</td><td>PRI</td><td>auto_increment</td><td>(NULL)</td><td>自增 ID</td></tr><tr><td>uid</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>用户 ID</td></tr><tr><td>exam_id</td><td>int(11)</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>试卷 ID</td></tr><tr><td>start_time</td><td>datetime</td><td>NO</td><td></td><td></td><td>(NULL)</td><td>开始时间</td></tr><tr><td>submit_time</td><td>datetime</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>提交时间</td></tr><tr><td>score</td><td>tinyint(4)</td><td>YES</td><td></td><td></td><td>(NULL)</td><td>分数</td></tr></tbody></table><p><strong>要求</strong>：请删除<code>exam_record</code>表中所有记录，&#x3D;&#x3D;并重置自增主键&#x3D;&#x3D;</p><p><strong>思路</strong>：这题考察对三种删除语句的区别，注意高亮部分，要求重置主键；</p><ul><li><code>DROP</code>: 清空表，删除表结构，不可逆</li><li><code>TRUNCATE</code>: 格式化表，不删除表结构，不可逆</li><li><code>DELETE</code>：删除数据，可逆</li></ul><p>这里选用<code>TRUNCATE</code>的原因是：TRUNCATE 只能作用于表；<code>TRUNCATE</code>会清空表中的所有行，但表结构及其约束、索引等保持不变；<code>TRUNCATE</code>会重置表的自增值；使用<code>TRUNCATE</code>后会使表和索引所占用的空间会恢复到初始大小。</p><p>这题也可以采用<code>DELETE</code>来做，但是在删除后，还需要手动<code>ALTER</code>表结构来设置主键初始值；</p><p>同理也可以采用<code>DROP</code>来做，直接删除整张表，包括表结构，然后再新建表即可。</p>]]></content>
    
    
    <summary type="html">JavaGuide的MySQL笔记复习总结</summary>
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>（开发笔记）平台开发时所使用的JSON记录总结</title>
    <link href="http://example.com/2023/01/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84JSON%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/01/10/%EF%BC%88%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%89%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84JSON%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-10T01:05:01.000Z</published>
    <updated>2023-09-07T02:12:57.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON的作用是实现序列化，用于将Java中的对象转化为JSON字符串，方便返回给前端。</p><p>平台使用的JSON是fastjson，阿里开源的，但是Java和Spring版本不能过高，否则fastjson可能没法用。</p><p>另外，SpringBoot内置的Jackson和谷歌开源的Gson也可以用（立下flag要学习使用）</p><h3 id="parseArray"><a href="#parseArray" class="headerlink" title="parseArray"></a>parseArray</h3><p>Java中的JSON.parseArray()方法用于将JSON数组字符串解析为Java中的List对象。<br>比如如果给一个JSON语句，然后第二个参数给Map.class，于是该方法就将该语句解析为一个List语句，其中该List里面的类是Map。</p>]]></content>
    
    
    <summary type="html">总结自用</summary>
    
    
    
    
    <category term="开发" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>(图论) B.Badge</title>
    <link href="http://example.com/2022/10/06/%E5%9B%BE%E8%AE%BA-B-Badge/"/>
    <id>http://example.com/2022/10/06/%E5%9B%BE%E8%AE%BA-B-Badge/</id>
    <published>2022-10-06T08:32:24.000Z</published>
    <updated>2023-09-06T07:13:48.443Z</updated>
    
    <content type="html"><![CDATA[<p>图论+dfs</p><p>题目链接：<a href="http://codeforces.com/contest/1020/problem/B">Problem - B - Codeforces</a></p><h4 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h4><h4 id="B-Badge"><a href="#B-Badge" class="headerlink" title="B. Badge"></a>B. Badge</h4><p>In Summer Informatics School, if a student doesn’t behave well, teachers make a hole in his badge. And today one of the teachers caught a group of n students doing yet another trick.</p><p>Let’s assume that all these students are numbered from 11 to n. The teacher came to student a and put a hole in his badge. The student, however, claimed that the main culprit is some other student papa.</p><p>After that, the teacher came to student papa and made a hole in his badge as well. The student in reply said that the main culprit was student Ppa.</p><p>This process went on for a while, but, since the number of students was finite, eventually the teacher came to the student, who already had a hole in his badge.</p><p>After that, the teacher put a second hole in the student’s badge and decided that he is done with this process, and went to the sauna.</p><p>You don’t know the first student who was caught by the teacher. However, you know all the numbers pi. Your task is to find out for every student a, who would be the student with two holes in the badge if the first caught student was a.</p><p>Input</p><p>The first line of the input contains the only integer n (1≤n≤10001≤n≤1000) — the number of the naughty students.</p><p>The second line contains n integers p1, …, p (1≤pi≤n), where pi indicates the student who was reported to the teacher by student ii.</p><p>Output</p><p>For every student a from 11 to n print which student would receive two holes in the badge, if a was the first student caught by the teacher.</p><p>Examples</p><p>input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 3</span><br></pre></td></tr></table></figure><p>Note</p><p>The picture corresponds to the first example test case.</p><img src="http://codeforces.com/predownloaded/e6/2f/e62f6279b291a91d10dcf8b13b483a9dc5659758.png" title="" alt="img" data-align="center"><p>When a&#x3D;1, the teacher comes to students 1, 2, 3, 2, in this order, and the student 2 is the one who receives a second hole in his badge.</p><p>When a&#x3D;2,the teacher comes to students 2, 3, 2, and the student 2 gets a second hole in his badge. When a&#x3D;3, the teacher will visit students 3, 2, 3 with student 3 getting a second hole in his badge.</p><p>For the second example test case it’s clear that no matter with whom the teacher starts, that student would be the one who gets the second hole in his badge.</p><p>上面的一些特殊的符号需要看看codeforces就行。</p><p>这个是一个图论题，就是在不断根据指控把一个人的标记打上扣，一直继续下去，直到找出已打出两个扣的人。</p><p>Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">L = list(map(int, input().split()))</span><br><span class="line">L.insert(0,0)</span><br><span class="line">Q = [i for i in range(n)]</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    vis = [0 for i in range(n + 1)]</span><br><span class="line">    cur = i</span><br><span class="line">    while True:</span><br><span class="line">        if vis[cur] != 0:</span><br><span class="line">            break</span><br><span class="line">        vis[cur] = 1</span><br><span class="line">        cur = L[cur]</span><br><span class="line">    print(cur, end=&quot; &quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;图论+dfs&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;http://codeforces.com/contest/1020/problem/B&quot;&gt;Problem - B - Codeforces&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    
    <category term="刷题：图论" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="刷题：DFS" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9ADFS/"/>
    
  </entry>
  
  <entry>
    <title>(图论) A. Love Triangle</title>
    <link href="http://example.com/2022/10/06/%E5%9B%BE%E8%AE%BA-A-Love-Triangle/"/>
    <id>http://example.com/2022/10/06/%E5%9B%BE%E8%AE%BA-A-Love-Triangle/</id>
    <published>2022-10-06T05:24:49.000Z</published>
    <updated>2023-09-06T07:13:37.266Z</updated>
    
    <content type="html"><![CDATA[<p>这个其实是一个很基础的图论题。</p><span id="more"></span><p>题目链接：<a href="http://codeforces.com/problemset/problem/939/A">Problem - 939A - Codeforces</a></p><h4 id="A-Love-Triangle"><a href="#A-Love-Triangle" class="headerlink" title="A. Love Triangle"></a>A. Love Triangle</h4><p>As you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are <em>n</em> planes on Earth, numbered from 1 to <em>n</em>, and the plane with number <em>i</em> likes the plane with number <em>f**i</em>, where 1 ≤ <em>f**i</em> ≤ <em>n</em> and <em>f**i</em> ≠ <em>i</em>.</p><p>We call a love triangle a situation in which plane <em>A</em> likes plane <em>B</em>, plane <em>B</em> likes plane <em>C</em> and plane <em>C</em> likes plane <em>A</em>. Find out if there is any love triangle on Earth.</p><p>Input</p><p>The first line contains a single integer <em>n</em> (2 ≤ <em>n</em> ≤ 5000) — the number of planes.</p><p>The second line contains <em>n</em> integers <em>f</em>1, <em>f</em>2, …, <em>f**n</em> (1 ≤ <em>f**i</em> ≤ <em>n</em>, <em>f**i</em> ≠ <em>i</em>), meaning that the <em>i</em>-th plane likes the <em>f**i</em>-th.</p><p>Output</p><p>Output «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO».</p><p>You can output any letter in lower case or in upper case.</p><p>Examples</p><p>input</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 5 1 3</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><p>input</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 5 5 5 1</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><p>Note</p><p>In first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle.</p><p>In second example there are no love triangles.</p><p>这个是一个很基础的图论题，只要有f[f[f[i]]] &#x3D;&#x3D; i的话，就说明肯定存在三角关系。</p><p>Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">f = list(map(int, input().split()))</span><br><span class="line">f.insert(0, 0)</span><br><span class="line">flag = 0</span><br><span class="line">for i in range(1, n + 1):</span><br><span class="line">    if f[f[f[i]]] == i:</span><br><span class="line">        flag = 1</span><br><span class="line">        break</span><br><span class="line">if flag:</span><br><span class="line">    print(&quot;YES&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;NO&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个其实是一个很基础的图论题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="刷题：图论" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9A%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>(数学)A. Restoring Three Numbers</title>
    <link href="http://example.com/2022/10/06/%E6%95%B0%E5%AD%A6-A-Restoring-Three-Numbers/"/>
    <id>http://example.com/2022/10/06/%E6%95%B0%E5%AD%A6-A-Restoring-Three-Numbers/</id>
    <published>2022-10-06T03:19:50.000Z</published>
    <updated>2023-09-06T07:13:23.178Z</updated>
    
    <content type="html"><![CDATA[<p>这个是一个数学题。不过不必是暴力的。</p><span id="more"></span><p>题目链接：<a href="http://codeforces.com/problemset/problem/1154/A">Problem - 1154A - Codeforces</a></p><h4 id="A-Restoring-Three-Numbers"><a href="#A-Restoring-Three-Numbers" class="headerlink" title="A. Restoring Three Numbers"></a>A. Restoring Three Numbers</h4><p>Polycarp has guessed three positive integers aa, bb and cc. He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: a+ba, a+c, b+c and a+b+c.</p><p>You have to guess three numbers aa, bb and cc using given numbers. Print three guessed integers in any order.</p><p>Pay attention that some given numbers a, b and c can be equal (it is also possible that a&#x3D;b&#x3D;c).</p><p>Input</p><p>The only line of the input contains four positive integers x1,x2,x3,x4(2≤xi≤10^9) — numbers written on a board in random order. It is guaranteed that the answer exists for the given number x1,x2,x3,x4.</p><p>Output</p><p>Print such positive integers aa, bb and cc that four numbers written on a board are values a+b, a+c, b+c and a+b+c written in some order. Print a, b and c in any order. If there are several answers, you can print any. It is guaranteed that the answer exists.</p><p>Examples</p><p>input</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6 5 4</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p>input</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40 40 40 60</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40 40 40 60</span><br></pre></td></tr></table></figure><p>input</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">201 101 101 200</span><br></pre></td></tr></table></figure><p>output</p><p>Copy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 100 100</span><br></pre></td></tr></table></figure><p>这个是一个数学题，不必是从1开始暴力，会超时的。可以从给出的4个数中选出最大的（a+b+c当然是最大的），然后减去其他中的一个，得到a或b或c，最后把剩下的两个减去这个数，得到相应的数。</p><p>Python代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Q = map(int, input().split()) # 最后得到的就是一个tuple类型</span><br><span class="line">L = list(Q) # 将tuple类型转换为list类型。</span><br><span class="line">L.sort() # 排序，为了得到a + b + c的值。</span><br><span class="line">m = L[3]</span><br><span class="line">c = m - L[2]</span><br><span class="line">a = L[0] - c</span><br><span class="line">b = L[1] - c</span><br><span class="line">print(a, b, c)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个是一个数学题。不过不必是暴力的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="刷题：Math" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%EF%BC%9AMath/"/>
    
  </entry>
  
  <entry>
    <title>Java基础复习简要总结（黑马视频）</title>
    <link href="http://example.com/2022/08/07/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/08/07/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-07T03:30:37.000Z</published>
    <updated>2023-09-07T01:54:31.944Z</updated>
    
    <content type="html"><![CDATA[<p>为了打好基础，我跟着Java黑马教程学习一段时间，现在将Java基础与面对对象知识进行总结并标记重要地方（主要对自己不太了解的知识总结）</p><p>视频来源：<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.search-card.all.click">黑马程序员Java零基础视频教程_上部(Java入门，含斯坦福大学练习题+力扣算法题和大厂java面试题）_哔哩哔哩_bilibili</a></p><h3 id="面向对象-就近原则和this关键字、构造方法"><a href="#面向对象-就近原则和this关键字、构造方法" class="headerlink" title="面向对象-就近原则和this关键字、构造方法"></a>面向对象-就近原则和this关键字、构造方法</h3><ul><li><p>this表示当前对象的地址</p><ul><li><p>this可以区分成员变量和局部变量</p></li><li><p>this 本质 代表方法调用者的地址值，Car c &#x3D; new Car()上，c和this的地址值是一样的，所以指代的也一样。</p></li></ul></li><li><p>就近原则 指的是谁离我近，就用谁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(age)</span>&#123;</span><br><span class="line">    age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据就近原则，左边的age算是局部变量，age&#x3D;null，所以返回null</p></li><li><p>构造方法的作用：</p><ul><li><p>给成员变量进行初始化，返回其地址</p></li><li><p>Car c &#x3D; new Car() c保存的是地址。（看面向对象-07的对象内存图）</p></li></ul></li><li><p>标准的JavaBean类（只是一个有特定要求的类而已，类似的有工具类）</p><ul><li><p>类名需要见名知意</p></li><li><p>成员变量至少需要用private修饰</p></li><li><p>提供至少2个构造方法，比如无参构造和带全部参数的构造</p></li><li><p>成员方法：提供每一个成员变量所提供的setXxxx()和getXxxx()，如果还其他行为，一并写上。</p></li><li><p>在IDEA上，可以邮件 有PTG to javabean。</p></li></ul></li></ul><h3 id="面向对象-07-三种情况的对象内存图【重要-看视频-面试】需要看JVM"><a href="#面向对象-07-三种情况的对象内存图【重要-看视频-面试】需要看JVM" class="headerlink" title="面向对象-07 三种情况的对象内存图【重要 看视频 面试】需要看JVM"></a>面向对象-07 三种情况的对象内存图【重要 看视频 面试】需要看JVM</h3><h3 id="面向对象-09-this的内存原理【看视频】"><a href="#面向对象-09-this的内存原理【看视频】" class="headerlink" title="面向对象-09 this的内存原理【看视频】"></a>面向对象-09 this的内存原理【看视频】</h3><h3 id="面向对象进阶-03-static的注意事项，-02也可以看看一下"><a href="#面向对象进阶-03-static的注意事项，-02也可以看看一下" class="headerlink" title="面向对象进阶-03 static的注意事项， 02也可以看看一下"></a>面向对象进阶-03 static的注意事项， 02也可以看看一下</h3><ul><li><p>总结</p><ul><li><p>静态方法没有this</p></li><li><p>静态方法只能访问静态，因为静态随类加载而加载，此时对象可能未加载，所以没法访问</p></li><li><p>非静态方法可以访问任意</p></li><li><p><em>静态属于类，不属于对象</em></p></li></ul></li><li><p>非静态方法有一个隐藏的this</p><ul><li><pre><code class="java">void show1(Student this)&#123;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 多线程 同步代码块 多线程 08</span><br><span class="line"></span><br><span class="line">- 把操作共享数据（比如用static定义的变量等）的代码锁起来。</span><br><span class="line"></span><br><span class="line">- static定义的变量和方法可以被所有对象共享。</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  synchronized(锁对象)&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>最好在循坏内，否则会成单线程 具体见多线程-08</p><p>看PPT的总结</p><ul><li><p>对于实例方法建议使用this作为锁对象。</p></li><li><p>对于静态方法建议使用字节码（类名.class）对象作为锁对象。</p></li></ul></li></ul><h3 id="多线程-同步方法"><a href="#多线程-同步方法" class="headerlink" title="多线程 同步方法"></a>多线程 同步方法</h3><ul><li><p>就是把synchronized关键字加到方法上。</p></li><li><p>用Runnable创建进程对象时，因为只构建一个对象，所以成员变量不需要添加static作为共享变量。</p></li></ul><h3 id="多线程-Lock锁"><a href="#多线程-Lock锁" class="headerlink" title="多线程 Lock锁"></a>多线程 Lock锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.lock()</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><ul><li><p>要保证所有对象共享同一把锁。</p></li><li><p>用Thread创建多个线程时，需要对Lock对对象添加static</p></li><li><p>使用try-catch-finally</p></li></ul><h3 id="多线程-死锁"><a href="#多线程-死锁" class="headerlink" title="多线程 死锁"></a>多线程 死锁</h3><ul><li>注意安排好线程的先后，否则会卡死</li></ul><h3 id="多线程-线程池-多线程-29"><a href="#多线程-线程池-多线程-29" class="headerlink" title="多线程 线程池 多线程 29"></a>多线程 线程池 多线程 29</h3><ul><li>线程池是线程的复用技术</li><li>1、创建线程池。2、提交任务，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下次提交任务时，不需要创建线程，只需要复用线程即可。3、池子中没有空闲线程时，也无法创建新的线程时，任务就排队等待。4、所有任务执行完毕时，会关闭线程池。</li></ul>]]></content>
    
    
    <summary type="html">基础复习总结，面对对象和多线程两个</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>scrapy提交表单——爬取火熊网最新上传一栏并下载图片</title>
    <link href="http://example.com/2021/07/10/scrapy%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E2%80%94%E2%80%94%E7%88%AC%E5%8F%96%E7%81%AB%E7%86%8A%E7%BD%91%E6%9C%80%E6%96%B0%E4%B8%8A%E4%BC%A0%E4%B8%80%E6%A0%8F%E5%B9%B6%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2021/07/10/scrapy%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E2%80%94%E2%80%94%E7%88%AC%E5%8F%96%E7%81%AB%E7%86%8A%E7%BD%91%E6%9C%80%E6%96%B0%E4%B8%8A%E4%BC%A0%E4%B8%80%E6%A0%8F%E5%B9%B6%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</id>
    <published>2021-07-10T05:01:57.000Z</published>
    <updated>2023-09-06T07:12:57.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我起初在爬这个<a href="http://cgartt.com/">火熊网</a>却发现这个是JS加载，所以我就打开谷歌开发者工具，查看<strong>XHR</strong>，找到了<em><a href="http://cgartt.com/api/api.php?d=index&c=Index&action=getWorkList">http://cgartt.com/api/api.php?d=index&amp;c=Index&amp;action=getWorkList</a></em></p><p>在这个链接中，用Google的JSON-handleg工具查看json，却发现这个json和preview是有所不同的：</p><p><img src="https://raw.githubusercontent.com/liuweixu/cdn/master/Python-crawler/Form_data1.png"><img src="https://raw.githubusercontent.com/liuweixu/cdn/master/Python-crawler/Form_data2.png"></p><p>（上面两个无论是title还是id以及imageUrl均是不同的）</p><p>所以我很困惑，一度误认为这个是JS加密或JS混淆的，所以就学了如何js加密的破解，不过还是没有找到关于这个的解决办法。后来，在Header一栏中，却发现有“Form data”：</p><p><img src="https://raw.githubusercontent.com/liuweixu/cdn/master/Python-crawler/Form_data3.png"></p><p>这时，我才想起，这个也许是需要通过提交表单才能获取preview上的json，所以就开始尝试提交表单了。</p><h3 id="开始爬取"><a href="#开始爬取" class="headerlink" title="开始爬取"></a>开始爬取</h3><h4 id="确定爬取的目标"><a href="#确定爬取的目标" class="headerlink" title="确定爬取的目标"></a>确定爬取的目标</h4><p>我确定在火熊网上爬取最新上传一栏的前10页，其中，对于排序并没有要求，能爬取并下载图片就行。网址：<a href="http://cgartt.com/">http://cgartt.com/</a></p><h4 id="确定爬取时所用的语言和框架"><a href="#确定爬取时所用的语言和框架" class="headerlink" title="确定爬取时所用的语言和框架"></a>确定爬取时所用的语言和框架</h4><p>Python的<strong>scrapy</strong>，同时，用scrapy的<strong>ImagePipeline</strong>来下载图片。</p><h4 id="爬虫程序"><a href="#爬虫程序" class="headerlink" title="爬虫程序"></a>爬虫程序</h4><h5 id="Begin"><a href="#Begin" class="headerlink" title="Begin:"></a>Begin:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject Huoxiong</span><br><span class="line">scrapy genspider huoXiongImage cgartt.com/</span><br></pre></td></tr></table></figure><p>上面建立scrapy</p><h5 id="spider-huoXiongImage-py"><a href="#spider-huoXiongImage-py" class="headerlink" title="spider&#x2F;huoXiongImage.py"></a>spider&#x2F;huoXiongImage.py</h5><p>这个是整个爬虫程序的重中之重，与爬虫是否成功息息相关的。</p><ul><li><p>其中，base_url_1指的是之前在开发者工具中找到的要查找的json所在的网址；而base_url_2是我在分析图片页的网址时，发现这个是共同的链接，比如：</p><ul><li><p><a href="http://cgartt.com/index_writing_detail.php?work=0&id=2761">http://cgartt.com/index_writing_detail.php?work=0&amp;id=2761</a></p></li><li><p><a href="http://cgartt.com/index_writing_detail.php?work=0&id=27614">http://cgartt.com/index_writing_detail.php?work=0&amp;id=27614</a></p></li><li><p><a href="http://cgartt.com/index_writing_detail.php?work=0&id=27676">http://cgartt.com/index_writing_detail.php?work=0&amp;id=27676</a></p></li></ul><p>在上面随机选择的3个图片页的链接中，可以看出它们几乎相似，唯一不同的地方是<strong>id</strong>，所以从这个思路下手，得到图片页的链接；最后的base_url_3中，这个的查找方法和base_url_1类似，也需要提交表单才能得到需要的信息,用<strong>scrapy.Request()<strong>，method为</strong>‘POST’</strong>，指提交。</p></li><li><p>接下来我觉得需要重写start_requests()，因为如果不重写，那程序将会从start_urls中开始爬取，不符合要从<a href="http://cgartt.com/api/api.php?d=index&c=Index&action=getWorkList%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E7%9A%84%E7%9B%AE%E7%9A%84%E3%80%82">http://cgartt.com/api/api.php?d=index&c=Index&action=getWorkList提交表单的目的。</a></p></li><li><p>下面就是通过base_url_1提交表单得到json后处理，主要是得到<strong>id</strong>，便于和base_url_2组成图片页的链接。</p></li><li><p>然后就是对base_url_3进行提交表单，用**scrapy.FormRequest()**，不过用scrapy.Request()并不能得到需要的内容。最后就是获取图片页的各个图片的链接，图片的标题、作者名字等等。</p></li><li><p>代码如下（HuoxiongimageSpider(scrapy.Spider)类里面）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;huoXiongImage&#x27;</span>  <span class="comment"># 这个name必不可少。</span></span><br><span class="line">allowed_domains = [<span class="string">&#x27;cgartt.com&#x27;</span>]</span><br><span class="line">start_urls = [<span class="string">&#x27;http://cgartt.com/&#x27;</span>]</span><br><span class="line">base_url_1 = <span class="string">&quot;http://cgartt.com/api/api.php?d=index&amp;c=Index&amp;action=getWorkList&quot;</span></span><br><span class="line">base_url_2 = <span class="string">&quot;http://cgartt.com/index_writing_detail.php?work=0&amp;id=&quot;</span></span><br><span class="line">base_url_3 = <span class="string">&quot;http://cgartt.com/api/api.php?d=find&amp;c=FindInfo&amp;action=getWorkDetial&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取前10页。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        data = &#123;<span class="string">&#x27;order&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">        data[<span class="string">&#x27;page&#x27;</span>] = page</span><br><span class="line">        <span class="comment"># 提交表单，为了得到最新上传一栏的1到10页的json。</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url=self.base_url_1, method=<span class="string">&#x27;POST&#x27;</span>, body=json.dumps(data), callback=self.parse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析提交表单后得到的数据。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    text = response.text</span><br><span class="line">    text = text[<span class="number">18</span>:] <span class="comment"># 这个是为了去掉空格，从而能确保转化为json过程中没有出错。</span></span><br><span class="line">    text = json.loads(text)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">list</span> <span class="keyword">in</span> text[<span class="string">&#x27;list&#x27;</span>]:</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">list</span>[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        url = self.base_url_2 + <span class="built_in">id</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url=url, callback=self.parse_page, meta=&#123;<span class="string">&#x27;id&#x27;</span>: <span class="built_in">id</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_page</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="built_in">id</span> = response.meta[<span class="string">&#x27;id&#x27;</span>]  <span class="comment"># 这个不能写成response[&#x27;id&#x27;]</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;id&#x27;</span>: <span class="built_in">id</span>&#125;</span><br><span class="line">    <span class="comment"># 不知怎么的，用FormRequest能得到需要的数据，而Request不能，所以一个不能用时，考虑用另一个。</span></span><br><span class="line">    <span class="keyword">yield</span> FormRequest(url=self.base_url_3, formdata=data, method=<span class="string">&#x27;POST&#x27;</span>, callback=self.parse_detail)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在图片页面获取图片的链接用于下载。另外也获取图片的id，标题和作者。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>(<span class="params">self, response</span>):</span><br><span class="line">    text = response.text</span><br><span class="line">    text = text[<span class="number">8</span>:]</span><br><span class="line">    text = json.loads(text)</span><br><span class="line">    images = text[<span class="string">&#x27;worksInfo&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images[<span class="string">&#x27;imageUrl&#x27;</span>]:</span><br><span class="line">        item = HuoxiongItem()</span><br><span class="line">        item[<span class="string">&#x27;img&#x27;</span>] = image[<span class="string">&#x27;imageUrl&#x27;</span>]</span><br><span class="line">        item[<span class="string">&#x27;title&#x27;</span>] = images[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">        item[<span class="string">&#x27;Name&#x27;</span>] = images[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">        item[<span class="string">&#x27;id&#x27;</span>] = images[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure></li></ul><h5 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a>items.py</h5><p>这个是构建Item()的.(HuoxiongItem(scrapy.Item)类)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define the fields for your item here like:</span></span><br><span class="line"><span class="comment"># name = scrapy.Field()</span></span><br><span class="line">title = Field()</span><br><span class="line">img = Field()</span><br><span class="line">Name = Field()</span><br><span class="line"><span class="built_in">id</span> = Field()</span><br></pre></td></tr></table></figure><h5 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a>pipelines.py</h5><p>&#x3D;需要引入scrapy.pipelines.images的ImagesPipeline</p><p>并将HuoxiongPipeline()类继承imagesPipeline类，重写file_path()和get_media_requests()方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuoxiongPipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line"><span class="comment"># def process_item(self, item, spider):</span></span><br><span class="line"><span class="comment">#     return item</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_path</span>(<span class="params">self, request, response=<span class="literal">None</span>, info=<span class="literal">None</span></span>):</span><br><span class="line">    item = request.meta[<span class="string">&#x27;meta&#x27;</span>]</span><br><span class="line">    file_name = item[<span class="string">&#x27;Name&#x27;</span>] + <span class="string">&quot;/&quot;</span> + item[<span class="string">&#x27;id&#x27;</span>] + <span class="string">&quot;/&quot;</span> + item[<span class="string">&#x27;title&#x27;</span>] + <span class="string">&quot;/&quot;</span> + item[<span class="string">&#x27;img&#x27;</span>].split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>] <span class="comment"># 这个是构建一个具有层次结构的文件的小尝试。</span></span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_media_requests</span>(<span class="params">self, item, info</span>):</span><br><span class="line">    <span class="keyword">yield</span> Request(url=item[<span class="string">&#x27;img&#x27;</span>], meta=&#123;<span class="string">&#x27;meta&#x27;</span>: item&#125;)</span><br></pre></td></tr></table></figure><h5 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h5><p>还得添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">&#x27;Huoxiong.pipelines.HuoxiongPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMAGES_STORE = <span class="string">&#x27;./image&#x27;</span></span><br></pre></td></tr></table></figure><p>需要去掉<em>ITEM_PIPELINES</em>所在的三行的注释，然后写上<strong>IMAGES_STORE &#x3D; ‘.&#x2F;image’</strong>，其中注意 <strong>“IMAGES_STORE”</strong> 不能写错。</p><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>最后在Terminal上scrapy crawl huoXiongImage就可以爬了，目前可以正常爬取的。</p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>完整的代码见于：</p><p><a href="https://github.com/liuweixu/Python-crawler/tree/master/Scrapy/%E7%81%AB%E7%86%8A%E7%BD%91%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96%E4%B8%8B%E8%BD%BD/Huoxiong">liuweixu’s Github</a></p>]]></content>
    
    
    <summary type="html">通过scrapy提交表单获得需要的信息（json），并通过这些信息下载图片。</summary>
    
    
    
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
